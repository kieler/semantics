/*
 * generated by Xtext 2.10.0
 */
package de.cau.cs.kieler.railsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class RailSLGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.Program");
		private final Assignment cBlocksAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cBlocksBlockParserRuleCall_0 = (RuleCall)cBlocksAssignment.eContents().get(0);
		
		//Program:
		//	blocks+=Block*;
		@Override public ParserRule getRule() { return rule; }
		
		//blocks+=Block*
		public Assignment getBlocksAssignment() { return cBlocksAssignment; }
		
		//Block
		public RuleCall getBlocksBlockParserRuleCall_0() { return cBlocksBlockParserRuleCall_0; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStartKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_1_0 = (RuleCall)cStatementsAssignment_1.eContents().get(0);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndBLOCK_ENDParserRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//Block:
		//	'Start:' statements+=Statement+ end=BLOCK_END;
		@Override public ParserRule getRule() { return rule; }
		
		//'Start:' statements+=Statement+ end=BLOCK_END
		public Group getGroup() { return cGroup; }
		
		//'Start:'
		public Keyword getStartKeyword_0() { return cStartKeyword_0; }
		
		//statements+=Statement+
		public Assignment getStatementsAssignment_1() { return cStatementsAssignment_1; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_1_0() { return cStatementsStatementParserRuleCall_1_0; }
		
		//end=BLOCK_END
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }
		
		//BLOCK_END
		public RuleCall getEndBLOCK_ENDParserRuleCall_2_0() { return cEndBLOCK_ENDParserRuleCall_2_0; }
	}
	public class BLOCK_ENDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.BLOCK_END");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEndKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLoopKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BLOCK_END:
		//	'End.' | 'Loop.';
		@Override public ParserRule getRule() { return rule; }
		
		//'End.' | 'Loop.'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'End.'
		public Keyword getEndKeyword_0() { return cEndKeyword_0; }
		
		//'Loop.'
		public Keyword getLoopKeyword_1() { return cLoopKeyword_1; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWaitStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cOpStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cConditionalStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Statement:
		//	SetStatement | WaitStatement | OpStatement | ConditionalStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//SetStatement | WaitStatement | OpStatement | ConditionalStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SetStatement
		public RuleCall getSetStatementParserRuleCall_0() { return cSetStatementParserRuleCall_0; }
		
		//WaitStatement
		public RuleCall getWaitStatementParserRuleCall_1() { return cWaitStatementParserRuleCall_1; }
		
		//OpStatement
		public RuleCall getOpStatementParserRuleCall_2() { return cOpStatementParserRuleCall_2; }
		
		//ConditionalStatement
		public RuleCall getConditionalStatementParserRuleCall_3() { return cConditionalStatementParserRuleCall_3; }
	}
	public class SetStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.SetStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetTrackStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSetPointStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SetStatement:
		//	SetTrackStatement | SetPointStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//SetTrackStatement | SetPointStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SetTrackStatement
		public RuleCall getSetTrackStatementParserRuleCall_0() { return cSetTrackStatementParserRuleCall_0; }
		
		//SetPointStatement
		public RuleCall getSetPointStatementParserRuleCall_1() { return cSetPointStatementParserRuleCall_1; }
	}
	public class SetTrackStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.SetTrackStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSetTrackKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSegmentsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSegmentsSEG_NAMETerminalRuleCall_1_0 = (RuleCall)cSegmentsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaSpaceKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSegmentsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSegmentsSEG_NAMETerminalRuleCall_2_1_0 = (RuleCall)cSegmentsAssignment_2_1.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cAndKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cSegmentsAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cSegmentsSEG_NAMETerminalRuleCall_3_0_1_0 = (RuleCall)cSegmentsAssignment_3_0_1.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cAndKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cSegmentsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cSegmentsSEG_NAMETerminalRuleCall_3_1_1_0 = (RuleCall)cSegmentsAssignment_3_1_1.eContents().get(0);
		private final Keyword cToKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cModeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cModeTrackSettingParserRuleCall_5_0 = (RuleCall)cModeAssignment_5.eContents().get(0);
		private final Keyword cFullStopKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//SetTrackStatement:
		//	'Set track' segments+=SEG_NAME (', ' segments+=SEG_NAME)* ('and' segments+=SEG_NAME | ', and' segments+=SEG_NAME)?
		//	'to' mode=TrackSetting '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'Set track' segments+=SEG_NAME (', ' segments+=SEG_NAME)* ('and' segments+=SEG_NAME | ', and' segments+=SEG_NAME)? 'to'
		//mode=TrackSetting '.'
		public Group getGroup() { return cGroup; }
		
		//'Set track'
		public Keyword getSetTrackKeyword_0() { return cSetTrackKeyword_0; }
		
		//segments+=SEG_NAME
		public Assignment getSegmentsAssignment_1() { return cSegmentsAssignment_1; }
		
		//SEG_NAME
		public RuleCall getSegmentsSEG_NAMETerminalRuleCall_1_0() { return cSegmentsSEG_NAMETerminalRuleCall_1_0; }
		
		//(', ' segments+=SEG_NAME)*
		public Group getGroup_2() { return cGroup_2; }
		
		//', '
		public Keyword getCommaSpaceKeyword_2_0() { return cCommaSpaceKeyword_2_0; }
		
		//segments+=SEG_NAME
		public Assignment getSegmentsAssignment_2_1() { return cSegmentsAssignment_2_1; }
		
		//SEG_NAME
		public RuleCall getSegmentsSEG_NAMETerminalRuleCall_2_1_0() { return cSegmentsSEG_NAMETerminalRuleCall_2_1_0; }
		
		//('and' segments+=SEG_NAME | ', and' segments+=SEG_NAME)?
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//'and' segments+=SEG_NAME
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//'and'
		public Keyword getAndKeyword_3_0_0() { return cAndKeyword_3_0_0; }
		
		//segments+=SEG_NAME
		public Assignment getSegmentsAssignment_3_0_1() { return cSegmentsAssignment_3_0_1; }
		
		//SEG_NAME
		public RuleCall getSegmentsSEG_NAMETerminalRuleCall_3_0_1_0() { return cSegmentsSEG_NAMETerminalRuleCall_3_0_1_0; }
		
		//', and' segments+=SEG_NAME
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//', and'
		public Keyword getAndKeyword_3_1_0() { return cAndKeyword_3_1_0; }
		
		//segments+=SEG_NAME
		public Assignment getSegmentsAssignment_3_1_1() { return cSegmentsAssignment_3_1_1; }
		
		//SEG_NAME
		public RuleCall getSegmentsSEG_NAMETerminalRuleCall_3_1_1_0() { return cSegmentsSEG_NAMETerminalRuleCall_3_1_1_0; }
		
		//'to'
		public Keyword getToKeyword_4() { return cToKeyword_4; }
		
		//mode=TrackSetting
		public Assignment getModeAssignment_5() { return cModeAssignment_5; }
		
		//TrackSetting
		public RuleCall getModeTrackSettingParserRuleCall_5_0() { return cModeTrackSettingParserRuleCall_5_0; }
		
		//'.'
		public Keyword getFullStopKeyword_6() { return cFullStopKeyword_6; }
	}
	public class TrackSettingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.TrackSetting");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Keyword cFullKeyword_0_0_0 = (Keyword)cAlternatives_0_0.eContents().get(0);
		private final Keyword cSlowKeyword_0_0_1 = (Keyword)cAlternatives_0_0.eContents().get(1);
		private final Keyword cReverseKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cStopKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//TrackSetting:
		//	('full' | 'slow') 'reverse'? | 'stop';
		@Override public ParserRule getRule() { return rule; }
		
		//('full' | 'slow') 'reverse'? | 'stop'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//('full' | 'slow') 'reverse'?
		public Group getGroup_0() { return cGroup_0; }
		
		//('full' | 'slow')
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }
		
		//'full'
		public Keyword getFullKeyword_0_0_0() { return cFullKeyword_0_0_0; }
		
		//'slow'
		public Keyword getSlowKeyword_0_0_1() { return cSlowKeyword_0_0_1; }
		
		//'reverse'?
		public Keyword getReverseKeyword_0_1() { return cReverseKeyword_0_1; }
		
		//'stop'
		public Keyword getStopKeyword_1() { return cStopKeyword_1; }
	}
	public class SetPointStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.SetPointStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSetPointKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPointsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPointsINTTerminalRuleCall_1_0 = (RuleCall)cPointsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaSpaceKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPointsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPointsINTTerminalRuleCall_2_1_0 = (RuleCall)cPointsAssignment_2_1.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cAndKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cPointsAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cPointsINTTerminalRuleCall_3_0_1_0 = (RuleCall)cPointsAssignment_3_0_1.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cAndKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cPointsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cPointsINTTerminalRuleCall_3_1_1_0 = (RuleCall)cPointsAssignment_3_1_1.eContents().get(0);
		private final Keyword cToKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cOrientationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Alternatives cOrientationAlternatives_5_0 = (Alternatives)cOrientationAssignment_5.eContents().get(0);
		private final Keyword cOrientationStraightKeyword_5_0_0 = (Keyword)cOrientationAlternatives_5_0.eContents().get(0);
		private final Keyword cOrientationBranchKeyword_5_0_1 = (Keyword)cOrientationAlternatives_5_0.eContents().get(1);
		private final Keyword cFullStopKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//SetPointStatement:
		//	'Set point' points+=INT (', ' points+=INT)* ('and' points+=INT | ', and' points+=INT)? 'to' orientation=('straight' |
		//	'branch') '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'Set point' points+=INT (', ' points+=INT)* ('and' points+=INT | ', and' points+=INT)? 'to' orientation=('straight' |
		//'branch') '.'
		public Group getGroup() { return cGroup; }
		
		//'Set point'
		public Keyword getSetPointKeyword_0() { return cSetPointKeyword_0; }
		
		//points+=INT
		public Assignment getPointsAssignment_1() { return cPointsAssignment_1; }
		
		//INT
		public RuleCall getPointsINTTerminalRuleCall_1_0() { return cPointsINTTerminalRuleCall_1_0; }
		
		//(', ' points+=INT)*
		public Group getGroup_2() { return cGroup_2; }
		
		//', '
		public Keyword getCommaSpaceKeyword_2_0() { return cCommaSpaceKeyword_2_0; }
		
		//points+=INT
		public Assignment getPointsAssignment_2_1() { return cPointsAssignment_2_1; }
		
		//INT
		public RuleCall getPointsINTTerminalRuleCall_2_1_0() { return cPointsINTTerminalRuleCall_2_1_0; }
		
		//('and' points+=INT | ', and' points+=INT)?
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//'and' points+=INT
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//'and'
		public Keyword getAndKeyword_3_0_0() { return cAndKeyword_3_0_0; }
		
		//points+=INT
		public Assignment getPointsAssignment_3_0_1() { return cPointsAssignment_3_0_1; }
		
		//INT
		public RuleCall getPointsINTTerminalRuleCall_3_0_1_0() { return cPointsINTTerminalRuleCall_3_0_1_0; }
		
		//', and' points+=INT
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//', and'
		public Keyword getAndKeyword_3_1_0() { return cAndKeyword_3_1_0; }
		
		//points+=INT
		public Assignment getPointsAssignment_3_1_1() { return cPointsAssignment_3_1_1; }
		
		//INT
		public RuleCall getPointsINTTerminalRuleCall_3_1_1_0() { return cPointsINTTerminalRuleCall_3_1_1_0; }
		
		//'to'
		public Keyword getToKeyword_4() { return cToKeyword_4; }
		
		//orientation=('straight' | 'branch')
		public Assignment getOrientationAssignment_5() { return cOrientationAssignment_5; }
		
		//('straight' | 'branch')
		public Alternatives getOrientationAlternatives_5_0() { return cOrientationAlternatives_5_0; }
		
		//'straight'
		public Keyword getOrientationStraightKeyword_5_0_0() { return cOrientationStraightKeyword_5_0_0; }
		
		//'branch'
		public Keyword getOrientationBranchKeyword_5_0_1() { return cOrientationBranchKeyword_5_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_6() { return cFullStopKeyword_6; }
	}
	public class WaitStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.WaitStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTimeWaitStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cContactWaitStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//WaitStatement:
		//	TimeWaitStatement | ContactWaitStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//TimeWaitStatement | ContactWaitStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TimeWaitStatement
		public RuleCall getTimeWaitStatementParserRuleCall_0() { return cTimeWaitStatementParserRuleCall_0; }
		
		//ContactWaitStatement
		public RuleCall getContactWaitStatementParserRuleCall_1() { return cContactWaitStatementParserRuleCall_1; }
	}
	public class TimeWaitStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.TimeWaitStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWaitForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTimeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTimeINTTerminalRuleCall_1_0 = (RuleCall)cTimeAssignment_1.eContents().get(0);
		private final Keyword cSecondsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//TimeWaitStatement:
		//	'Wait for'+ time=INT+ 'seconds.';
		@Override public ParserRule getRule() { return rule; }
		
		//'Wait for'+ time=INT+ 'seconds.'
		public Group getGroup() { return cGroup; }
		
		//'Wait for'+
		public Keyword getWaitForKeyword_0() { return cWaitForKeyword_0; }
		
		//time=INT+
		public Assignment getTimeAssignment_1() { return cTimeAssignment_1; }
		
		//INT
		public RuleCall getTimeINTTerminalRuleCall_1_0() { return cTimeINTTerminalRuleCall_1_0; }
		
		//'seconds.'
		public Keyword getSecondsKeyword_2() { return cSecondsKeyword_2; }
	}
	public class ContactWaitStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.ContactWaitStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEventAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cEventAlternatives_0_0 = (Alternatives)cEventAssignment_0.eContents().get(0);
		private final Keyword cEventReachKeyword_0_0_0 = (Keyword)cEventAlternatives_0_0.eContents().get(0);
		private final Keyword cEventPassKeyword_0_0_1 = (Keyword)cEventAlternatives_0_0.eContents().get(1);
		private final Assignment cContactIndexAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContactIndexContactIndexParserRuleCall_1_0 = (RuleCall)cContactIndexAssignment_1.eContents().get(0);
		private final Keyword cContactOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSegNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSegNameSEG_NAMETerminalRuleCall_3_0 = (RuleCall)cSegNameAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ContactWaitStatement:
		//	event=('Reach' | 'Pass') contactIndex=ContactIndex 'contact of' segName=SEG_NAME '.';
		@Override public ParserRule getRule() { return rule; }
		
		//event=('Reach' | 'Pass') contactIndex=ContactIndex 'contact of' segName=SEG_NAME '.'
		public Group getGroup() { return cGroup; }
		
		//event=('Reach' | 'Pass')
		public Assignment getEventAssignment_0() { return cEventAssignment_0; }
		
		//('Reach' | 'Pass')
		public Alternatives getEventAlternatives_0_0() { return cEventAlternatives_0_0; }
		
		//'Reach'
		public Keyword getEventReachKeyword_0_0_0() { return cEventReachKeyword_0_0_0; }
		
		//'Pass'
		public Keyword getEventPassKeyword_0_0_1() { return cEventPassKeyword_0_0_1; }
		
		//contactIndex=ContactIndex
		public Assignment getContactIndexAssignment_1() { return cContactIndexAssignment_1; }
		
		//ContactIndex
		public RuleCall getContactIndexContactIndexParserRuleCall_1_0() { return cContactIndexContactIndexParserRuleCall_1_0; }
		
		//'contact of'
		public Keyword getContactOfKeyword_2() { return cContactOfKeyword_2; }
		
		//segName=SEG_NAME
		public Assignment getSegNameAssignment_3() { return cSegNameAssignment_3; }
		
		//SEG_NAME
		public RuleCall getSegNameSEG_NAMETerminalRuleCall_3_0() { return cSegNameSEG_NAMETerminalRuleCall_3_0; }
		
		//'.'
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}
	public class OpStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.OpStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCrossingStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLightStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//OpStatement:
		//	CrossingStatement | LightStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//CrossingStatement | LightStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CrossingStatement
		public RuleCall getCrossingStatementParserRuleCall_0() { return cCrossingStatementParserRuleCall_0; }
		
		//LightStatement
		public RuleCall getLightStatementParserRuleCall_1() { return cLightStatementParserRuleCall_1; }
	}
	public class CrossingStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.CrossingStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cModeAlternatives_0_0 = (Alternatives)cModeAssignment_0.eContents().get(0);
		private final Keyword cModeOpenKeyword_0_0_0 = (Keyword)cModeAlternatives_0_0.eContents().get(0);
		private final Keyword cModeCloseKeyword_0_0_1 = (Keyword)cModeAlternatives_0_0.eContents().get(1);
		private final Keyword cCrossingKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//CrossingStatement:
		//	mode=('Open' | 'Close') 'crossing.';
		@Override public ParserRule getRule() { return rule; }
		
		//mode=('Open' | 'Close') 'crossing.'
		public Group getGroup() { return cGroup; }
		
		//mode=('Open' | 'Close')
		public Assignment getModeAssignment_0() { return cModeAssignment_0; }
		
		//('Open' | 'Close')
		public Alternatives getModeAlternatives_0_0() { return cModeAlternatives_0_0; }
		
		//'Open'
		public Keyword getModeOpenKeyword_0_0_0() { return cModeOpenKeyword_0_0_0; }
		
		//'Close'
		public Keyword getModeCloseKeyword_0_0_1() { return cModeCloseKeyword_0_0_1; }
		
		//'crossing.'
		public Keyword getCrossingKeyword_1() { return cCrossingKeyword_1; }
	}
	public class LightStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.LightStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTurnLightKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLightsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLightsINTTerminalRuleCall_1_0 = (RuleCall)cLightsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaSpaceKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLightsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cLightsINTTerminalRuleCall_2_1_0 = (RuleCall)cLightsAssignment_2_1.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cAlternatives_3.eContents().get(0);
		private final Keyword cAndKeyword_3_0_0 = (Keyword)cGroup_3_0.eContents().get(0);
		private final Assignment cLightsAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cLightsINTTerminalRuleCall_3_0_1_0 = (RuleCall)cLightsAssignment_3_0_1.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cAndKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cLightsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cLightsINTTerminalRuleCall_3_1_1_0 = (RuleCall)cLightsAssignment_3_1_1.eContents().get(0);
		private final Assignment cStateAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Alternatives cStateAlternatives_4_0 = (Alternatives)cStateAssignment_4.eContents().get(0);
		private final Keyword cStateOnKeyword_4_0_0 = (Keyword)cStateAlternatives_4_0.eContents().get(0);
		private final Keyword cStateOffKeyword_4_0_1 = (Keyword)cStateAlternatives_4_0.eContents().get(1);
		private final Keyword cFullStopKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LightStatement:
		//	'Turn light' lights+=INT (', ' lights+=INT)* ('and' lights+=INT | ', and' lights+=INT)? state=('on' | 'off') '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'Turn light' lights+=INT (', ' lights+=INT)* ('and' lights+=INT | ', and' lights+=INT)? state=('on' | 'off') '.'
		public Group getGroup() { return cGroup; }
		
		//'Turn light'
		public Keyword getTurnLightKeyword_0() { return cTurnLightKeyword_0; }
		
		//lights+=INT
		public Assignment getLightsAssignment_1() { return cLightsAssignment_1; }
		
		//INT
		public RuleCall getLightsINTTerminalRuleCall_1_0() { return cLightsINTTerminalRuleCall_1_0; }
		
		//(', ' lights+=INT)*
		public Group getGroup_2() { return cGroup_2; }
		
		//', '
		public Keyword getCommaSpaceKeyword_2_0() { return cCommaSpaceKeyword_2_0; }
		
		//lights+=INT
		public Assignment getLightsAssignment_2_1() { return cLightsAssignment_2_1; }
		
		//INT
		public RuleCall getLightsINTTerminalRuleCall_2_1_0() { return cLightsINTTerminalRuleCall_2_1_0; }
		
		//('and' lights+=INT | ', and' lights+=INT)?
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//'and' lights+=INT
		public Group getGroup_3_0() { return cGroup_3_0; }
		
		//'and'
		public Keyword getAndKeyword_3_0_0() { return cAndKeyword_3_0_0; }
		
		//lights+=INT
		public Assignment getLightsAssignment_3_0_1() { return cLightsAssignment_3_0_1; }
		
		//INT
		public RuleCall getLightsINTTerminalRuleCall_3_0_1_0() { return cLightsINTTerminalRuleCall_3_0_1_0; }
		
		//', and' lights+=INT
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//', and'
		public Keyword getAndKeyword_3_1_0() { return cAndKeyword_3_1_0; }
		
		//lights+=INT
		public Assignment getLightsAssignment_3_1_1() { return cLightsAssignment_3_1_1; }
		
		//INT
		public RuleCall getLightsINTTerminalRuleCall_3_1_1_0() { return cLightsINTTerminalRuleCall_3_1_1_0; }
		
		//state=('on' | 'off')
		public Assignment getStateAssignment_4() { return cStateAssignment_4; }
		
		//('on' | 'off')
		public Alternatives getStateAlternatives_4_0() { return cStateAlternatives_4_0; }
		
		//'on'
		public Keyword getStateOnKeyword_4_0_0() { return cStateOnKeyword_4_0_0; }
		
		//'off'
		public Keyword getStateOffKeyword_4_0_1() { return cStateOffKeyword_4_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_5() { return cFullStopKeyword_5; }
	}
	public class ConditionalStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.ConditionalStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBranchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLinesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLinesConditionalLineParserRuleCall_1_0 = (RuleCall)cLinesAssignment_1.eContents().get(0);
		private final Assignment cLinesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLinesConditionalLineParserRuleCall_2_0 = (RuleCall)cLinesAssignment_2.eContents().get(0);
		
		//ConditionalStatement:
		//	'Branch:'
		//	lines+=ConditionalLine
		//	lines+=ConditionalLine+;
		@Override public ParserRule getRule() { return rule; }
		
		//'Branch:' lines+=ConditionalLine lines+=ConditionalLine+
		public Group getGroup() { return cGroup; }
		
		//'Branch:'
		public Keyword getBranchKeyword_0() { return cBranchKeyword_0; }
		
		//lines+=ConditionalLine
		public Assignment getLinesAssignment_1() { return cLinesAssignment_1; }
		
		//ConditionalLine
		public RuleCall getLinesConditionalLineParserRuleCall_1_0() { return cLinesConditionalLineParserRuleCall_1_0; }
		
		//lines+=ConditionalLine+
		public Assignment getLinesAssignment_2() { return cLinesAssignment_2; }
		
		//ConditionalLine
		public RuleCall getLinesConditionalLineParserRuleCall_2_0() { return cLinesConditionalLineParserRuleCall_2_0; }
	}
	public class ConditionalLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.ConditionalLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cContactAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContactContactIndexParserRuleCall_1_0 = (RuleCall)cContactAssignment_1.eContents().get(0);
		private final Keyword cContactOfKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSegNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSegNameSEG_NAMETerminalRuleCall_3_0 = (RuleCall)cSegNameAssignment_3.eContents().get(0);
		private final Keyword cIsReachedFirstDoKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBlockBlockParserRuleCall_5_0 = (RuleCall)cBlockAssignment_5.eContents().get(0);
		
		//ConditionalLine:
		//	'If' contact=ContactIndex 'contact of' segName=SEG_NAME 'is reached first, do'+ block=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//'If' contact=ContactIndex 'contact of' segName=SEG_NAME 'is reached first, do'+ block=Block
		public Group getGroup() { return cGroup; }
		
		//'If'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//contact=ContactIndex
		public Assignment getContactAssignment_1() { return cContactAssignment_1; }
		
		//ContactIndex
		public RuleCall getContactContactIndexParserRuleCall_1_0() { return cContactContactIndexParserRuleCall_1_0; }
		
		//'contact of'
		public Keyword getContactOfKeyword_2() { return cContactOfKeyword_2; }
		
		//segName=SEG_NAME
		public Assignment getSegNameAssignment_3() { return cSegNameAssignment_3; }
		
		//SEG_NAME
		public RuleCall getSegNameSEG_NAMETerminalRuleCall_3_0() { return cSegNameSEG_NAMETerminalRuleCall_3_0; }
		
		//'is reached first, do'+
		public Keyword getIsReachedFirstDoKeyword_4() { return cIsReachedFirstDoKeyword_4; }
		
		//block=Block
		public Assignment getBlockAssignment_5() { return cBlockAssignment_5; }
		
		//Block
		public RuleCall getBlockBlockParserRuleCall_5_0() { return cBlockBlockParserRuleCall_5_0; }
	}
	public class ContactIndexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.ContactIndex");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFirstKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSecondKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//ContactIndex:
		//	'first' | 'second';
		@Override public ParserRule getRule() { return rule; }
		
		//'first' | 'second'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'first'
		public Keyword getFirstKeyword_0() { return cFirstKeyword_0; }
		
		//'second'
		public Keyword getSecondKeyword_1() { return cSecondKeyword_1; }
	}
	
	
	private final ProgramElements pProgram;
	private final BlockElements pBlock;
	private final BLOCK_ENDElements pBLOCK_END;
	private final StatementElements pStatement;
	private final SetStatementElements pSetStatement;
	private final SetTrackStatementElements pSetTrackStatement;
	private final TrackSettingElements pTrackSetting;
	private final SetPointStatementElements pSetPointStatement;
	private final WaitStatementElements pWaitStatement;
	private final TimeWaitStatementElements pTimeWaitStatement;
	private final ContactWaitStatementElements pContactWaitStatement;
	private final OpStatementElements pOpStatement;
	private final CrossingStatementElements pCrossingStatement;
	private final LightStatementElements pLightStatement;
	private final ConditionalStatementElements pConditionalStatement;
	private final ConditionalLineElements pConditionalLine;
	private final ContactIndexElements pContactIndex;
	private final TerminalRule tSEG_NAME;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public RailSLGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.pBlock = new BlockElements();
		this.pBLOCK_END = new BLOCK_ENDElements();
		this.pStatement = new StatementElements();
		this.pSetStatement = new SetStatementElements();
		this.pSetTrackStatement = new SetTrackStatementElements();
		this.pTrackSetting = new TrackSettingElements();
		this.pSetPointStatement = new SetPointStatementElements();
		this.pWaitStatement = new WaitStatementElements();
		this.pTimeWaitStatement = new TimeWaitStatementElements();
		this.pContactWaitStatement = new ContactWaitStatementElements();
		this.pOpStatement = new OpStatementElements();
		this.pCrossingStatement = new CrossingStatementElements();
		this.pLightStatement = new LightStatementElements();
		this.pConditionalStatement = new ConditionalStatementElements();
		this.pConditionalLine = new ConditionalLineElements();
		this.pContactIndex = new ContactIndexElements();
		this.tSEG_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.railsl.RailSL.SEG_NAME");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.railsl.RailSL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Program:
	//	blocks+=Block*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//Block:
	//	'Start:' statements+=Statement+ end=BLOCK_END;
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//BLOCK_END:
	//	'End.' | 'Loop.';
	public BLOCK_ENDElements getBLOCK_ENDAccess() {
		return pBLOCK_END;
	}
	
	public ParserRule getBLOCK_ENDRule() {
		return getBLOCK_ENDAccess().getRule();
	}
	
	//Statement:
	//	SetStatement | WaitStatement | OpStatement | ConditionalStatement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//SetStatement:
	//	SetTrackStatement | SetPointStatement;
	public SetStatementElements getSetStatementAccess() {
		return pSetStatement;
	}
	
	public ParserRule getSetStatementRule() {
		return getSetStatementAccess().getRule();
	}
	
	//SetTrackStatement:
	//	'Set track' segments+=SEG_NAME (', ' segments+=SEG_NAME)* ('and' segments+=SEG_NAME | ', and' segments+=SEG_NAME)?
	//	'to' mode=TrackSetting '.';
	public SetTrackStatementElements getSetTrackStatementAccess() {
		return pSetTrackStatement;
	}
	
	public ParserRule getSetTrackStatementRule() {
		return getSetTrackStatementAccess().getRule();
	}
	
	//TrackSetting:
	//	('full' | 'slow') 'reverse'? | 'stop';
	public TrackSettingElements getTrackSettingAccess() {
		return pTrackSetting;
	}
	
	public ParserRule getTrackSettingRule() {
		return getTrackSettingAccess().getRule();
	}
	
	//SetPointStatement:
	//	'Set point' points+=INT (', ' points+=INT)* ('and' points+=INT | ', and' points+=INT)? 'to' orientation=('straight' |
	//	'branch') '.';
	public SetPointStatementElements getSetPointStatementAccess() {
		return pSetPointStatement;
	}
	
	public ParserRule getSetPointStatementRule() {
		return getSetPointStatementAccess().getRule();
	}
	
	//WaitStatement:
	//	TimeWaitStatement | ContactWaitStatement;
	public WaitStatementElements getWaitStatementAccess() {
		return pWaitStatement;
	}
	
	public ParserRule getWaitStatementRule() {
		return getWaitStatementAccess().getRule();
	}
	
	//TimeWaitStatement:
	//	'Wait for'+ time=INT+ 'seconds.';
	public TimeWaitStatementElements getTimeWaitStatementAccess() {
		return pTimeWaitStatement;
	}
	
	public ParserRule getTimeWaitStatementRule() {
		return getTimeWaitStatementAccess().getRule();
	}
	
	//ContactWaitStatement:
	//	event=('Reach' | 'Pass') contactIndex=ContactIndex 'contact of' segName=SEG_NAME '.';
	public ContactWaitStatementElements getContactWaitStatementAccess() {
		return pContactWaitStatement;
	}
	
	public ParserRule getContactWaitStatementRule() {
		return getContactWaitStatementAccess().getRule();
	}
	
	//OpStatement:
	//	CrossingStatement | LightStatement;
	public OpStatementElements getOpStatementAccess() {
		return pOpStatement;
	}
	
	public ParserRule getOpStatementRule() {
		return getOpStatementAccess().getRule();
	}
	
	//CrossingStatement:
	//	mode=('Open' | 'Close') 'crossing.';
	public CrossingStatementElements getCrossingStatementAccess() {
		return pCrossingStatement;
	}
	
	public ParserRule getCrossingStatementRule() {
		return getCrossingStatementAccess().getRule();
	}
	
	//LightStatement:
	//	'Turn light' lights+=INT (', ' lights+=INT)* ('and' lights+=INT | ', and' lights+=INT)? state=('on' | 'off') '.';
	public LightStatementElements getLightStatementAccess() {
		return pLightStatement;
	}
	
	public ParserRule getLightStatementRule() {
		return getLightStatementAccess().getRule();
	}
	
	//ConditionalStatement:
	//	'Branch:'
	//	lines+=ConditionalLine
	//	lines+=ConditionalLine+;
	public ConditionalStatementElements getConditionalStatementAccess() {
		return pConditionalStatement;
	}
	
	public ParserRule getConditionalStatementRule() {
		return getConditionalStatementAccess().getRule();
	}
	
	//ConditionalLine:
	//	'If' contact=ContactIndex 'contact of' segName=SEG_NAME 'is reached first, do'+ block=Block;
	public ConditionalLineElements getConditionalLineAccess() {
		return pConditionalLine;
	}
	
	public ParserRule getConditionalLineRule() {
		return getConditionalLineAccess().getRule();
	}
	
	//ContactIndex:
	//	'first' | 'second';
	public ContactIndexElements getContactIndexAccess() {
		return pContactIndex;
	}
	
	public ParserRule getContactIndexRule() {
		return getContactIndexAccess().getRule();
	}
	
	//terminal SEG_NAME:
	//	'KH_ST_0' | 'KH_ST_1' | 'KH_ST_2' | 'KH_ST_3' | 'KH_ST_4' | 'KH_ST_5' | 'KH_ST_6' |
	//	'KH_LN_0' | 'KH_LN_1' | 'KH_LN_2' | 'KH_LN_3' | 'KH_LN_4' | 'KH_LN_5' | 'KH_LN_6' | 'KH_LN_7' | 'KH_LN_8' |
	//	'KIO_LN_0' | 'KIO_LN_1' | 'OC_ST_0' | 'OC_ST_1' | 'OC_ST_2' | 'OC_ST_3' | 'OC_ST_4' |
	//	'OC_LN_0' | 'OC_LN_1' | 'OC_LN_2' | 'OC_LN_3' | 'OC_LN_4' | 'OC_LN_5' |
	//	'IC_ST_0' | 'IC_ST_1' | 'IC_ST_2' | 'IC_ST_3' | 'IC_ST_4' |
	//	'IC_LN_0' | 'IC_LN_1' | 'IC_LN_2' | 'IC_LN_3' | 'IC_LN_4' | 'IC_LN_5' |
	//	'OC_JCT_0' | 'IC_JCT_0' | 'OI_LN_0' | 'OI_LN_1' | 'OI_LN_2' |
	//	'IO_LN_0' | 'IO_LN_1' | 'IO_LN_2';
	public TerminalRule getSEG_NAMERule() {
		return tSEG_NAME;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
