«REM»
	Template file for triggers and effects of transitions and actions. 
«ENDREM»

«IMPORT synccharts»
«IMPORT kexpressions»

«EXTENSION Helper»

«REM»
	Entry point for triggers. It will be distinguished if
	the ritgger is simple or complex. Then the effects will be generated.
«ENDREM»
«DEFINE trigger FOR Action-»
	«IF !(this.label == null)-»
		«IF !(this.trigger == null)-»
			«IF (this.trigger.metaType == ValuedObjectReference 
			     && ((ValuedObjectReference)this.trigger).valuedObject.metaType == Signal)-»
				«EXPAND simpleTrigger FOR this-»
			«ELSEIF (this.trigger.metaType == ComplexExpression)-»
				«EXPAND complexTrigger FOR this-»
			«ELSE-»
				/* error while generating code */
			«ENDIF-»
		«ELSE-»
			«EXPAND effects FOR this-»
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«DEFINE simpleTrigger FOR Action-»
	if («EXPAND ifRequest FOR this-») {
		«EXPAND effects FOR this-»
		«EXPAND CodegenPriority::priorityReduction FOR this-»
	}
«ENDDEFINE»

«DEFINE complexTrigger FOR Action-»
	if («EXPAND ifRequest FOR this-») {
		«EXPAND effects FOR this-»
		«EXPAND stateAbortion FOR (Transition)this-»
	}
«ENDDEFINE»

«REM»
	This template distinguishes if the request is a boolean value, an expression or
	a signal reference. 
«ENDREM»
«DEFINE ifRequest FOR Action-»
	«IF (this.trigger.metaType == BooleanValue)-»
		«EXPAND getValue FOR this.trigger-»
	«ELSEIF this.trigger.metaType == OperatorExpression-»
		«EXPAND complexExpression FOR ((OperatorExpression)this.trigger)-»
	«ELSEIF this.trigger.metaType == ValuedObjectReference-»
		PRESENT(sig_«((ValuedObjectReference)this.trigger).valuedObject.name-»)
	«ELSE-»
		/* unknown if request */
	«ENDIF-»
«ENDDEFINE»

«REM»
	Emission of int values, bool values or pure signals. 
«ENDREM»
«DEFINE effects FOR Action-»
	«FOREACH this.effects AS effect-»
		«IF ((Emission)effect).signal.type == ValueType::INT-»
			«EXPAND valuedIntegerSignal FOR ((Emission)effect)-»
		«ELSEIF ((Emission)effect).signal.type == ValueType::BOOL-»
			«EXPAND valuedBooleanSignal FOR ((Emission)effect)-»
		«ELSE-»
			EMIT(sig_«((Emission)effect).signal.name-»);
		«ENDIF-»
	«ENDFOREACH-»
«ENDDEFINE»

«REM»
	Valued integer signals with its combine functions 
«ENDREM»
«DEFINE valuedIntegerSignal FOR Emission-»
	«IF this.signal.combineOperator == CombineOperator::NONE-»
		EMITINT(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MULT-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMUL(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::ADD-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTADD(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MAX-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMAX(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::MIN-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITINTMIN(«EXPAND signalAndValue FOR this-»);
	«ENDIF-»
	«IF this.signal.combineOperator == CombineOperator::MULT || this.signal.combineOperator == CombineOperator::ADD || this.signal.combineOperator == CombineOperator::MAX || this.signal.combineOperator == CombineOperator::MIN-»
		} else {
			EMITINT(«EXPAND signalAndValue FOR this-»);
		}
	«ENDIF»
«ENDDEFINE»

«REM»
	Valued boolean signals with its combine functions 
«ENDREM»
«DEFINE valuedBooleanSignal FOR Emission-»
	«IF this.signal.combineOperator == CombineOperator::NONE-»
		EMITBOOL(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::AND-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITBOOLAND(«EXPAND signalAndValue FOR this-»);
	«ELSEIF this.signal.combineOperator == CombineOperator::OR-»
		if (PRESENT(sig_«this.signal.name-»)){
			EMITBOOLOR(«EXPAND signalAndValue FOR this-»);
	«ENDIF-»
	«IF this.signal.combineOperator == CombineOperator::AND || this.signal.combineOperator == CombineOperator::OR-»
		} else {
			EMITBOOL(«EXPAND signalAndValue FOR this-»);
		}
	«ENDIF»
«ENDDEFINE»

«DEFINE signalAndValue FOR Emission-»
	«IF this.newValue.metaType == kexpressions::OperatorExpression-»
		sig_«this.signal.name», «EXPAND checkExpression FOR this.newValue-»
	«ELSEIF this.newValue.metaType == kexpressions::BooleanValue-»
		sig_«this.signal.name», «EXPAND getValue FOR this.newValue-»
	«ELSE-»
		sig_«this.signal.name», «((IntValue)this.newValue).value-»
	«ENDIF-»
«ENDDEFINE»

«REM»
	For complex expressions we have to distinguish what kind of operator the expression has.
	The default case is <VAL> OP <VAL>.
«ENDREM»
«DEFINE complexExpression FOR OperatorExpression-»
	«IF this.operator == OperatorType::PRE-»
		«EXPAND preOperator FOR this.subExpressions.get(0)-»
	«ELSEIF this.operator == OperatorType::NOT-»
		«EXPAND syncChartsOpToCOp FOR this.operator-»
		«EXPAND checkExpression FOR this.subExpressions.get(0)-»
	«ELSEIF this.operator == OperatorType::VAL-»
		«IF (this.eContainer.metaType == kexpressions::OperatorExpression)-»
			VALPRE(sig_«((ValuedObjectReference)this.subExpressions.get(0)).valuedObject.name-»)
		«ELSE-»
			VAL(sig_«((ValuedObjectReference)this.subExpressions.get(0)).valuedObject.name-»)
		«ENDIF-»
	«ELSE-»
		«EXPAND checkExpression FOR this.subExpressions.get(0)-»
		«EXPAND syncChartsOpToCOp FOR this.operator-»
		«EXPAND checkExpression FOR this.subExpressions.get(1)-»
	«ENDIF-»
«ENDDEFINE»

«REM»
	simple signal reference 
«ENDREM»
«DEFINE valuedObjectReference FOR ValuedObjectReference-»
	PRESENT(sig_«this.valuedObject.name»)
«ENDDEFINE»

«REM»
	Pre operator for signal references or complex types. 
«ENDREM»
«DEFINE preOperator FOR Expression-»
	«IF this.metaType == OperatorExpression-»
		«EXPAND complexExpression FOR (OperatorExpression) this-»
	«ELSEIF this.metaType == ValuedObjectReference-»
		PRESENTPRE(sig_«((ValuedObjectReference)this).valuedObject.name-»)
	«ELSE»
		«EXPAND getValue FOR this-»
	«ENDIF»
«ENDDEFINE»

«REM»
	This checks if an expression is weather a complex expression or a signal reference. 
«ENDREM»
«DEFINE checkExpression FOR Expression-»
	«IF this.metaType == OperatorExpression-»
		(«EXPAND complexExpression FOR (OperatorExpression)this-»)
	«ELSEIF this.metaType == ValuedObjectReference-»
		«EXPAND valuedObjectReference FOR (ValuedObjectReference)this-»
	«ELSE»
		«EXPAND getValue FOR this-»
	«ENDIF»
«ENDDEFINE»

«REM»
	Returns the value of valued signals.
«ENDREM»
«DEFINE getValue FOR Expression-»
	/* metatype:  «((Value)this).metaType» */
	«IF ((Value)this).metaType == kexpressions::IntValue-»
		«((IntValue)this).value-»
	«ELSEIF ((Value)this).metaType == kexpressions::FloatValue-»
		«((FloatValue)this).value-»
	«ELSEIF((Value)this).metaType == kexpressions::FloatValue-»
		«IF ((BooleanValue)this).value-»
			1
		«ELSE-»
			0
		«ENDIF-»
	«ENDIF-»
«ENDDEFINE»

«REM»
	Returns the C operator depending on the operator in the SyncCharts metamodel
«ENDREM»
«DEFINE syncChartsOpToCOp FOR OperatorType-»
	«IF this == OperatorType::AND-»
		&&
	«ELSEIF this == OperatorType::OR»
		||
	«ELSEIF this == OperatorType::NOT»
		!
	«ELSEIF this == OperatorType::EQ»
		==
	«ELSEIF this == OperatorType::NE»
		!=
	«ELSEIF this == OperatorType::LT»
		<
	«ELSEIF this == OperatorType::GT»
		>
	«ELSEIF this == OperatorType::LEQ»
		<=
	«ELSEIF this == OperatorType::GEQ»
		>=
	«ELSEIF this == OperatorType::ADD»
		+
	«ELSEIF this == OperatorType::SUB»
		-
	«ELSEIF this == OperatorType::MULT»
		*
	«ELSEIF this == OperatorType::DIV»
		/
	«ELSEIF this == OperatorType::MOD»
		%
	«ENDIF-»
«ENDDEFINE»

«REM»
	This template handles the differend cases of aborting a state.
«ENDREM»
«DEFINE stateAbortion FOR Transition-»
	«IF this.type != TransitionType::NORMALTERMINATION-»
		«IF !(this.sourceState.regions.isEmpty)-»
			«IF this.type != TransitionType::STRONGABORT-»
				PRIO(«getRealThreadPriority(this.targetState)»);
			«ENDIF-»
			ABORT;
			«IF this.type == TransitionType::STRONGABORT-»
				PRIO(«getRealThreadPriority(this.targetState)»);
			«ENDIF-»
		«ENDIF-»
		«EXPAND CodegenPriority::priorityReduction FOR this-»
	«ENDIF-»
	«EXPAND transitionWithoutTriggersAndEffects FOR this-»
«ENDDEFINE»

«DEFINE transitionWithoutTriggersAndEffects FOR Transition-»
	GOTO(L_«getStateNameByFlag(this.targetState, 3)»);
«ENDDEFINE»

«REM»
	Templates for delayed triggers 
«ENDREM»
«DEFINE delayedTrigger FOR Transition-»
	«IF this.delay > 1-»
		if (count_«getStateNameByFlag(this.targetState, 3)» < «this.delay») {
			GOTO(L_afterCount_«getStateNameByFlag(this.targetState, 3)»);
		}
	«ENDIF-»
«ENDDEFINE»

«DEFINE delayedTriggerLabel FOR Transition-»
	«IF this.delay > 1-»
		L_afterCount_«getStateNameByFlag(this.targetState, 3)»:
		count_«getStateNameByFlag(this.targetState, 3)»++;
	«ENDIF-»
«ENDDEFINE»