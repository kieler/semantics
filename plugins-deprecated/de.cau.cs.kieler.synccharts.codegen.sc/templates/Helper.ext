/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 *
 * Copyright 2009 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 *
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 *
 * @author tam
 *
 *****************************************************************************/
 
 /*
  * This Xtend file provides some additional extensions for the SyncCharts
  * metamodel.
  *
  */

import synccharts;
import expressions;

// Returns a sorted list of transition priorities.
List sortTransitionPrios(State state):
	state.outgoingTransitions.sortBy(e|e.priority)
;

// Returns a sorted list of states.
List sortStateControlFlow(State state):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.sortStateControlFlow(de.cau.cs.kieler.synccharts.State)
;

// Returns the URI of a state.
cached String getURI(State state):
	JAVA de.cau.cs.kieler.synccharts.codegen.sc.Activator.getUri(de.cau.cs.kieler.synccharts.State)
;

// Returns the URI of a transition.
cached String getFragmentURI(Transition transition):
	JAVA de.cau.cs.kieler.synccharts.codegen.sc.Activator.getUri(de.cau.cs.kieler.synccharts.Transition)
;
	
// Returns the root state of a SyncChart.
cached State getRootState(State s):
	s.parentRegion.parentState == null ? s :
	getRootState(s.parentRegion.parentState)
;

// Returns the initial state of a region.
State getInitialState(Region region):
	region.states.select(s|s.isInitial).first()
;

// Returns a list of thread priorities.
cached List computeThreadPriorities(State rootState):
	JAVA de.cau.cs.kieler.synccharts.codegen.sc.Helper.computeThreadPriorities(de.cau.cs.kieler.synccharts.State)
;

// Returns the thread priority of the main thread.
cached int getMainTreadPriority(State rootState):
	getRealThreadPriority(rootState)
;

// Returns the thread priority of a state. The state is not represented as weak
// or strong but by the real nature of the given state.
int getRealThreadPriority(State state):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.getRealThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the optimized thread priority of a state.
int getRealOptimizedThreadPriority(State state):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.getRealOptimizedThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the thread priority of a state represented as a weak state.
int getWeakThreadPriority(State rootState):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.getWeakThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the optimized thread priority of a state represented as a weak state.
int getOptimizedWeakThreadPriority(State rootState):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.getOptimizedWeakThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the smallest thread priority of a state.
int getSmallestThreadPriority(State state):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.getSmallestThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns a list with all signals in the SyncChart.
cached List allSignals(State state):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.allSignals(de.cau.cs.kieler.synccharts.State)
;


// Returns the first inital state.
State getInitialState(State state):
	state.regions.first().states.select(s|s.isInitial).first()
;

// Returns the signal list of a state.
cached List getStateSignals(State state):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.getStateSignals(de.cau.cs.kieler.synccharts.State)
;

// Returns the highest priority of the priority list.
cached int getHighestPriority(State state):
	// The size of the list is the highest thread priority.
	// We can not use the biggest element of the list because
	// after the optimization of the priority numbers the biggest
	// element is not the highest priority in the file.
	// Thus the priority optimizer has to work.
	computeThreadPriorities(state).size
;

// Tests if a transition has signals of which other signals are dependend.
boolean hasDependentState(Transition transition):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.hasDependentState(de.cau.cs.kieler.synccharts.Transition)
;

// Tests if a transition has signals that are dependend from other transitions.
boolean isSignalDependent(Transition transition):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.isSignalDependent(de.cau.cs.kieler.synccharts.Transition)
;

// Returns the statename for labels.
String getStateNameByFlag(State state, int flag):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.getStateNameByFlag(de.cau.cs.kieler.synccharts.State, java.lang.Integer)
;

Void debug(String s):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.debug(java.lang.String)
;

Void error(String s):
	JAVA  de.cau.cs.kieler.synccharts.codegen.sc.Helper.error(java.lang.String)
;

// Tests if a state is hierarchical root state without transitions and actions.
boolean isSimpleHierarchical(State state):
	state.parentRegion.parentState == null &&
	(state.regions.size == 1) &&
	state.outgoingTransitions.isEmpty &&
	state.innerActions.isEmpty &&
	state.entryActions.isEmpty &&
	!state.parentRegion.states.exists(s|s.outgoingTransitions.exists(t|t.targetState == state))
;

// Tests if a state has any outgoing immediate transitions or entry actions.
boolean hasImmediates(State state):
	state.outgoingTransitions.exists(t|t.isImmediate) ||
	(state.entryActions.size > 0)
;

// Tests if a state has a transition without any triggers.
boolean hasTransitionWithoutTrigger(State state):
	state.outgoingTransitions.exists(t|t. trigger == null) &&
	!state.outgoingTransitions.exists(t|t.type == TransitionType::NORMALTERMINATION)
;