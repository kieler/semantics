
/* ==========================================================================
   
    RailController.c

    This code is generated by oAw code generation from a SimpleRailCtrl
    EMF metamodel instance.

    Copyright 2008 Christian Motika, cmot@delphino.de

    This is free software, released under the terms of the GNU General
    Public License.

 ========================================================================== */

#include "railway.h"							  
#include "kicking.h"							  
#include <stdio.h>							  
#include <unistd.h>							  
#include <stdlib.h>		
#include <pthread.h>

#define DEBUGCONTROLLER 1

//define point constants
#define POINT_0 0   
#define POINT_1 1   
#define POINT_2 2   
#define POINT_3 3   
#define POINT_4 4   
#define POINT_5 5   
#define POINT_6 6   
#define POINT_7 7   
#define POINT_8 8   
#define POINT_9 9   
#define POINT_10 10   
#define POINT_11 11   
#define POINT_12 12   
#define POINT_13 13   
#define POINT_14 14   
#define POINT_15 15   
#define POINT_16 16   
#define POINT_17 17   
#define POINT_18 18   
#define POINT_19 19   
#define POINT_20 20  
#define POINT_21 21  
#define POINT_22 22  
#define POINT_23 23  
#define POINT_24 24  
#define POINT_25 25  
#define POINT_26 26  
#define POINT_27 27  
#define POINT_28 28  
#define POINT_29 29   

//define FIRST and SECOND
#define FIRST 0
#define SECOND 1

#define STOP 0
#define FWD 1
#define REV 2
#define BRAKE 3

int GLOBSEM = 0; 			// a global semaphore to rail API (released)

int MasterShutdown;			// master shutdown initialization
int TICK = 0; 				// globally increased (MACRO)TICK

int ContactMem[48][2];      // arrays for saving contact/occupied
int OccupiedMem[48];		// information during one macro tick


int localLOCK2 = 0;   

int localTERMINATED2 = 0;   


struct railway_system *railway;

//synchronous getcontact and trackused functions
//ContactMem array and OccupiedMem array are filled by master thread
//prior to each round and remain persistent for each thread during a macro tick
int getcontact_sync(struct railway_system *railway, int track, int position, int clear) {
	return ContactMem[track][position];
}
int trackused_sync(struct railway_system *railway, int track) {
	return OccupiedMem[track];
}


//hash function for state-ids
int HASH (const char *str_param) {
	unsigned long int hashvalue, test;
	const char *str = str_param;
	hashvalue = 0;
	while (*str != '\0') {
		hashvalue <<= 4;
		hashvalue += (unsigned char) *str++;
		test = hashvalue & ((unsigned long int) 0xf << (32 - 4));
		if (test) {
			hashvalue ^= test >> (32 - 8);
			hashvalue ^= test;
		}//end if
	}
	return (int)hashvalue;
}


int P(int ThreadId){
	while (1) {
      if (!railway_alive(railway)) {
	      if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
	      exit(EXIT_FAILURE);
      }//end if
	  usleep(1000); // sleep for 1ms
      //if (DEBUGCONTROLLER) printf("Thread %d waiting for global lock.\n",ThreadId);
	  //if global semaphore is free
	  if (GLOBSEM == 0) {
	  	//try to grabb it
	  	GLOBSEM = ThreadId;
	  	//if succeeded return!
		if (GLOBSEM == ThreadId) return 1;
	  }
	}
}
void V(int ThreadId){
   //if (DEBUGCONTROLLER) printf("Thread %d released global lock.\n",ThreadId);
   GLOBSEM = 0;
}


// The Master Thread implements an idea of synchrony. Its task
// is to use barrier synchronization and let every thread run its
// main loop OR event loop just once before not every other thread
// has also proceeded in doing so
// this ensures the "eventually entry" of any railway API code that is 
// sequentialized due to the use of simple binary semaphore mutex
// variables
// Every thread has its own localLOCK variable, that is increased in
// every loop step, the thread must wait 
// if its own localLOCK is > 0. It is reset to 0 if ALL threads have
// set their localLOCKs to > 0 and hence have done a step
void* ThreadFunctionMaster(void* port)
{
  int track;
  while (!MasterShutdown) {
   		//do not wait for terminated threads
   			if (localTERMINATED2) {
			   localLOCK2 = 1;   
			}
  
  		//wait for all localTicks to be increased
  		if ((localLOCK2 == 1)&&(1)) {
			//fill ContactMem and OccupiedMem array
			for (track = 0; track < 48; track++) {
 			  ContactMem[track][0] = getcontact(railway,track,FIRST,1);
 			  ContactMem[track][1] = getcontact(railway,track,SECOND,1);
 			  OccupiedMem[track] = trackused(railway,track);
			}

  			//increase a tick counter (useless)
  			TICK++;
			//if (DEBUGCONTROLLER) printf("TICK %d\n",TICK);
			localLOCK2 = 0;   
  		}//end if
		usleep(1000); // sleep for 1ms
  }
  return (void *)1;
}
 
 
void* ThreadFunction2(void* port)
{
  int secondcounter = 0;
  int outtransition = 0;
  int state = (int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetPointImpl@7c26a0ba (initial: true) (point: [POINT_19, POINT_20, POINT_23, POINT_24], direction: BRANCH)"));
  
  if (DEBUGCONTROLLER) printf("Thread 'org.eclipse.internal.xpand2.type.XpandIterator@432dbb4b' started.\n");
  
  while(1) {
      if (DEBUGCONTROLLER) printf("Entering state %d.\n",state);
      
      //escape if railway system is down
      if (!railway_alive(railway)) {
	  	  if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
     	  exit(EXIT_FAILURE);
	  }//end if
	  
      //all states
      if (state == -1) {}
	  else if (state == ((int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@73b61aea (initial: false) (track: [IC_JCT_0, IC_LN_0, IC_LN_1, IC_LN_2, IC_LN_3, IC_LN_4, IC_LN_5, IC_ST_0, IC_ST_2, IC_ST_4], speed: 100, direction: FWD)")))) {
	  		  P(2); // GET THE GLOBALLOCK
              if (DEBUGCONTROLLER) printf("State %d (de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@73b61aea (initial: false) (track: [IC_JCT_0, IC_LN_0, IC_LN_1, IC_LN_2, IC_LN_3, IC_LN_4, IC_LN_5, IC_ST_0, IC_ST_2, IC_ST_4], speed: 100, direction: FWD)) entered.\n",(int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@73b61aea (initial: false) (track: [IC_JCT_0, IC_LN_0, IC_LN_1, IC_LN_2, IC_LN_3, IC_LN_4, IC_LN_5, IC_ST_0, IC_ST_2, IC_ST_4], speed: 100, direction: FWD)")));
	          //state1 entry code (SET SPEED)
			  settrack(railway, IC_JCT_0, FWD, 100);
		      setsignal(railway, IC_JCT_0, FIRST, OFF);
		      setsignal(railway, IC_JCT_0, SECOND, GREEN);
			  settrack(railway, IC_LN_0, FWD, 100);
		      setsignal(railway, IC_LN_0, FIRST, OFF);
		      setsignal(railway, IC_LN_0, SECOND, GREEN);
			  settrack(railway, IC_LN_1, FWD, 100);
		      setsignal(railway, IC_LN_1, FIRST, OFF);
		      setsignal(railway, IC_LN_1, SECOND, GREEN);
			  settrack(railway, IC_LN_2, FWD, 100);
		      setsignal(railway, IC_LN_2, FIRST, OFF);
		      setsignal(railway, IC_LN_2, SECOND, GREEN);
			  settrack(railway, IC_LN_3, FWD, 100);
		      setsignal(railway, IC_LN_3, FIRST, OFF);
		      setsignal(railway, IC_LN_3, SECOND, GREEN);
			  settrack(railway, IC_LN_4, FWD, 100);
		      setsignal(railway, IC_LN_4, FIRST, OFF);
		      setsignal(railway, IC_LN_4, SECOND, GREEN);
			  settrack(railway, IC_LN_5, FWD, 100);
		      setsignal(railway, IC_LN_5, FIRST, OFF);
		      setsignal(railway, IC_LN_5, SECOND, GREEN);
			  settrack(railway, IC_ST_0, FWD, 100);
		      setsignal(railway, IC_ST_0, FIRST, OFF);
		      setsignal(railway, IC_ST_0, SECOND, GREEN);
			  settrack(railway, IC_ST_2, FWD, 100);
		      setsignal(railway, IC_ST_2, FIRST, OFF);
		      setsignal(railway, IC_ST_2, SECOND, GREEN);
			  settrack(railway, IC_ST_4, FWD, 100);
		      setsignal(railway, IC_ST_4, FIRST, OFF);
		      setsignal(railway, IC_ST_4, SECOND, GREEN);
	  		  V(2); // RELEASE THE GLOBALLOCK
	  		  
	          
	          //state1 transitions code
	          secondcounter = 0;
	          while(1) {
		   		    P(2); // GET THE GLOBALLOCK
	                outtransition = 0;
		            if ((DEBUGCONTROLLER)&&(!(secondcounter%10))) printf("Transition wait (%d seconds).\n",secondcounter/10);
			  		outtransition = 1;
	          		//test for contact-events
			  		if ((getcontact_sync(railway,IC_ST_2,FIRST,1) != 0)) {
			  		    V(2); // RELEASE THE GLOBALLOCK
	 	                if (DEBUGCONTROLLER) printf("Event-Transition taken.\n");
			  			state = HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@2af590c6 (initial: false) (track: [IC_ST_0, IC_ST_2], speed: 30, direction: FWD)");
			  			break;
			  		}
	  		  		V(2); // RELEASE THE GLOBALLOCK
			  			          		
	                //escape if railway system is down
                    if (!railway_alive(railway)) {
	 	                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
				    	exit(EXIT_FAILURE);
                    }//end if
                    	          
                    //escape if not outtransitions
                    if (!outtransition) {
	 	                if (DEBUGCONTROLLER) printf("Final state - terminating thread.\n");
						//set localTERMINATED := 1 (so that we not wait on this thread in any next macro-tick any more)
		          		localTERMINATED2 = 1;   
						return (void *)1;
                    }//end if
                    	          
	          		secondcounter++;
				usleep(100000); // sleep for 100ms
					
					//set localLOCK := 1 and wait for its reset
	          		localLOCK2 = 1;   
	          		while (localLOCK2 == 1){
		                    if (!railway_alive(railway)) {
	 			                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
						    	exit(EXIT_FAILURE);
                    		}//end if
							usleep(5000); // sleep for 5ms
							//if (DEBUGCONTROLLER) printf("Thread 2 waiting for next tick.\n");
	          		}//end while
	          		
	          }//end while
	      }//end if
	      
	  else if (state == ((int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetPointImpl@7c26a0ba (initial: true) (point: [POINT_19, POINT_20, POINT_23, POINT_24], direction: BRANCH)")))) {
	  		  P(2); // GET THE GLOBALLOCK
              if (DEBUGCONTROLLER) printf("State %d (de.cau.cs.kieler.simplerailctrl.impl.SetPointImpl@7c26a0ba (initial: true) (point: [POINT_19, POINT_20, POINT_23, POINT_24], direction: BRANCH)) entered.\n",(int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetPointImpl@7c26a0ba (initial: true) (point: [POINT_19, POINT_20, POINT_23, POINT_24], direction: BRANCH)")));
	          //state2 enty code (SET POINT)
			  setpoint(railway,  POINT_19, BRANCH);
			  setpoint(railway,  POINT_20, BRANCH);
			  setpoint(railway,  POINT_23, BRANCH);
			  setpoint(railway,  POINT_24, BRANCH);
	  		  V(2); // RELEASE THE GLOBALLOCK
	  		  
	          
	          //state2 transitions code
	          secondcounter = 0;
	          while(1) {
		   		    P(2); // GET THE GLOBALLOCK
	                outtransition = 0;
		            if ((DEBUGCONTROLLER)&&(!(secondcounter%10))) printf("Transition wait (%d seconds).\n",secondcounter/10);
			  		outtransition = 1;
	          		//test for wait-events
			  		if (secondcounter/10 >= 5) {
			  		    V(2); // RELEASE THE GLOBALLOCK
	 	                if (DEBUGCONTROLLER) printf("Wait-Transition taken.\n");
			  			state = HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@73b61aea (initial: false) (track: [IC_JCT_0, IC_LN_0, IC_LN_1, IC_LN_2, IC_LN_3, IC_LN_4, IC_LN_5, IC_ST_0, IC_ST_2, IC_ST_4], speed: 100, direction: FWD)");
			  			break;
			  		}
			  		
	  		  		V(2); // RELEASE THE GLOBALLOCK
			  			          		
	                //escape if railway system is down
                    if (!railway_alive(railway)) {
	 	                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
				    	exit(EXIT_FAILURE);
                    }//end if
                    	          
                    //escape if not outtransitions
                    if (!outtransition) {
	 	                if (DEBUGCONTROLLER) printf("Final state - terminating thread.\n");
						//set localTERMINATED := 1 (so that we not wait on this thread in any next macro-tick any more)
		          		localTERMINATED2 = 1;   
						return (void *)1;
                    }//end if
                    	          
	          		secondcounter++;
				usleep(100000); // sleep for 100ms
					
					//set localLOCK := 1 and wait for its reset
	          		localLOCK2 = 1;   
	          		while (localLOCK2 == 1){
		                    if (!railway_alive(railway)) {
	 			                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
						    	exit(EXIT_FAILURE);
                    		}//end if
							usleep(5000); // sleep for 5ms
							//if (DEBUGCONTROLLER) printf("Thread 2 waiting for next tick.\n");
	          		}//end while
	          		
	          }//end while
	      }//end if
	      
	  else if (state == ((int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@2af590c6 (initial: false) (track: [IC_ST_0, IC_ST_2], speed: 30, direction: FWD)")))) {
	  		  P(2); // GET THE GLOBALLOCK
              if (DEBUGCONTROLLER) printf("State %d (de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@2af590c6 (initial: false) (track: [IC_ST_0, IC_ST_2], speed: 30, direction: FWD)) entered.\n",(int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@2af590c6 (initial: false) (track: [IC_ST_0, IC_ST_2], speed: 30, direction: FWD)")));
	          //state3 entry code (SET SPEED)
			  settrack(railway, IC_ST_0, FWD, 30);
		      setsignal(railway, IC_ST_0, FIRST, OFF);
		      setsignal(railway, IC_ST_0, SECOND, YELLOW);
			  settrack(railway, IC_ST_2, FWD, 30);
		      setsignal(railway, IC_ST_2, FIRST, OFF);
		      setsignal(railway, IC_ST_2, SECOND, YELLOW);
	  		  V(2); // RELEASE THE GLOBALLOCK
	  		  
	          
	          //state3 transitions code
	          secondcounter = 0;
	          while(1) {
		   		    P(2); // GET THE GLOBALLOCK
	                outtransition = 0;
		            if ((DEBUGCONTROLLER)&&(!(secondcounter%10))) printf("Transition wait (%d seconds).\n",secondcounter/10);
			  		outtransition = 1;
	          		//test for contact-events
			  		if ((getcontact_sync(railway,IC_ST_2,SECOND,1) != 0)) {
			  		    V(2); // RELEASE THE GLOBALLOCK
	 	                if (DEBUGCONTROLLER) printf("Event-Transition taken.\n");
			  			state = HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@5ff3cd32 (initial: false) (track: [IC_ST_2], speed: 0, direction: FWD)");
			  			break;
			  		}
	  		  		V(2); // RELEASE THE GLOBALLOCK
			  			          		
	                //escape if railway system is down
                    if (!railway_alive(railway)) {
	 	                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
				    	exit(EXIT_FAILURE);
                    }//end if
                    	          
                    //escape if not outtransitions
                    if (!outtransition) {
	 	                if (DEBUGCONTROLLER) printf("Final state - terminating thread.\n");
						//set localTERMINATED := 1 (so that we not wait on this thread in any next macro-tick any more)
		          		localTERMINATED2 = 1;   
						return (void *)1;
                    }//end if
                    	          
	          		secondcounter++;
				usleep(100000); // sleep for 100ms
					
					//set localLOCK := 1 and wait for its reset
	          		localLOCK2 = 1;   
	          		while (localLOCK2 == 1){
		                    if (!railway_alive(railway)) {
	 			                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
						    	exit(EXIT_FAILURE);
                    		}//end if
							usleep(5000); // sleep for 5ms
							//if (DEBUGCONTROLLER) printf("Thread 2 waiting for next tick.\n");
	          		}//end while
	          		
	          }//end while
	      }//end if
	      
	  else if (state == ((int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@5ff3cd32 (initial: false) (track: [IC_ST_2], speed: 0, direction: FWD)")))) {
	  		  P(2); // GET THE GLOBALLOCK
              if (DEBUGCONTROLLER) printf("State %d (de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@5ff3cd32 (initial: false) (track: [IC_ST_2], speed: 0, direction: FWD)) entered.\n",(int)(HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@5ff3cd32 (initial: false) (track: [IC_ST_2], speed: 0, direction: FWD)")));
	          //state4 entry code (SET SPEED)
			  settrack(railway, IC_ST_2, FWD, 0);
		      setsignal(railway, IC_ST_2, FIRST, OFF);
		      setsignal(railway, IC_ST_2, SECOND, RED);
	  		  V(2); // RELEASE THE GLOBALLOCK
	  		  
	          
	          //state4 transitions code
	          secondcounter = 0;
	          while(1) {
		   		    P(2); // GET THE GLOBALLOCK
	                outtransition = 0;
		            if ((DEBUGCONTROLLER)&&(!(secondcounter%10))) printf("Transition wait (%d seconds).\n",secondcounter/10);
			  		outtransition = 1;
	          		//test for wait-events
			  		if (secondcounter/10 >= 10) {
			  		    V(2); // RELEASE THE GLOBALLOCK
	 	                if (DEBUGCONTROLLER) printf("Wait-Transition taken.\n");
			  			state = HASH("de.cau.cs.kieler.simplerailctrl.impl.SetSpeedImpl@73b61aea (initial: false) (track: [IC_JCT_0, IC_LN_0, IC_LN_1, IC_LN_2, IC_LN_3, IC_LN_4, IC_LN_5, IC_ST_0, IC_ST_2, IC_ST_4], speed: 100, direction: FWD)");
			  			break;
			  		}
			  		
	  		  		V(2); // RELEASE THE GLOBALLOCK
			  			          		
	                //escape if railway system is down
                    if (!railway_alive(railway)) {
	 	                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
				    	exit(EXIT_FAILURE);
                    }//end if
                    	          
                    //escape if not outtransitions
                    if (!outtransition) {
	 	                if (DEBUGCONTROLLER) printf("Final state - terminating thread.\n");
						//set localTERMINATED := 1 (so that we not wait on this thread in any next macro-tick any more)
		          		localTERMINATED2 = 1;   
						return (void *)1;
                    }//end if
                    	          
	          		secondcounter++;
				usleep(100000); // sleep for 100ms
					
					//set localLOCK := 1 and wait for its reset
	          		localLOCK2 = 1;   
	          		while (localLOCK2 == 1){
		                    if (!railway_alive(railway)) {
	 			                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
						    	exit(EXIT_FAILURE);
                    		}//end if
							usleep(5000); // sleep for 5ms
							//if (DEBUGCONTROLLER) printf("Thread 2 waiting for next tick.\n");
	          		}//end while
	          		
	          }//end while
	      }//end if
	      
  }//end while
}	


int main() {
	//initialize railway system 
  	if ((railway=railway_initsystem(&kicking))==NULL) {
    	perror("railway_initsystem");
    	exit(EXIT_FAILURE);
  	}
  	if (railway_openlinks_udp(railway,"node%02i","/dev/ttyS0")<0) {
    	railway_donesystem(railway);
    	exit(EXIT_FAILURE);
  	}
  	if (railway_startcontrol(railway,0,0)<0) {
	    perror("railway_startcontrol");
	    railway_closelinks(railway);
    	railway_donesystem(railway);
	    exit(EXIT_FAILURE);
  	}
  	
  	//start the master thread
  	MasterShutdown = 0;
    pthread_t ThreadMaster;
    pthread_create (&ThreadMaster, NULL, &ThreadFunctionMaster, NULL);
    
    //start concurrent threads of controllers
    pthread_t Thread2;
    pthread_create (&Thread2, NULL, &ThreadFunction2, NULL);
 
    //wait for concurrent controller threads
    pthread_join( Thread2, NULL ); 
	
	//shutdown master thread
	MasterShutdown = 1;
	
    if (DEBUGCONTROLLER) printf("Waiting for GUI thread or railway system shutdown.\n");
    
    //shutdown the railway
    if (railway_stopcontrol(railway,1)<0) {
      perror("railway_stopcontrol");
      exit(EXIT_FAILURE);
    }
    if (railway_closelinks(railway)<0) {
      perror("railway_closelinks");
      exit(EXIT_FAILURE);
    }
    if (railway_donesystem(railway)<0) {
      perror("railway_donesystem");
      exit(EXIT_FAILURE);
    }
    
    if (DEBUGCONTROLLER) printf("All threads joined - terminating program.\n");
    return 1;
}

