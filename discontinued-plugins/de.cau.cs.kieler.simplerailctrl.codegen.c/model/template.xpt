/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2009 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
*/

«IMPORT simplerailctrl»

«DEFINE main FOR RailController-»
	«FILE "RailController.c"-»

/* ==========================================================================
   
    RailController.c

    This code is generated by oAw code generation from a SimpleRailCtrl
    EMF metamodel instance.

    Copyright 2008 Christian Motika, cmot@delphino.de

    This is free software, released under the terms of the GNU General
    Public License.

 ========================================================================== */

#include "railway.h"							  
#include "kicking.h"							  
#include <stdio.h>							  
#include <unistd.h>							  
#include <stdlib.h>		
#include <pthread.h>

#define DEBUGCONTROLLER 1

//define point constants
#define POINT_0 0   
#define POINT_1 1   
#define POINT_2 2   
#define POINT_3 3   
#define POINT_4 4   
#define POINT_5 5   
#define POINT_6 6   
#define POINT_7 7   
#define POINT_8 8   
#define POINT_9 9   
#define POINT_10 10   
#define POINT_11 11   
#define POINT_12 12   
#define POINT_13 13   
#define POINT_14 14   
#define POINT_15 15   
#define POINT_16 16   
#define POINT_17 17   
#define POINT_18 18   
#define POINT_19 19   
#define POINT_20 20  
#define POINT_21 21  
#define POINT_22 22  
#define POINT_23 23  
#define POINT_24 24  
#define POINT_25 25  
#define POINT_26 26  
#define POINT_27 27  
#define POINT_28 28  
#define POINT_29 29   

//define FIRST and SECOND
#define FIRST 0
#define SECOND 1

#define STOP 0
#define FWD 1
#define REV 2
#define BRAKE 3

int GLOBSEM = 0; 			// a global semaphore to rail API (released)

int MasterShutdown;			// master shutdown initialization
int TICK = 0; 				// globally increased (MACRO)TICK

int ContactMem[48][2];      // arrays for saving contact/occupied
int OccupiedMem[48];		// information during one macro tick


«FOREACH nodes AS n ITERATOR i-»
   «IF n.initial-»
int localLOCK«i.counter1-» = 0;   
   «ENDIF-»
«ENDFOREACH-»

«FOREACH nodes AS n ITERATOR i-»
   «IF n.initial-»
int localTERMINATED«i.counter1-» = 0;   
   «ENDIF-»
«ENDFOREACH-»


struct railway_system *railway;

//synchronous getcontact and trackused functions
//ContactMem array and OccupiedMem array are filled by master thread
//prior to each round and remain persistent for each thread during a macro tick
int getcontact_sync(struct railway_system *railway, int track, int position, int clear) {
	return ContactMem[track][position];
}
int trackused_sync(struct railway_system *railway, int track) {
	return OccupiedMem[track];
}


//hash function for state-ids
int HASH (const char *str_param) {
	unsigned long int hashvalue, test;
	const char *str = str_param;
	hashvalue = 0;
	while (*str != '\0') {
		hashvalue <<= 4;
		hashvalue += (unsigned char) *str++;
		test = hashvalue & ((unsigned long int) 0xf << (32 - 4));
		if (test) {
			hashvalue ^= test >> (32 - 8);
			hashvalue ^= test;
		}//end if
	}
	return (int)hashvalue;
}


int P(int ThreadId){
	while (1) {
      if (!railway_alive(railway)) {
	      if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
	      exit(EXIT_FAILURE);
      }//end if
	  usleep(1000); // sleep for 1ms
      //if (DEBUGCONTROLLER) printf("Thread %d waiting for global lock.\n",ThreadId);
	  //if global semaphore is free
	  if (GLOBSEM == 0) {
	  	//try to grabb it
	  	GLOBSEM = ThreadId;
	  	//if succeeded return!
		if (GLOBSEM == ThreadId) return 1;
	  }
	}
}
void V(int ThreadId){
   //if (DEBUGCONTROLLER) printf("Thread %d released global lock.\n",ThreadId);
   GLOBSEM = 0;
}


// The Master Thread implements an idea of synchrony. Its task
// is to use barrier synchronization and let every thread run its
// main loop OR event loop just once before not every other thread
// has also proceeded in doing so
// this ensures the "eventually entry" of any railway API code that is 
// sequentialized due to the use of simple binary semaphore mutex
// variables
// Every thread has its own localLOCK variable, that is increased in
// every loop step, the thread must wait 
// if its own localLOCK is > 0. It is reset to 0 if ALL threads have
// set their localLOCKs to > 0 and hence have done a step
void* ThreadFunctionMaster(void* port)
{
  int track;
  while (!MasterShutdown) {
   		//do not wait for terminated threads
«FOREACH nodes AS n ITERATOR i-»
   «IF n.initial-»
   			if (localTERMINATED«i.counter1-») {
			   localLOCK«i.counter1-» = 1;   
			}
   «ENDIF-»
«ENDFOREACH-»
  
  		//wait for all localTicks to be increased
  		if («FOREACH nodes AS n ITERATOR i-»«IF n.initial-»(localLOCK«i.counter1-» == 1)&&«ENDIF-»«ENDFOREACH-»(1)) {
			//fill ContactMem and OccupiedMem array
			for (track = 0; track < 48; track++) {
 			  ContactMem[track][0] = getcontact(railway,track,FIRST,1);
 			  ContactMem[track][1] = getcontact(railway,track,SECOND,1);
 			  OccupiedMem[track] = trackused(railway,track);
			}

  			//increase a tick counter (useless)
  			TICK++;
			//if (DEBUGCONTROLLER) printf("TICK %d\n",TICK);
«FOREACH nodes AS n ITERATOR i-»
   «IF n.initial-»
			localLOCK«i.counter1-» = 0;   
   «ENDIF-»
«ENDFOREACH-»
  		}//end if
		usleep(1000); // sleep for 1ms
  }
  return (void *)1;
}
 
 
	«FOREACH nodes AS n ITERATOR i-»
	   «IF n.initial-»
void* ThreadFunction«i.counter1-»(void* port)
{
  int secondcounter = 0;
  int outtransition = 0;
  int state = (int)(HASH("«n-»"));
  
  if (DEBUGCONTROLLER) printf("Thread '«i.toString()-»' started.\n");
  
  while(1) {
      if (DEBUGCONTROLLER) printf("Entering state %d.\n",state);
      
      //escape if railway system is down
      if (!railway_alive(railway)) {
	  	  if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
     	  exit(EXIT_FAILURE);
	  }//end if
	  
      //all states
      if (state == -1) {}
	  «FOREACH nodes AS nn ITERATOR ii-»
	  else if (state == ((int)(HASH("«nn»")))) {
	  		  P(«i.counter1-»); // GET THE GLOBALLOCK
              if (DEBUGCONTROLLER) printf("State %d («nn.toString()») entered.\n",(int)(HASH("«nn-»")));
	          «IF (nn.metaType.name.matches("simplerailctrl::SetSpeed"))-»
	          //state«ii.counter1-» entry code (SET SPEED)
			  «FOREACH ((simplerailctrl::SetSpeed)nn).track AS t-»
			  settrack(railway, «t-», «((simplerailctrl::SetSpeed)nn).direction-», «((simplerailctrl::SetSpeed)nn).speed-»);
			  «IF((simplerailctrl::SetSpeed)nn).speed == 0-»
			  	«IF((simplerailctrl::SetSpeed)nn).direction.toString() == 'FWD'-»
		      setsignal(railway, «t-», FIRST, OFF);
		      setsignal(railway, «t-», SECOND, RED);
		      	«ELSEIF((simplerailctrl::SetSpeed)nn).direction.toString() == 'REV'-»
		      setsignal(railway, «t-», FIRST, RED);
		      setsignal(railway, «t-», SECOND, OFF);
			    «ELSE-»
		      setsignal(railway, «t-», FIRST, OFF);
		      setsignal(railway, «t-», SECOND, OFF);
		      	«ENDIF-»
			  «ELSEIF((simplerailctrl::SetSpeed)nn).speed < 50-»
			  	«IF((simplerailctrl::SetSpeed)nn).direction.toString() == 'FWD'-»
		      setsignal(railway, «t-», FIRST, OFF);
		      setsignal(railway, «t-», SECOND, YELLOW);
		      	«ELSEIF((simplerailctrl::SetSpeed)nn).direction.toString() == 'REV'-»
		      setsignal(railway, «t-», FIRST, YELLOW);
		      setsignal(railway, «t-», SECOND, OFF);
			    «ELSE-»
		      setsignal(railway, «t-», FIRST, OFF);
		      setsignal(railway, «t-», SECOND, OFF);
		      	«ENDIF-»
		      «ELSE-»
			  	«IF((simplerailctrl::SetSpeed)nn).direction.toString() == 'FWD'-»
		      setsignal(railway, «t-», FIRST, OFF);
		      setsignal(railway, «t-», SECOND, GREEN);
		      	«ELSEIF((simplerailctrl::SetSpeed)nn).direction.toString() == 'REV'-»
		      setsignal(railway, «t-», FIRST, GREEN);
		      setsignal(railway, «t-», SECOND, OFF);
			    «ELSE-»
		      setsignal(railway, «t-», FIRST, OFF);
		      setsignal(railway, «t-», SECOND, OFF);
		      	«ENDIF-»
		      «ENDIF-»
			  «ENDFOREACH-»	          		
	          «ENDIF-»
	          «IF (nn.metaType.name.matches("simplerailctrl::SetSignal"))-»
	          //state«ii.counter1-» enty code (SET SIGNAL)
			  «FOREACH ((simplerailctrl::SetSignal)nn).track AS t-»
			  «FOREACH ((simplerailctrl::SetSignal)nn).position AS p-»
		      setsignal(railway, «t-», «p-», «((simplerailctrl::SetSignal)nn).color-»);
			  «ENDFOREACH-»	          		
			  «ENDFOREACH-»	          		
	          «ENDIF-»
	          «IF (nn.metaType.name.matches("simplerailctrl::SetPoint"))-»
	          //state«ii.counter1-» enty code (SET POINT)
			  «FOREACH ((simplerailctrl::SetPoint)nn).point AS p-»
			  setpoint(railway,  «p-», «((simplerailctrl::SetPoint)nn).direction-»);
			  «ENDFOREACH-»	          		
	          «ENDIF-»
	  		  V(«i.counter1-»); // RELEASE THE GLOBALLOCK
	  		  
	          
	          //state«ii.counter1-» transitions code
	          secondcounter = 0;
	          while(1) {
		   		    P(«i.counter1-»); // GET THE GLOBALLOCK
	                outtransition = 0;
		            if ((DEBUGCONTROLLER)&&(!(secondcounter%10))) printf("Transition wait (%d seconds).\n",secondcounter/10);
			  		«FOREACH (nn).outTransitions AS ot-»
			  		outtransition = 1;
	          		«IF (ot.metaType.name.matches("simplerailctrl::EventWait"))-»
	          		//test for wait-events
			  		if (secondcounter/10 >= «((simplerailctrl::EventWait)ot).seconds») {
			  		    V(«i.counter1-»); // RELEASE THE GLOBALLOCK
	 	                if (DEBUGCONTROLLER) printf("Wait-Transition taken.\n");
			  			state = HASH("«((simplerailctrl::EventWait)ot).destination-»");
			  			break;
			  		}
			  		
	          		«ENDIF-»
	          		«IF (ot.metaType.name.matches("simplerailctrl::EventContact"))-»
	          		//test for contact-events
			  		if ((getcontact_sync(railway,«((simplerailctrl::EventContact)ot).track»,«((simplerailctrl::EventContact)ot).position»,1) != 0)) {
			  		    V(«i.counter1-»); // RELEASE THE GLOBALLOCK
	 	                if (DEBUGCONTROLLER) printf("Event-Transition taken.\n");
			  			state = HASH("«((simplerailctrl::EventWait)ot).destination-»");
			  			break;
			  		}
	          		«ENDIF-»
	          		«IF (ot.metaType.name.matches("simplerailctrl::EventOccupied"))-»
	          			//test for occupied-events
			       		«IF (((simplerailctrl::EventOccupied)ot).condition.toString() == 'IF') -»
				       		«IF (((simplerailctrl::EventOccupied)ot).conjunction.toString() == 'AND') -»
						if ((«FOREACH ((simplerailctrl::EventOccupied)ot).track AS t SEPARATOR '&&'-»(trackused(railway,«t-») != 0)«ENDFOREACH-»
					        «ELSE-»
						if (!(«FOREACH ((simplerailctrl::EventOccupied)ot).track AS t SEPARATOR '||'-»(trackused(railway,«t-») != 0)«ENDFOREACH-»
					        «ENDIF-»
			          	«ELSE-»
				       		«IF (((simplerailctrl::EventOccupied)ot).conjunction.toString() == 'AND') -»
						if (!(«FOREACH ((simplerailctrl::EventOccupied)ot).track AS t SEPARATOR '&&'-»(trackused(railway,«t-») != 0)«ENDFOREACH-»
					        «ELSE-»
						if (!(«FOREACH ((simplerailctrl::EventOccupied)ot).track AS t SEPARATOR '||'-»(trackused(railway,«t-») != 0)«ENDFOREACH-»
					        «ENDIF-»
			          	«ENDIF-»)) {
				  		    V(«i.counter1-»); // RELEASE THE GLOBALLOCK
	 	                	if (DEBUGCONTROLLER) printf("Occupied-Transition taken.\n");
			  				state = HASH("«((simplerailctrl::EventOccupied)ot).destination-»");
			  				break;
			  		}
			  		
	          		«ENDIF-»
			  		«ENDFOREACH-»
	  		  		V(«i.counter1-»); // RELEASE THE GLOBALLOCK
			  			          		
	                //escape if railway system is down
                    if (!railway_alive(railway)) {
	 	                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
				    	exit(EXIT_FAILURE);
                    }//end if
                    	          
                    //escape if not outtransitions
                    if (!outtransition) {
	 	                if (DEBUGCONTROLLER) printf("Final state - terminating thread.\n");
						//set localTERMINATED := 1 (so that we not wait on this thread in any next macro-tick any more)
		          		localTERMINATED«i.counter1-» = 1;   
						return (void *)1;
                    }//end if
                    	          
	          		secondcounter++;
				usleep(100000); // sleep for 100ms
					
					//set localLOCK := 1 and wait for its reset
	          		localLOCK«i.counter1-» = 1;   
	          		while (localLOCK«i.counter1-» == 1){
		                    if (!railway_alive(railway)) {
	 			                if (DEBUGCONTROLLER) printf("Railway system down - terminating thread.\n");
						    	exit(EXIT_FAILURE);
                    		}//end if
							usleep(5000); // sleep for 5ms
							//if (DEBUGCONTROLLER) printf("Thread «i.counter1-» waiting for next tick.\n");
	          		}//end while
	          		
	          }//end while
	      }//end if
	      
	  «ENDFOREACH-»
  }//end while
}	
	   «ENDIF-»
	«ENDFOREACH-»


int main() {
	//initialize railway system 
  	if ((railway=railway_initsystem(&kicking))==NULL) {
    	perror("railway_initsystem");
    	exit(EXIT_FAILURE);
  	}
  	if (railway_openlinks_udp(railway,"node%02i","/dev/ttyS0")<0) {
    	railway_donesystem(railway);
    	exit(EXIT_FAILURE);
  	}
  	if (railway_startcontrol(railway,0,0)<0) {
	    perror("railway_startcontrol");
	    railway_closelinks(railway);
    	railway_donesystem(railway);
	    exit(EXIT_FAILURE);
  	}
  	
  	//start the master thread
  	MasterShutdown = 0;
    pthread_t ThreadMaster;
    pthread_create (&ThreadMaster, NULL, &ThreadFunctionMaster, NULL);
    
    //start concurrent threads of controllers
	«FOREACH nodes AS n ITERATOR i-»
	   «IF n.initial-»
    pthread_t Thread«i.counter1-»;
    pthread_create (&Thread«i.counter1-», NULL, &ThreadFunction«i.counter1-», NULL);
	   «ENDIF-»
	«ENDFOREACH-»
 
    //wait for concurrent controller threads
	«FOREACH nodes AS n ITERATOR i-»
	   «IF n.initial-»
    pthread_join( Thread«i.counter1-», NULL ); 
	   «ENDIF-»
	«ENDFOREACH-»
	
	//shutdown master thread
	MasterShutdown = 1;
	
    if (DEBUGCONTROLLER) printf("Waiting for GUI thread or railway system shutdown.\n");
    
    //shutdown the railway
    if (railway_stopcontrol(railway,1)<0) {
      perror("railway_stopcontrol");
      exit(EXIT_FAILURE);
    }
    if (railway_closelinks(railway)<0) {
      perror("railway_closelinks");
      exit(EXIT_FAILURE);
    }
    if (railway_donesystem(railway)<0) {
      perror("railway_donesystem");
      exit(EXIT_FAILURE);
    }
    
    if (DEBUGCONTROLLER) printf("All threads joined - terminating program.\n");
    return 1;
}

«ENDFILE-»
«ENDDEFINE»
