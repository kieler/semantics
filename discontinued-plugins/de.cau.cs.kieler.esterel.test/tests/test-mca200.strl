%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Arbiter:
%
% If one of three error signals is active then send a global error
% signal.
%
module ARB_3:
input
  ERR1,
  ERR2,
  ERR3;
output
  ERR;
% Infinite loop
loop
  % Wait for local error signals
  await
    case ERR1
    case ERR2
    case ERR3
  end;
  % Emit global error signal
  emit ERR;
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Arbiter:
%
% It decides the value of output (SOFT, MED, HARD) according to a
%
% priority order (HARD is the highest). If one of input is HARD then
%
% output becomes HARD.
%
module ARBITER:
input
  RESET,
  CTRL_1(integer),
  CTRL_2(integer),
  CTRL_3(integer),
  CTRL_4(integer),
  CTRL_5(integer),
  CTRL_6(integer),
  CTRL_7(integer),
  CTRL_8(integer);
output
  CTRL(integer);
constant
  HARD, MED, SOFT : integer;
var
  CTRL_1_VAL : integer,
  CTRL_2_VAL : integer,
  CTRL_3_VAL : integer,
  CTRL_4_VAL : integer,
  CTRL_5_VAL : integer,
  CTRL_6_VAL : integer,
  CTRL_7_VAL : integer,
  CTRL_8_VAL : integer,
  CTRL_VAL : integer
in
  % Infinite loop
  loop
    % Reset sequence
    CTRL_1_VAL := SOFT;
    CTRL_2_VAL := SOFT;
    CTRL_3_VAL := SOFT;
    CTRL_4_VAL := SOFT;
    CTRL_5_VAL := SOFT;
    CTRL_6_VAL := SOFT;
    CTRL_7_VAL := SOFT;
    CTRL_8_VAL := SOFT;
    CTRL_VAL := SOFT;
    % When a RESET happens quit loop
    do
      loop
        % Emit output
        emit CTRL(CTRL_VAL);
        % Wait for input signals
        await
          case CTRL_1 do
            % Get its value
            CTRL_1_VAL := ?CTRL_1;
          case CTRL_2 do
            % Get its value
            CTRL_2_VAL := ?CTRL_2;
          case CTRL_3 do
            % Get its value
            CTRL_3_VAL := ?CTRL_3;
          case CTRL_4 do
            % Get its value
            CTRL_4_VAL := ?CTRL_4;
          case CTRL_5 do
            % Get its value
            CTRL_5_VAL := ?CTRL_5;
          case CTRL_6 do
            % Get its value
            CTRL_6_VAL := ?CTRL_6;
          case CTRL_7 do
            % Get its value
            CTRL_7_VAL := ?CTRL_7;
          case CTRL_8 do
            % Get its value
            CTRL_8_VAL := ?CTRL_8;
        end;
        % Test their value for sewtting output
        if ((CTRL_1_VAL = HARD) or (CTRL_2_VAL = HARD) or (CTRL_3_VAL = HARD) or (CTRL_4_VAL = HARD) or 
            (CTRL_5_VAL = HARD) or (CTRL_6_VAL = HARD) or (CTRL_7_VAL = HARD) or (CTRL_8_VAL = HARD)) then
          CTRL_VAL := HARD;
        else
          if ((CTRL_1_VAL = MED) or (CTRL_2_VAL = MED) or (CTRL_3_VAL = MED) or (CTRL_4_VAL = MED) or 
              (CTRL_5_VAL = MED) or (CTRL_6_VAL = MED) or (CTRL_7_VAL = MED) or (CTRL_8_VAL = MED)) then
            CTRL_VAL := MED;
          else
            CTRL_VAL := SOFT;
          end;   
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Battery calculation:
%
% It verifies the voltage level of battery according to the following
% conditions:
%
% 1. If (VBAT < LLVBAT, HLVBAT) or (VBAT > LHVBAT, HHVBAT) for more
%    than BAT_TIME_OUT time then it goes into phase n.1.
% 2. If VBAT returns to the normal range ahead of TIME_RECOVERY then
%    it goes into phase n.0. generating a RES_MOT signal for motors
%    else it goes to phase n.2.
%
% Phases:
% number 0: normal state; 
% number 1: motors' condition is HARD;
% number 2: motors' condition is HARD and it sends an error signal,
% only the RESET signal can take it out from this state.
%
% CONSTANTS:
%
% Name		HHVBAT
% Data size	Unsigned 8 bit
% Range		0 - 25.5 V
% Resolution	0.1 V/bit
% Function	Upper threshold of the maximum value of battery voltage
% Threshold	18 V
% Value		180
%
% Name		LHVBAT
% Data size	Unsigned 8 bit
% Range		0 - 25.5 V
% Resolution	0.1 V/bit
% Function	Lower threshold of the maximum value of battery voltage
% Threshold	17 V
% Value		170
%
% Name		HLVBAT
% Data size	Unsigned 8 bit
% Range		0 - 25.5 V
% Resolution	0.1 V/bit
% Function	Upper threshold of the minimum value of battery voltage
% Threshold	11 V
% Value		110
%
% Name		LLVBAT
% Data size	Unsigned 8 bit
% Range		0 - 25.5 V
% Resolution	0.1 V/bit
% Function	Lower threshold of the minimum value of battery voltage
% Threshold	10 V
% Value		100
%
% Name		BAT_TIME_OUT
% Data size	Unsigned 8 bit
% Range		0 - 6.12 sec
% Resolution	24 msec/bit
% Function	Time out of being outside thresholds
% Threshold	240 msec
% Value		10
%
% Name		TIME_RECOVERY
% Data size	Unsigned 16 bit
% Range		0 - 1572.864 sec
% Resolution	24 msec/bit
% Function	Time out of phase number 1
% Threshold	30 sec
% Value		1250
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_24
% Period		24 msec
% Function		Sampling frequency of battery voltage
%
% Name			VBAT
% Data size		Unsigned 8 bit
% Range		Direction	Voltage level	Value		Function
%		Increase	0 - 10.5 V  	0 - 105		Low battery voltage
%		Increase	10.5 - 18 V   	105 - 180	Normal value
%		Increase	18 - 25.5 V	180 - 255	High battery voltage
%		Decrease	0 - 10.5 V  	0 - 105		Low battery voltage
%		Decrease	10.5 - 18 V   	105 - 180	Normal value
%		Decrease	18 - 25.5 V	180 - 255	High battery voltage
% Resolution		0.1 V/bit
% Rate of sampling	24 msec
% Function		Voltage level of battery
%
% OUTPUTS
%
% Name			BAT_MOT_RES
% Data size		1 bit
% Range			ON - OFF
% Function		Acts a reset sequence on motors
%
% Name			BAT_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
% Name			BAT_MOT_HARD
% Data size		1 bit
% Range			ON - OFF
% Function		Signal for set motors into HARD condition
%
module BAT_DIAG:
input
  RESET,
  CLOCK_24,
  VBAT(integer);
output
  BAT_MOT_RES,
  BAT_ERR,
  BAT_MOT_HARD;
constant
  UP, DOWN : integer,
  HHVBAT : integer,
  LHVBAT : integer,
  HLVBAT : integer,
  LLVBAT : integer,
  BAT_TIME_OUT : integer,
  TIME_RECOVERY : integer;
var
  VBAT_VALUE : integer,		% battery voltage value
  OLD_VALUE : integer,		% previous battery voltage value
  VBAT_OUT_TIME : integer,	% occurences of out of functional range
  DIRECTION : integer,		% Direction of changes: true - increase, false - decrease
  RECOVERY_STATE : boolean	% internal state variable: true - phase n.1., false - normal
in
  % Infinite loop
  loop
    % Reset sequence
    VBAT_VALUE := 0;
    OLD_VALUE := 0;
    VBAT_OUT_TIME := 0;
    DIRECTION := UP;
    RECOVERY_STATE := false;
    % When a RESET happens quit loop
    do
      loop
        await
          case VBAT do
            % Get battery voltage value
            VBAT_VALUE := ?VBAT;
            % Test the direction of changes
            if (VBAT_VALUE > OLD_VALUE) then
              % If it increases then set increase
              DIRECTION := UP;
            else
              if (VBAT_VALUE < OLD_VALUE) then
                % Otherwise set decrease
                DIRECTION := DOWN;
              end;
            end;
            % Keep the read value
            OLD_VALUE := VBAT_VALUE;
          case CLOCK_24 do
            % Test the value of battery voltage for functional range
            if (((DIRECTION = UP) and ((VBAT_VALUE > HHVBAT) or (VBAT_VALUE < HLVBAT))) or ((DIRECTION = DOWN) and ((VBAT_VALUE > LHVBAT) or (VBAT_VALUE < LLVBAT)))) then
              % Increase the timer
              VBAT_OUT_TIME := VBAT_OUT_TIME + 1;
              % Test the value of timer
              if ((not RECOVERY_STATE) and (VBAT_OUT_TIME >= BAT_TIME_OUT)) then
                % If it is in phase number 0 then go into the phase number 1
                RECOVERY_STATE := true;
	        % Set motors in condition HARD
                emit BAT_MOT_HARD;
                % Reset timer
                VBAT_OUT_TIME := 0;
              else
                if (RECOVERY_STATE and (VBAT_OUT_TIME >= TIME_RECOVERY)) then
                  % If it is in phase number 1 then go into the phase number 2
                  emit BAT_ERR;
                  % Wait an infinite amount of time, it quits when RESET takes place
                  halt;
                end;
              end;
            else
              % If the value returned within the normal range then delete the counter
              VBAT_OUT_TIME := 0;
              % Test the phase
              if (RECOVERY_STATE) then
                % If it returns from the 1st phase then send a reset signal to the mmotors
                emit BAT_MOT_RES;
                RECOVERY_STATE := false;
              end;
            end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Implementation of strategy curve:
%
% Name			SPEED_10_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		10 Km/h
% Value			10
%
% Name			SPEED_20_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		20 Km/h
% Value			20
%
% Name			SPEED_30_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		30 Km/h
% Value			30
%
% Name			SPEED_40_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		40 Km/h
% Value			40
%
% Name			SPEED_50_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		50 Km/h
% Value			50
%
% Name			SPEED_60_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		60 Km/h
% Value			60
%
% Name			SPEED_70_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		70 Km/h
% Value			70
%
% Name			SPEED_80_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		80 Km/h
% Value			80
%
% Name			SPEED_90_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		90 Km/h
% Value			90
%
% Name			SPEED_100_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		100 Km/h
% Value			100
%
% Name			SPEED_110_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		110 Km/h
% Value			110
%
% Name			SPEED_120_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		120 Km/h
% Value			120
%
% Name			SPEED_130_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		130 Km/h
% Value			130
%
% Name			SPEED_140_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		140 Km/h
% Value			140
%
% Name			SPEED_150_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		150 Km/h
% Value			150
%
% Name			SPEED_160_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		160 Km/h
% Value			160
%
% Name			SPEED_170_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		170 Km/h
% Value			170
%
% Name			SPEED_180_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		180 Km/h
% Value			180
%
% Name			SPEED_190_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		190 Km/h
% Value			190
%
% Name			SPEED_200_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		200 Km/h
% Value			200
%
% Name			SPEED_210_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		210 Km/h
% Value			210
%
% Name			SPEED_220_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		220 Km/h
% Value			220
%
% Name			SPEED_230_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		230 Km/h
% Value			230
%
% Name			SPEED_240_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		240 Km/h
% Value			240
%
% Name			SPEED_250_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		250 Km/h
% Value			250
%
module CURVE_FRONT:
input 
  RESET,
  VALUE(integer),
  SPEED(integer);
output
  CONTROL(integer);
constant
  HARD, MED, SOFT : integer,
  UP, DOWN : integer,
  V1_1,V1_2,V1_3,V1_4,V1_5,V1_6,V1_7,V1_8,V1_9,V1_10,V1_11,V1_12,V1_13,V1_14,V1_15,V1_16,V1_17,V1_18,V1_19,V1_20,V1_21,V1_22,V1_23,V1_24,V1_25 : integer,
  V2_1,V2_2,V2_3,V2_4,V2_5,V2_6,V2_7,V2_8,V2_9,V2_10,V2_11,V2_12,V2_13,V2_14,V2_15,V2_16,V2_17,V2_18,V2_19,V2_20,V2_21,V2_22,V2_23,V2_24,V2_25 : integer,
  SPEED_10_KM,SPEED_20_KM,SPEED_30_KM,SPEED_40_KM,SPEED_50_KM,SPEED_60_KM,SPEED_70_KM,SPEED_80_KM,SPEED_90_KM,SPEED_100_KM : integer,
  SPEED_110_KM,SPEED_120_KM,SPEED_130_KM,SPEED_140_KM,SPEED_150_KM,SPEED_160_KM,SPEED_170_KM,SPEED_180_KM,SPEED_190_KM,SPEED_200_KM : integer,
  SPEED_210_KM,SPEED_220_KM,SPEED_230_KM,SPEED_240_KM,SPEED_250_KM : integer,
  T1 : integer,
  T2 : integer;
var
  CURRENT_VALUE : integer,
  OLD_VALUE : integer,
  SPEED_VALUE : integer,
  CONTROL_VALUE : integer,
  DIRECTION : integer,
  V1 : integer,
  V2 : integer,
  TIME1 : integer,
  TIME2 : integer
in
  % Infinite loop
  loop
    % Reset sequence
    CURRENT_VALUE := 0;
    OLD_VALUE := 0;
    CONTROL_VALUE := SOFT;
    DIRECTION := UP;
    V1 := V1_1;
    V2 := V2_1;
    % When a RESET happens quit loop
    do
      loop
        % Emit control signal
        emit CONTROL(CONTROL_VALUE);
        % Memorize old value
        OLD_VALUE := CURRENT_VALUE;
        % Wait for new values
        await
          case SPEED do
            % Get its value
            SPEED_VALUE := ?SPEED;
            % Set the value of constants depending on speed
            if (SPEED_VALUE < SPEED_10_KM ) then
              V1 := V1_1;
              V2 := V2_1;
            else
              if (SPEED_VALUE < SPEED_20_KM ) then
                V1 := V1_2;
                V2 := V2_2;
              else
                if (SPEED_VALUE < SPEED_30_KM ) then
                  V1 := V1_3;
                  V2 := V2_3;
                else
                  if (SPEED_VALUE < SPEED_40_KM ) then
                    V1 := V1_4;
                    V2 := V2_4;
                  else
                    if (SPEED_VALUE < SPEED_50_KM ) then
                      V1 := V1_5;
                      V2 := V2_5;
                    else
                      if (SPEED_VALUE < SPEED_60_KM ) then
                        V1 := V1_6;
                        V2 := V2_6;
                      else
                        if (SPEED_VALUE < SPEED_70_KM ) then
                          V1 := V1_7;
                          V2 := V2_7;
                        else
                          if (SPEED_VALUE < SPEED_80_KM ) then
                            V1 := V1_8;
                            V2 := V2_8;
                          else
                            if (SPEED_VALUE < SPEED_90_KM ) then
                              V1 := V1_9;
                              V2 := V2_9;
                            else
                              if (SPEED_VALUE < SPEED_100_KM ) then
                                V1 := V1_10;
                                V2 := V2_10;
                              else
                                if (SPEED_VALUE < SPEED_110_KM ) then
                                  V1 := V1_11;
                                  V2 := V2_11;
                                else
                                  if (SPEED_VALUE < SPEED_120_KM ) then
                                    V1 := V1_12;
                                    V2 := V2_12;
                                  else
                                    if (SPEED_VALUE < SPEED_130_KM ) then
                                      V1 := V1_13;
                                      V2 := V2_13;
                                    else
                                      if (SPEED_VALUE < SPEED_140_KM ) then
                                        V1 := V1_14;
                                        V2 := V2_14;
                                      else
                                        if (SPEED_VALUE < SPEED_150_KM ) then
                                          V1 := V1_15;
                                          V2 := V2_15;
                                        else
                                          if (SPEED_VALUE < SPEED_160_KM ) then
                                            V1 := V1_16;
                                            V2 := V2_16;
                                          else
                                            if (SPEED_VALUE < SPEED_170_KM ) then
                                              V1 := V1_17;
                                              V2 := V2_17;
                                            else
                                              if (SPEED_VALUE < SPEED_180_KM ) then
                                                V1 := V1_18;
                                                V2 := V2_18;
                                              else
                                                if (SPEED_VALUE < SPEED_190_KM ) then
                                                  V1 := V1_19;
                                                  V2 := V2_19;
                                                else
                                                  if (SPEED_VALUE < SPEED_200_KM ) then
                                                    V1 := V1_20;
                                                    V2 := V2_20;
                                                  else
                                                    if (SPEED_VALUE < SPEED_210_KM ) then
                                                      V1 := V1_21;
                                                      V2 := V2_21;
                                                    else
                                                      if (SPEED_VALUE < SPEED_220_KM ) then
                                                        V1 := V1_22;
                                                        V2 := V2_22;
                                                      else
                                                        if (SPEED_VALUE < SPEED_230_KM ) then
                                                          V1 := V1_23;
                                                          V2 := V2_23;
                                                        else
                                                          if (SPEED_VALUE < SPEED_240_KM ) then
                                                            V1 := V1_24;
                                                            V2 := V2_24;
                                                          else
                                                            V1 := V1_25;
                                                            V2 := V2_25;
                                                          end;
                                                        end;
                                                      end;
                                                    end;
                                                  end;
                                                end;
                                              end;
                                            end;
                                          end;
                                        end;
                                      end;
                                    end;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          case VALUE do
            % Get it
            CURRENT_VALUE := ?VALUE;
%       end;
        % Set direction
        if (CURRENT_VALUE < OLD_VALUE) then
          DIRECTION := DOWN;
        else
          if (CURRENT_VALUE > OLD_VALUE) then
            DIRECTION := UP;
          end;
        end;
        % Search for the location of value on the curve
        if (DIRECTION = UP) then
          % If value is increasing
          if (CURRENT_VALUE < V1) then
           CONTROL_VALUE := SOFT;
          else
            if (CURRENT_VALUE < V2) then
              CONTROL_VALUE := MED;
            else
              CONTROL_VALUE :=HARD;
            end; 
          end;
        else
          % If value is decreasing
          if (CURRENT_VALUE > V2) then
            CONTROL_VALUE := HARD;
          else
            if (CURRENT_VALUE > V1) then
              if (CONTROL_VALUE <> MED) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE > V2) then
                  % Start timer
                  TIME1 := 0;
                else
                  % Increase the timer
                  TIME1 := TIME1 +1;
                  if (TIME1 > T1) then
                     CONTROL_VALUE := MED;
                  end;
                end;
              end;
            else
              if (CONTROL_VALUE <> SOFT) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE > V1) then
                  % Start timer
                  TIME2 := 0;
                else
                  % Increase the timer
                  TIME2 := TIME2 +1;
                  if (TIME2 > T2) then
                    CONTROL_VALUE := SOFT;
                  end;
                end;
              end;
            end;
          end;
        end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
module CURVE_REAR:
input 
  RESET,
  VALUE(integer),
  SPEED(integer);
output
  CONTROL(integer);
constant
  HARD, MED, SOFT : integer,
  UP, DOWN : integer,
  V1_1,V1_2,V1_3,V1_4,V1_5,V1_6,V1_7,V1_8,V1_9,V1_10,V1_11,V1_12,V1_13,V1_14,V1_15,V1_16,V1_17,V1_18,V1_19,V1_20,V1_21,V1_22,V1_23,V1_24,V1_25 : integer,
  V2_1,V2_2,V2_3,V2_4,V2_5,V2_6,V2_7,V2_8,V2_9,V2_10,V2_11,V2_12,V2_13,V2_14,V2_15,V2_16,V2_17,V2_18,V2_19,V2_20,V2_21,V2_22,V2_23,V2_24,V2_25 : integer,
  SPEED_10_KM,SPEED_20_KM,SPEED_30_KM,SPEED_40_KM,SPEED_50_KM,SPEED_60_KM,SPEED_70_KM,SPEED_80_KM,SPEED_90_KM,SPEED_100_KM : integer,
  SPEED_110_KM,SPEED_120_KM,SPEED_130_KM,SPEED_140_KM,SPEED_150_KM,SPEED_160_KM,SPEED_170_KM,SPEED_180_KM,SPEED_190_KM,SPEED_200_KM : integer,
  SPEED_210_KM,SPEED_220_KM,SPEED_230_KM,SPEED_240_KM,SPEED_250_KM : integer,
  DELT_1,DELT_2,DELT_3,DELT_4,DELT_5,DELT_6,DELT_7,DELT_8,DELT_9,DELT_10,DELT_11,DELT_12,DELT_13,DELT_14,DELT_15,DELT_16,DELT_17,DELT_18,DELT_19,DELT_20,DELT_21,DELT_22,DELT_23,DELT_24,DELT_25 : integer,
  T1 : integer,
  T2 : integer;
var
  CURRENT_VALUE : integer,
  OLD_VALUE : integer,
  SPEED_VALUE : integer,
  CONTROL_VALUE : integer,
  DIRECTION : integer,
  V1 : integer,
  V2 : integer,
  D : integer,
  TIME : integer
in
  % Infinite loop
  loop
    % Reset sequence
    CURRENT_VALUE := 0;
    OLD_VALUE := 0;
    CONTROL_VALUE := SOFT;
    DIRECTION := UP;
    V1 := V1_1;
    V2 := V2_1;
    D := DELT_1;
    % When a RESET happens quit loop
    do
      loop
        % Emit control signal
        emit CONTROL(CONTROL_VALUE);
        % Memorize old value
        OLD_VALUE := CURRENT_VALUE;
        % Wait for new values
        await
          case SPEED do
            % Get its value
            SPEED_VALUE := ?SPEED;
            % Set the value of constants depending on speed
            if (SPEED_VALUE < SPEED_10_KM ) then
              V1 := V1_1;
              V2 := V2_1;
              D := DELT_1;
            else
              if (SPEED_VALUE < SPEED_20_KM ) then
                V1 := V1_2;
                V2 := V2_2;
                D := DELT_2;
              else
                if (SPEED_VALUE < SPEED_30_KM ) then
                  V1 := V1_3;
                  V2 := V2_3;
                  D := DELT_3;
                else
                  if (SPEED_VALUE < SPEED_40_KM ) then
                    V1 := V1_4;
                    V2 := V2_4;
                    D := DELT_4;
                  else
                    if (SPEED_VALUE < SPEED_50_KM ) then
                      V1 := V1_5;
                      V2 := V2_5;
                      D := DELT_5;
                    else
                      if (SPEED_VALUE < SPEED_60_KM ) then
                        V1 := V1_6;
                        V2 := V2_6;
                        D := DELT_6;
                      else
                        if (SPEED_VALUE < SPEED_70_KM ) then
                          V1 := V1_7;
                          V2 := V2_7;
                          D := DELT_7;
                        else
                          if (SPEED_VALUE < SPEED_80_KM ) then
                            V1 := V1_8;
                            V2 := V2_8;
                            D := DELT_8;
                          else
                            if (SPEED_VALUE < SPEED_90_KM ) then
                              V1 := V1_9;
                              V2 := V2_9;
                              D := DELT_9;
                            else
                              if (SPEED_VALUE < SPEED_100_KM ) then
                                V1 := V1_10;
                                V2 := V2_10;
                                D := DELT_10;
                              else
                                if (SPEED_VALUE < SPEED_110_KM ) then
                                  V1 := V1_11;
                                  V2 := V2_11;
                                  D := DELT_11;
                                else
                                  if (SPEED_VALUE < SPEED_120_KM ) then
                                    V1 := V1_12;
                                    V2 := V2_12;
                                    D := DELT_12;
                                  else
                                    if (SPEED_VALUE < SPEED_130_KM ) then
                                      V1 := V1_13;
                                      V2 := V2_13;
                                      D := DELT_13;
                                    else
                                      if (SPEED_VALUE < SPEED_140_KM ) then
                                        V1 := V1_14;
                                        V2 := V2_14;
                                        D := DELT_14;
                                      else
                                        if (SPEED_VALUE < SPEED_150_KM ) then
                                          V1 := V1_15;
                                          V2 := V2_15;
                                          D := DELT_15;
                                        else
                                          if (SPEED_VALUE < SPEED_160_KM ) then
                                            V1 := V1_16;
                                            V2 := V2_16;
                                            D := DELT_16;
                                          else
                                            if (SPEED_VALUE < SPEED_170_KM ) then
                                              V1 := V1_17;
                                              V2 := V2_17;
                                              D := DELT_17;
                                            else
                                              if (SPEED_VALUE < SPEED_180_KM ) then
                                                V1 := V1_18;
                                                V2 := V2_18;
                                                D := DELT_18;
                                              else
                                                if (SPEED_VALUE < SPEED_190_KM ) then
                                                  V1 := V1_19;
                                                  V2 := V2_19;
                                                  D := DELT_19;
                                                else
                                                  if (SPEED_VALUE < SPEED_200_KM ) then
                                                    V1 := V1_20;
                                                    V2 := V2_20;
                                                    D := DELT_20;
                                                  else
                                                    if (SPEED_VALUE < SPEED_210_KM ) then
                                                      V1 := V1_21;
                                                      V2 := V2_21;
                                                      D := DELT_21;
                                                    else
                                                      if (SPEED_VALUE < SPEED_220_KM ) then
                                                        V1 := V1_22;
                                                        V2 := V2_22;
                                                        D := DELT_22;
                                                      else
                                                        if (SPEED_VALUE < SPEED_230_KM ) then
                                                          V1 := V1_23;
                                                          V2 := V2_23;
                                                          D := DELT_23;
                                                        else
                                                          if (SPEED_VALUE < SPEED_240_KM ) then
                                                            V1 := V1_24;
                                                            V2 := V2_24;
                                                            D := DELT_24;
                                                          else
                                                            V1 := V1_25;
                                                            V2 := V2_25;
                                                            D := DELT_25;
                                                          end;
                                                        end;
                                                      end;
                                                    end;
                                                  end;
                                                end;
                                              end;
                                            end;
                                          end;
                                        end;
                                      end;
                                    end;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          case VALUE do
            % Get it
            CURRENT_VALUE := ?VALUE;
%       end;
        % Set direction
        if (CURRENT_VALUE < OLD_VALUE) then
          DIRECTION := DOWN;
        else
          if (CURRENT_VALUE > OLD_VALUE) then
            DIRECTION := UP;
          end;
        end;
        % Search for the location of value on the curve
        if (DIRECTION = UP) then
          % If value is increasing
          if (CURRENT_VALUE < V1) then
           CONTROL_VALUE := SOFT;
          else
            if (CURRENT_VALUE < V2) then
              % Test changes
              if (CONTROL_VALUE <> MED) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE < V1 ) then
                  % Start timer
                  TIME := 0;
                else
                  % Increase the timer
                  TIME := TIME +1;
                  % Test timer
                  if (TIME > D) then
                    CONTROL_VALUE := MED;
                  end;
                end;
              end;
            else
              % Test changes
              if (CONTROL_VALUE <> HARD) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE < V2 ) then
                  % Start timer
                  TIME := 0;
                else
                  % Increase the timer
                  TIME := TIME +1;
                  % Test timer
                  if (TIME > D) then
                    CONTROL_VALUE := HARD;
                  end;
                end;
              end;
            end; 
          end;
        else
          % If value is decreasing
          if (CURRENT_VALUE > V2) then
            CONTROL_VALUE := HARD;
          else
            if (CURRENT_VALUE > V1) then
              % Test changes
              if (CONTROL_VALUE <> MED) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE > V2) then
                  % Start timer
                  TIME := 0;
                else
                  % Increase the timer
                  TIME := TIME +1;
                  % Test_timer
                  if (TIME > T1+ D) then
                    CONTROL_VALUE := MED;
                  end;
                end;
              end;
            else
              % Test changes
              if (CONTROL_VALUE <> SOFT) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE > V1) then
                  % Start timer
                  TIME := 0;
                else
                  % Increase the timer
                  TIME := TIME +1;
                  % Test_timer
                  if (TIME > T2+ D) then
                    CONTROL_VALUE := SOFT;
                  end;
                end;
              end;
            end;
          end;
        end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Implementation of strategy curve:
%
% Name			SPEED_10_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		10 Km/h
% Value			10
%
% Name			SPEED_20_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		20 Km/h
% Value			20
%
% Name			SPEED_30_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		30 Km/h
% Value			30
%
% Name			SPEED_40_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		40 Km/h
% Value			40
%
% Name			SPEED_50_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		50 Km/h
% Value			50
%
% Name			SPEED_60_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		60 Km/h
% Value			60
%
% Name			SPEED_70_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		70 Km/h
% Value			70
%
% Name			SPEED_80_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		80 Km/h
% Value			80
%
% Name			SPEED_90_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		90 Km/h
% Value			90
%
% Name			SPEED_100_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		100 Km/h
% Value			100
%
% Name			SPEED_110_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		110 Km/h
% Value			110
%
% Name			SPEED_120_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		120 Km/h
% Value			120
%
% Name			SPEED_130_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		130 Km/h
% Value			130
%
% Name			SPEED_140_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		140 Km/h
% Value			140
%
% Name			SPEED_150_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		150 Km/h
% Value			150
%
% Name			SPEED_160_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		160 Km/h
% Value			160
%
% Name			SPEED_170_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		170 Km/h
% Value			170
%
% Name			SPEED_180_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		180 Km/h
% Value			180
%
% Name			SPEED_190_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		190 Km/h
% Value			190
%
% Name			SPEED_200_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		200 Km/h
% Value			200
%
% Name			SPEED_210_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		210 Km/h
% Value			210
%
% Name			SPEED_220_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		220 Km/h
% Value			220
%
% Name			SPEED_230_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		230 Km/h
% Value			230
%
% Name			SPEED_240_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		240 Km/h
% Value			240
%
% Name			SPEED_250_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Speed threshold
% Threshold		250 Km/h
% Value			250
%
module CURVE:
input 
  RESET,
  VALUE(integer),
  SPEED(integer);
output
  CONTROL(integer);
constant
  HARD, MED, SOFT : integer,
  UP, DOWN : integer,
  V1_1,V1_2,V1_3,V1_4,V1_5,V1_6,V1_7,V1_8,V1_9,V1_10,V1_11,V1_12,V1_13,V1_14,V1_15,V1_16,V1_17,V1_18,V1_19,V1_20,V1_21,V1_22,V1_23,V1_24,V1_25 : integer,
  V2_1,V2_2,V2_3,V2_4,V2_5,V2_6,V2_7,V2_8,V2_9,V2_10,V2_11,V2_12,V2_13,V2_14,V2_15,V2_16,V2_17,V2_18,V2_19,V2_20,V2_21,V2_22,V2_23,V2_24,V2_25 : integer,
  SPEED_10_KM,SPEED_20_KM,SPEED_30_KM,SPEED_40_KM,SPEED_50_KM,SPEED_60_KM,SPEED_70_KM,SPEED_80_KM,SPEED_90_KM,SPEED_100_KM : integer,
  SPEED_110_KM,SPEED_120_KM,SPEED_130_KM,SPEED_140_KM,SPEED_150_KM,SPEED_160_KM,SPEED_170_KM,SPEED_180_KM,SPEED_190_KM,SPEED_200_KM : integer,
  SPEED_210_KM,SPEED_220_KM,SPEED_230_KM,SPEED_240_KM,SPEED_250_KM : integer,
  T1 : integer,
  T2 : integer;
var
  CURRENT_VALUE : integer,
  OLD_VALUE : integer,
  SPEED_VALUE : integer,
  CONTROL_VALUE : integer,
  DIRECTION : integer,
  V1 : integer,
  V2 : integer,
  TIME1 : integer,
  TIME2 : integer
in
  % Infinite loop
  loop
    % Reset sequence
    CURRENT_VALUE := 0;
    OLD_VALUE := 0;
    CONTROL_VALUE := SOFT;
    DIRECTION := UP;
    V1 := V1_1;
    V2 := V2_1;
    % When a RESET happens quit loop
    do
      loop
        % Emit control signal
        emit CONTROL(CONTROL_VALUE);
        % Memorize old value
        OLD_VALUE := CURRENT_VALUE;
        % Wait for new values
        await
          case SPEED do
            % Get its value
            SPEED_VALUE := ?SPEED;
            % Set the value of constants depending on speed
            if (SPEED_VALUE < SPEED_10_KM ) then
              V1 := V1_1;
              V2 := V2_1;
            else
              if (SPEED_VALUE < SPEED_20_KM ) then
                V1 := V1_2;
                V2 := V2_2;
              else
                if (SPEED_VALUE < SPEED_30_KM ) then
                  V1 := V1_3;
                  V2 := V2_3;
                else
                  if (SPEED_VALUE < SPEED_40_KM ) then
                    V1 := V1_4;
                    V2 := V2_4;
                  else
                    if (SPEED_VALUE < SPEED_50_KM ) then
                      V1 := V1_5;
                      V2 := V2_5;
                    else
                      if (SPEED_VALUE < SPEED_60_KM ) then
                        V1 := V1_6;
                        V2 := V2_6;
                      else
                        if (SPEED_VALUE < SPEED_70_KM ) then
                          V1 := V1_7;
                          V2 := V2_7;
                        else
                          if (SPEED_VALUE < SPEED_80_KM ) then
                            V1 := V1_8;
                            V2 := V2_8;
                          else
                            if (SPEED_VALUE < SPEED_90_KM ) then
                              V1 := V1_9;
                              V2 := V2_9;
                            else
                              if (SPEED_VALUE < SPEED_100_KM ) then
                                V1 := V1_10;
                                V2 := V2_10;
                              else
                                if (SPEED_VALUE < SPEED_110_KM ) then
                                  V1 := V1_11;
                                  V2 := V2_11;
                                else
                                  if (SPEED_VALUE < SPEED_120_KM ) then
                                    V1 := V1_12;
                                    V2 := V2_12;
                                  else
                                    if (SPEED_VALUE < SPEED_130_KM ) then
                                      V1 := V1_13;
                                      V2 := V2_13;
                                    else
                                      if (SPEED_VALUE < SPEED_140_KM ) then
                                        V1 := V1_14;
                                        V2 := V2_14;
                                      else
                                        if (SPEED_VALUE < SPEED_150_KM ) then
                                          V1 := V1_15;
                                          V2 := V2_15;
                                        else
                                          if (SPEED_VALUE < SPEED_160_KM ) then
                                            V1 := V1_16;
                                            V2 := V2_16;
                                          else
                                            if (SPEED_VALUE < SPEED_170_KM ) then
                                              V1 := V1_17;
                                              V2 := V2_17;
                                            else
                                              if (SPEED_VALUE < SPEED_180_KM ) then
                                                V1 := V1_18;
                                                V2 := V2_18;
                                              else
                                                if (SPEED_VALUE < SPEED_190_KM ) then
                                                  V1 := V1_19;
                                                  V2 := V2_19;
                                                else
                                                  if (SPEED_VALUE < SPEED_200_KM ) then
                                                    V1 := V1_20;
                                                    V2 := V2_20;
                                                  else
                                                    if (SPEED_VALUE < SPEED_210_KM ) then
                                                      V1 := V1_21;
                                                      V2 := V2_21;
                                                    else
                                                      if (SPEED_VALUE < SPEED_220_KM ) then
                                                        V1 := V1_22;
                                                        V2 := V2_22;
                                                      else
                                                        if (SPEED_VALUE < SPEED_230_KM ) then
                                                          V1 := V1_23;
                                                          V2 := V2_23;
                                                        else
                                                          if (SPEED_VALUE < SPEED_240_KM ) then
                                                            V1 := V1_24;
                                                            V2 := V2_24;
                                                          else
                                                            V1 := V1_25;
                                                            V2 := V2_25;
                                                          end;
                                                        end;
                                                      end;
                                                    end;
                                                  end;
                                                end;
                                              end;
                                            end;
                                          end;
                                        end;
                                      end;
                                    end;
                                  end;
                                end;
                              end;
                            end;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
            end;
          case VALUE do
            % Get it
            CURRENT_VALUE := ?VALUE;
%        end;
        % Set direction
        if (CURRENT_VALUE < OLD_VALUE) then
          DIRECTION := DOWN;
        else
          if (CURRENT_VALUE > OLD_VALUE) then
            DIRECTION := UP;
          end;
        end;
        % Search for the location of value on the curve
        if (DIRECTION = UP) then
          % If value is increasing
          if (CURRENT_VALUE < V1) then
           CONTROL_VALUE := SOFT;
          else
            if (CURRENT_VALUE < V2) then
              CONTROL_VALUE := MED;
            else
              CONTROL_VALUE := HARD;
            end; 
          end;
        else
          % If value is decreasing
          if (CURRENT_VALUE > V2) then
            CONTROL_VALUE := HARD;
          else
            if (CURRENT_VALUE > V1) then
              if (CONTROL_VALUE <> MED) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE > V2) then
                  % Start timer
                  TIME1 := 0;
                else
                  % Increase the timer
                  TIME1 := TIME1 + 1;
                  if (TIME1 > T1) then
                    CONTROL_VALUE := MED;
                  end;
                end;
              end;
            else
              if (CONTROL_VALUE <> SOFT) then
                % Test whether it just crossed the threshold
                if (OLD_VALUE > V1) then
                  % Start timer
                  TIME2 := 0;
                else
                  % Increase the timer
                  TIME2 := TIME2 +1;
                  if (TIME2 > T2) then
                    CONTROL_VALUE := SOFT;
                  end;
                end;
              end;
            end;
          end;
        end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
module DRIVER:
input
  RESET,
  CLOCK_500,
  COMMAND(integer),
  DAMAGE(integer),
  POS_A(boolean),
  POS_B(boolean),
  VBAT(integer);
output
  CHANNEL_P(boolean),
  CHANNEL_N(boolean);
constant
  SOFT, MED, HARD : integer,
  TIME_START : integer,
  TIME_STOP : integer,
  TIME_45 : integer,
  TIME_30 : integer,
  TIME_15 : integer,
  VBAT_10_V : integer,
  VBAT_12_V : integer,
  VBAT_13_V : integer;
var
  CHANNEL_P_VALUE : boolean,
  CHANNEL_N_VALUE : boolean,
  POS_A_VALUE : boolean,
  POS_B_VALUE : boolean,
  POS_VALUE : integer,
  COM_VALUE : integer,
  DAM_VALUE : integer,
  VBAT_VALUE : integer,
  START_TIMER : integer,
  STOP_TIMER : integer,
  TIME_ADD : integer
in
  % Infinite loop
  loop
    % Reset sequence
    CHANNEL_P_VALUE := false;
    CHANNEL_N_VALUE := true;
    POS_VALUE := SOFT;
    COM_VALUE := SOFT;
    DAM_VALUE := SOFT;
    START_TIMER := 0;
    STOP_TIMER := 0;
    do
      loop
        emit CHANNEL_P(CHANNEL_P_VALUE);
        emit CHANNEL_N(CHANNEL_N_VALUE);
        await
          case CLOCK_500 do
            % Test phase
            if ((POS_VALUE <> COM_VALUE) and (not CHANNEL_P_VALUE)) then
              % Increase START_TIMER
              START_TIMER := START_TIMER + 1;
            else
              if ((POS_VALUE = COM_VALUE) and (not CHANNEL_N_VALUE)) then
                % Increase START_TIMER
                STOP_TIMER := STOP_TIMER + 1;
              end;
            end;
          case COMMAND do
            % Get its value
            COM_VALUE := ?COMMAND;
	    % Test damage
            if (DAM_VALUE > COM_VALUE) then
              COM_VALUE := DAM_VALUE;
            end;
          case DAMAGE do
            % Get value of DAMAGE
            DAM_VALUE := ?DAMAGE;
	    % Test damage
            if (DAM_VALUE > COM_VALUE) then
              COM_VALUE := DAM_VALUE;
            end;
	  case POS_A do
	    % Get motor position
            POS_A_VALUE := ?POS_A;
	    % Set position
            if (POS_A_VALUE and (not POS_B_VALUE)) then
              POS_VALUE := HARD;
            else
              if (POS_B_VALUE and (not POS_A_VALUE)) then
                POS_VALUE := SOFT;
              else
                POS_VALUE := MED;
              end;
            end;
          case POS_B do
	    % Get motor position
	    POS_B_VALUE := ?POS_B;
	    % Set position
            if (POS_A_VALUE and (not POS_B_VALUE)) then
              POS_VALUE := HARD;
            else
              if (POS_B_VALUE and (not POS_A_VALUE)) then
                POS_VALUE := SOFT;
              else
                POS_VALUE := MED;
              end;
            end;
	  case VBAT do
            % Get voltage level of battery
            VBAT_VALUE := ?VBAT;
            % Set time delay according to the voltage
            if (VBAT_VALUE < VBAT_10_V) then
              TIME_ADD := TIME_45;
            else
              if (VBAT_VALUE < VBAT_12_V) then
                TIME_ADD := TIME_30;
              else
                if (VBAT_VALUE < VBAT_13_V) then
                  TIME_ADD := TIME_15;
                else
                  TIME_ADD := 0;
                end;
              end;
            end;
        end;
        % Test position
        if (POS_VALUE <> COM_VALUE) then
          % Test timer
          if (START_TIMER > TIME_START) then
            CHANNEL_P_VALUE := true;
            START_TIMER := 0;
          else
            CHANNEL_N_VALUE := false;
          end;
        else
          % Test timer
          if (STOP_TIMER > TIME_STOP + TIME_ADD) then
            CHANNEL_N_VALUE := true;
            STOP_TIMER := 0;
          else
            CHANNEL_P_VALUE := false;
          end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Frequency filter:
%
% It filters the input according to the following formula:
%
% FILT_VALUE(t) := (B0 * VALUE(t) + B1 * VALUE(t-1) + B2 * VALUE(t-2) +
%                  A0 * FILT_VALUE(t-1) + A1 * FILT_VALUE(t-2))/2^14.
%
% When RESET arrives it outputs 0.
%
module FILTER_FREQ:
function POLIS_RSH(integer,integer) : integer;
input
  RESET,
  VALUE(integer);
output
  FILT_VALUE(integer);
constant
  B0 : integer,
  B1 : integer,
  B2 : integer,
  A0 : integer,
  A1 : integer;
var
  VAL_0 : integer,
  VAL_1 : integer,
  VAL_2 : integer,
  FILT_VAL_0 : integer,
  FILT_VAL_1 : integer,
  FILT_VAL_2 : integer
in
  % Infinite loop
  loop
    % Reset sequence
    VAL_0 := 0;
    VAL_1 := 0;
    VAL_2 := 0;
    FILT_VAL_0 := 0;
    FILT_VAL_1 := 0;
    FILT_VAL_2 := 0;
    % When a RESET happens quit loop
    do
      loop
        % Compute the filtered value
        FILT_VAL_0 := POLIS_RSH(B0 * VAL_0 + B1 * VAL_1 + B2 * VAL_2 + A0 * FILT_VAL_1 + A1 * FILT_VAL_2,14);
        % Emit filtered value
        emit FILT_VALUE(FILT_VAL_0);
	% Shift the values
        VAL_2 := VAL_1;
        VAL_1 := VAL_0;
        FILT_VAL_2 := FILT_VAL_1;
        FILT_VAL_1 := FILT_VAL_0;
        % Wait for a new input value
        await VALUE;
        % Get the value itself
        VAL_0 := ?VALUE;
      end
    watching RESET;
  end
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Filter:
%
% It filters the input according to the following formula:
%
% FILT_VALUE(t) := FILT_VALUE(t-1) + (VALUE(t) - FILT_VALUE(t-1)) / K.
%
% When RESET arrives it outputs 0.
%
module FILTER:
input
  RESET,
  VALUE(integer);
output
  FILT_VALUE(integer);
constant
  K : integer;
var
  VAL : integer,
  FILT_VAL : integer
in
  % Infinite loop
  loop
    % Reset sequence
    FILT_VAL := 0;
    % When a RESET happens quit loop
    do
      loop
        % Emit filtered value
        emit FILT_VALUE(FILT_VAL);
        % Wait for a new value
        await VALUE;
        % Get the value itself
        VAL := ?VALUE;
        % Compute the filtered value
        FILT_VAL := FILT_VAL + (VAL - FILT_VAL) / K ;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Longitudinal acceleration calculation:
%
% It calulates the longitudinal acceleration according to the
% following formula:
%
% ACC = (LONG_SPEED_FILT(t) - LONG_SPEED_FILT(t-K)) / K.
%
% It does not divide it by K because it is done by changing the
% resolution:
% 
% ACC * R_ACC = D_LONG_SPEED_FILT * R_VEL / ( K * 24 * 10E-3 * 3.6 )
%
% R_ACC = 255 * 10E+3 / ( 8 * 24 * 3.6 * 2^16) = 0.005629 [ (m/sec^2)/bit ]
%
% CONSTANT:
%
% Name			K
% Data size		Unsigned 8 bit
% Range			0 - 6.1 sec
% Resolution		24 msec/bit 
% Function		Coefficient
% Symbolic value	192 ms
% Value			8
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_24
% Period		24 msec
% Function		Clock for sampling LONG_SPEED_FILT
%
% Name			LONG_SPEED_FILT
% Data size		unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 Km/h
% Function		Filtered speed of car
%
% OUTPUTS:
%
% Name			ACC
% Data size		Signed 16 bit
% Range			+/- 184 m/sec^2
% Resolution		0.0056 (m/sec^2)/bit
% Function		Longitudinal acceleration/decceleration
%
module LONG_ACC_CAL:
input
  RESET,
  CLOCK_24,
  LONG_SPEED_FILT(integer);
output
  ACC(integer);
var
  SPEED_VAL_0 : integer,	% instantaneous speed value
  SPEED_VAL_1 : integer,	% instantaneous speed value
  SPEED_VAL_2 : integer,	% instantaneous speed value
  SPEED_VAL_3 : integer,	% instantaneous speed value
  SPEED_VAL_4 : integer,	% instantaneous speed value
  SPEED_VAL_5 : integer,	% instantaneous speed value
  SPEED_VAL_6 : integer,	% instantaneous speed value
  SPEED_VAL_7 : integer,	% instantaneous speed value
  SPEED_VAL_8 : integer,	% instantaneous speed value
  ACC_VALUE : integer	% longitudinal acceleration
in
  % Infinite loop
  loop
    % Reset sequence
    SPEED_VAL_0 := 0;
    SPEED_VAL_1 := 0;
    SPEED_VAL_2 := 0;
    SPEED_VAL_3 := 0;
    SPEED_VAL_4 := 0;
    SPEED_VAL_5 := 0;
    SPEED_VAL_6 := 0;
    SPEED_VAL_7 := 0;
    SPEED_VAL_8 := 0;
    % When a RESET happens quit the loop
    do
      loop
        await
          case LONG_SPEED_FILT do
            % Get the value of filtered longitudinal speed
            SPEED_VAL_0 := ?LONG_SPEED_FILT;
          case CLOCK_24 do
            % Compute the acceleration value
            ACC_VALUE := SPEED_VAL_0 - SPEED_VAL_8;
            % Emit result
            emit ACC(ACC_VALUE);
            % Shift speed values
            SPEED_VAL_8 := SPEED_VAL_7;
            SPEED_VAL_7 := SPEED_VAL_6;
            SPEED_VAL_6 := SPEED_VAL_5;
            SPEED_VAL_5 := SPEED_VAL_4;
            SPEED_VAL_4 := SPEED_VAL_3;
            SPEED_VAL_3 := SPEED_VAL_2;
            SPEED_VAL_2 := SPEED_VAL_1;
            SPEED_VAL_1 := SPEED_VAL_0;
        end;
      end;
    watching RESET;
  end
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Derivative of longitudinal acceleration calculation:
%
% It calulates the derivative of filtered longitudinal acceleration
% according to the following formula:
%
% ACC_DER = (ACC_FILT(t) - ACC_FILT(t-Ka)) / Ka.
%
% It does not divide it by Ka because it is done by changing the
% resolution:
%
% ACC_DER * R_DER = D_ACC_FILT * R_ACC / ( Ka * 24 * 10E-3 )
%
% R_DER = 255 * 10E+6 / ( 8 * 12 * 24^2 * 2^16) = 0.01955 [ (m/sec^3)/bit ]
%
% CONSTANT:
%
% Name			Ka
% Data size		Unsigned 8 bit
% Range			0 - 6.1 sec
% Resolution		24 ms/bit 
% Function		Coefficient
% Symbolic value	288 ms
% Value			12
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			ACC_FILT
% Data size		Signed 16 bit
% Range			+/- 184 m/sec^2
% Resolution		0.0056 (m/sec^2)/bit
% Function		Longitudinal acceleration/decceleration
%
% OUTPUTS
%
% Name			ACC_DER
% Data size		Signed 16 bit
% Range			+/- 640 m/sec^3
% Resolution		0.0195 (m/sec^3)/bit
% Function		Derivative of filtered longitudinal acceleration/decceleration
%
module LONG_ACC_DER:
input
  RESET,
  ACC_FILT(integer);
output
  ACC_DER(integer);
var
  ACC_VALUE_0 : integer,	% acceleration value
  ACC_VALUE_1 : integer,	% acceleration value
  ACC_VALUE_2 : integer,	% acceleration value
  ACC_VALUE_3 : integer,	% acceleration value
  ACC_VALUE_4 : integer,	% acceleration value
  ACC_VALUE_5 : integer,	% acceleration value
  ACC_VALUE_6 : integer,	% acceleration value
  ACC_VALUE_7 : integer,	% acceleration value
  ACC_VALUE_8 : integer,	% acceleration value
  ACC_VALUE_9 : integer,	% acceleration value
  ACC_VALUE_10 : integer,	% acceleration value
  ACC_VALUE_11 : integer,	% acceleration value
  ACC_VALUE_12 : integer,	% acceleration value
  ACC_DER_VALUE : integer	% derivative of filtered longitudinal acceleration
in
  % infinite loop
  loop
    % Reset sequence
    ACC_VALUE_0 := 0;
    ACC_VALUE_1 := 0;
    ACC_VALUE_2 := 0;
    ACC_VALUE_3 := 0;
    ACC_VALUE_4 := 0;
    ACC_VALUE_5 := 0;
    ACC_VALUE_6 := 0;
    ACC_VALUE_7 := 0;
    ACC_VALUE_8 := 0;
    ACC_VALUE_9 := 0;
    ACC_VALUE_10 := 0;
    ACC_VALUE_11 := 0;
    ACC_VALUE_12 := 0;
    % When a RESET happens quit loop
    do
      loop
        % Compute the value of derivative of filtered longitudinal accelreration
        ACC_DER_VALUE := (ACC_VALUE_0 - ACC_VALUE_12);
        % Emit result
        emit ACC_DER(ACC_DER_VALUE);
        % Shift acceleration values
        ACC_VALUE_12 := ACC_VALUE_11;
        ACC_VALUE_11 := ACC_VALUE_10;
        ACC_VALUE_10 := ACC_VALUE_9;
        ACC_VALUE_9 := ACC_VALUE_8;
        ACC_VALUE_8 := ACC_VALUE_7;
        ACC_VALUE_7 := ACC_VALUE_6;
        ACC_VALUE_6 := ACC_VALUE_5;
        ACC_VALUE_5 := ACC_VALUE_4;
        ACC_VALUE_4 := ACC_VALUE_3;
        ACC_VALUE_3 := ACC_VALUE_2;
        ACC_VALUE_2 := ACC_VALUE_1;
        ACC_VALUE_1 := ACC_VALUE_0;
        % Wait for filtered longitudinal acceleration
        await ACC_FILT;
        % Get the value of filtered longitudinal acceleration
        ACC_VALUE_0 := ?ACC_FILT;
      end
    watching RESET;
  end
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% TRS time calculation for longitudinal calculation:
%
% It measures the time slot (D_TIME) spent between two impulses of
% speed sensor and it calculates the summary of 4 slots (TRS_A) and of
% 8 slots (TRS_B) when a new impulse arrives. When D_TIME is greater
% then SPEED_STOP constant then the vehicle is stopped and it sends a
% signal (SPEED_OFF) out. The car is considered as stopped if its
% speed is less then 4 km/h (SPEED_MIN).
%
% SPEED_STOP := 1 / (SPEED_MIN * SPEED_SENS);
%
% SPEED_STOP := 1 / (4 [km/h] * 1.11 [Hz/(KM/h)]);
%
% SPEED_STOP := 225.225 [msec];
%
%
% CONSTANTS:
%
% Name		SPEED_STOP
% Data size	Unsigned 16 bit
% Range		0 - 1.049 sec
% Resolution	32 usec/bit
% Function	Max time without edge
% Threshold	225 msec
% Value		7038
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_32
% Period		32 usec
% Function		Measuring time spent between two impulses
%
% Name			SPEED_SENS
% Data size		1 bit
% Range			0 - 255 Km/h
% Resolution		1.11 Hz/(Km/h)
% Function		Impulses from speed sensor
%
%
% OUTPUTS:
%
% Name			TRS_A
% Data size		Unsigned 16 bit
% Range			0 - 2.097 sec
% Resolution		32 usec/bit
% Function		Summary of 4 periods
%
% Name			TRS_B
% Data size		Unsigned 16 bit
% Range			0 - 2.097 sec
% Resolution		32 usec/bit
% Function		Summary of 8 periods
%
% Name			SPEED_OFF
% Data size		1 bit
% Range			ON - OFF
% Function		Flag for state of car
%
module LONG_SPEED_CAL_TRS:
input
  RESET,
  CLOCK_32,
  SPEED_SENS;
output
  TRS_A(integer),
  TRS_B(integer),
  SPEED_OFF;
constant
  SPEED_STOP : integer;
var
  D_TIME : integer,	% time of a slot
  D_TIME_0 : integer,	% time slot
  D_TIME_1 : integer,	% time slot
  D_TIME_2 : integer,	% time slot
  D_TIME_3 : integer,	% time slot
  D_TIME_4 : integer,	% time slot
  D_TIME_5 : integer,	% time slot
  D_TIME_6 : integer,	% time slot
  D_TIME_7 : integer,	% time slot
  TIME_A : integer,	% summary of 4 time slots
  TIME_B : integer	% summary of 8 time slots
in
  % Infinite loop
  loop
    await RESET;
    % Reset sequence
    D_TIME := 0;
    D_TIME_0 := 0;
    D_TIME_1 := 0;
    D_TIME_2 := 0;
    D_TIME_3 := 0;
    D_TIME_4 := 0;
    D_TIME_5 := 0;
    D_TIME_6 := 0;
    D_TIME_7 := 0;
    TIME_A := 0;
    TIME_B := 0;
    % When a RESET happens quit loop
    do
      % Infinite loop for getting an impulse from speed sensor
      loop
        % Compute the summeries of periods
        TIME_A := TIME_A - D_TIME_3 + D_TIME;
        TIME_B := TIME_B - D_TIME_7 + D_TIME;
        if (D_TIME < SPEED_STOP) then
          % Emit results
          emit TRS_A(TIME_A);
          emit TRS_B(TIME_B);
        end;
        % Shift values of periods
        D_TIME_7 := D_TIME_6;
        D_TIME_6 := D_TIME_5;
        D_TIME_5 := D_TIME_4;
        D_TIME_4 := D_TIME_3;
        D_TIME_3 := D_TIME_2;
        D_TIME_2 := D_TIME_1;
        D_TIME_1 := D_TIME_0;
        % Memorize time slot spent between two impulses
        D_TIME_0 := D_TIME;
        % Reset D_TIME
        D_TIME := 0;
        % Infinite loop for measuring time spent between two impulses
        loop
          % Waitb for CLOCK_32
          await CLOCK_32;
          % Increase timer
          D_TIME := D_TIME + 1;
          % Test the value of timer
          if (D_TIME > SPEED_STOP) then
            % If it is more than the max value then emit SPEED_OFF
            emit SPEED_OFF;
            % Halt until SPEED_SENS
            halt;
          end;
        end;
      each SPEED_SENS;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Longitudinal speed value calculation:
%
% It gets TRS_A and TRS_B values and determines the speed measure
% strategy according to their values and send the instantaneous speed
% value according to the following form:
%
% SPEED_SENS := SPEED_FREQ / SPEED_INST;
%
% SPEED_INST := SPEED_FREQ / SPEED_SENS;
%
% SPEED_INST := 1 / (TRS * SPEED_SENS);
%
% SPEED_INST [km/h] := 1 / (TRS [32 usec] * SPEED_SENS [Hz/(Km/h)]);
%
% SPEED_INST [Km/h] := 1 / (TRS * 32E-6 [sec] * 1.11 [Hz/(Km/h)]);
%
% SPEED_INST [Km/h] := 28153.153 / TRS;
%
% TRS_A := TRS(i) + TRS(i+1) + TRS(i+2) + TRS(i+3);
%
% TRS_B := TRS(i) + ... + TRS(i+7);
%
% HSPEED := 76 [Km/h] -> LPERIOD := 4 / (HSPEED * SPEED_SENS);
%
% LPERIOD := 47.426 [msec];
%
% LSPEED : 72 [Km/h] -> HPERIOD := 50.050 [msec];
%
% A strategy:
%
% SPEED_INST [Km/h] := (4 * 28153.153) / TRS_A;
%
% SPEED_INST [Km/h] := 112612.61 / TRS_A;
%
% SPEED_INST [256 * Km/h] := 28828829 /TRS_A;
%
% TIME_REF_A := 28828829;
%
% B strategy:
%
% SPEED_INST [Km/h] := (8 * 56306.306) / TRS_B;
%
% SPEED_INST [Km/h] := 225225.23 / TRS_B;
%
% SPEED_INST [256 * Km/h] := 57657658 /TRS_A;
%
% TIME_REF_B := 57657658;
%
% CONSTANTS:
%
% Name		TIME_REF_A
% Data size	Unsigned 16 bit
% Value		28828829
%
% Name		TIME_REF_B
% Data size	Unsigned 16 bit
% Value		57657658
%
% Name		HPERIOD
% Data size	Unsigned 16 bit
% Range		0 - 2.097 sec
% Resolution	32 usec/bit
% Function	Low threshold of strategy transition
% Threshold	50.05 msec (4 impulses)
% Value		6256
%
% Name		LPERIOD
% Data size	Unsigned 16 bit
% Range		0 - 2.097 sec
% Resolution	32 usec/bit
% Function	High threshold of strategy transition
% Threshold	47.42 msec (4 impulses)
% Value		5927
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			TRS_A
% Data size		Unsigned 16 bit
% Range			0 - 2.097 sec
% Resolution		32 usec/bit
% Function		Summary of 4 periods
%
% Name			TRS_B
% Data size		Unsigned 16 bit
% Range			0 - 2.097 sec
% Resolution		32 usec/bit
% Function		Summary of 8 periods
%
% Name			SPEED_OFF
% Data size		1 bit
% Range			ON - OFF
% Function		Flag for state of car
%
% OUTPUTS:
%
% Name			SPEED_INST
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Continuous longitudinal speed
%
module LONG_SPEED_CAL_VAL:
input
  RESET,
  TRS_A(integer),
  TRS_B(integer),
  SPEED_OFF;
output
  SPEED_INST(integer);
constant
  A, B : integer,
  TIME_REF_A : integer,
  TIME_REF_B : integer,
  LPERIOD : integer,
  HPERIOD : integer;
var
  STRATEGY : integer,	% actual strategy
  TRS_A_VALUE :  integer,	% summary of 4 time slots
  TRS_B_VALUE :  integer,	% summary of 8 time slots
  SPEED_VALUE : integer	% longitudinal instantaneous speed value
in
  % Infinite loop
  loop
    % Reset sequence
    STRATEGY := A;
    SPEED_VALUE := 0;
    TRS_A_VALUE := 0;
    TRS_B_VALUE := 0;
    % When a RESET or SPEED_OFF happens quit loop
    do
      loop
        emit SPEED_INST(SPEED_VALUE);
	% Wait for inputs
        await [TRS_A or TRS_B];
        present TRS_A then
	  % Get its value
          TRS_A_VALUE := ?TRS_A;
        end;
        present TRS_B then
          % Get its value
          TRS_B_VALUE := ?TRS_B;
        end;
        % Test TRS_A
        if (STRATEGY = A) then
          % Test period
          if (TRS_A_VALUE > LPERIOD) then
            % Computes instantenous speed value according to A strategy
            SPEED_VALUE := TIME_REF_A / TRS_A_VALUE;
          else
            if (TRS_B_VALUE <> 0) then
              % Change strategy
              STRATEGY := B;
              % Computes instantenous speed value according to B strategy
              SPEED_VALUE := TIME_REF_B / TRS_B_VALUE;
            end;
          end;
        else
          % Test period
          if (TRS_A_VALUE < HPERIOD) then
            SPEED_VALUE := TIME_REF_B / TRS_B_VALUE;
          else
            if (TRS_A_VALUE <> 0) then
              % Change strategy
              STRATEGY := A;
              % Computes instantenous speed value according to A strategy
              SPEED_VALUE := TIME_REF_A / TRS_A_VALUE
            end;
          end;
        end; 
      end;  
    watching [RESET or SPEED_OFF];
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Diagnosis of wrong longitudinal speed sensor:
%
% The following condition causes abnormal state:
%
% If SPEED_OFF and (VER_ACC_MED_FREQ > MAX_ACC_VALUE)
% MAX_OUT_ERR_NUM times for less then MAX_OUT_TIME time then
% the sensor does not function well.
%
% After MAX_ABN_NUM abnormal states the module sends a ERR_ACC
% signal.
%
% CONSTANTS:
%
% Name		MAX_ACC_VALUE
% Data size	Signed 8 bit
% Range		+/-10 m/sec^2
% Resolution	0.078 (m/sec^2)/bit
% Function	Threshold of acceleration for diagnosis of speed sensor
% Threshold	1.8 m/sec^2
% Value		23
%
% Name		MAX_OUT_TIME
% Data size	Unsigned 8 bit
% Range		0 - 4 sec
% Resolution	24 msec/bit
% Function	Diagnosis time of speed sensor
% Threshold	240 msec
% Value		10
%
% Name		MAX_OUT_ERR_NUM
% Data size	Unsigned 8 bit
% Range		0 - 255
% Resolution	1
% Function	Max number of errors
% Threshold	3
% Value		3
%
% Name		MAX_ABN_NUM
% Data size	Unsigned 8 bit
% Range		0 - 255
% Resolution	1
% Function	Max number of abnormalities
% Threshold	3
% Value		3
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_24
% Period		24 msec
% Function		Measuring time spent between two impulses
%
% Name			VER_ACC_FREQ_MED
% Data size		Signed 8 bit
% Range			+/-10 m/sec^2
% Resolution		0.078 (m/sec^2)/bit
% Function		Vertical acceleration medium frequency
%
% Name			SPEED_INST
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Continuous longitudinal speed
%
% Name			SPEED_OFF
% Data size		1 bit
% Range			TRUE - FALSE
% Function		Flag for vehicle movement (moving - stopped) 
%
% OUTPUTS:
%
% Name			ERR_ACC
% Data size		1 bit
% Range			ON - OFF
% Function		Local error signals of wrong speed sensor
%
module LONG_SPEED_DIAG_ACC:
input
  RESET,
  CLOCK_24,
  VER_ACC_FREQ_MED(integer),
  SPEED_INST(integer),
  SPEED_OFF;
output
  ERR_ACC;
constant
  MAX_ACC_VALUE : integer,
  MAX_OUT_TIME : integer,
  MAX_ABN_NUM : integer,
  MAX_OUT_ERR_NUM : integer;
var
  SPEED_VALUE : integer,	% longitudinal instantaneous speed value
  ACC_VALUE : integer,		% vertical acceleration value
  ACC_OUT_TIME : integer,	% time of error state
  ACC_OUT_ERR_NUM : integer,	% number of errors
  ABNORM_NUM : integer          % number of abnormalities
in
  % Infinite loop
  loop
    % Reset sequence
    SPEED_VALUE := 0;
    ACC_VALUE := 0;
    ACC_OUT_TIME := 0;
    ACC_OUT_ERR_NUM := 0;
    ABNORM_NUM := 0;
    % When a RESET happens quit loop
    do
      loop
        % Wait for signals
        await [SPEED_OFF or SPEED_INST or VER_ACC_FREQ_MED or CLOCK_24];
        present SPEED_INST then
          % Get its value
          SPEED_VALUE := ?SPEED_INST                        
        end;
	present SPEED_OFF then
          % Set speed value to 0
          SPEED_VALUE := 0
        end;
        present VER_ACC_FREQ_MED then
 	  % Get its value
          ACC_VALUE := ?VER_ACC_FREQ_MED;
	end;
        present CLOCK_24 then
 	  % Increase timer
          ACC_OUT_TIME := ACC_OUT_TIME + 1;
          % Test timer
          if (ACC_OUT_TIME > MAX_OUT_TIME) then
            % Reset timer
            ACC_OUT_TIME := 0;
            % Reset number of errors
            ACC_OUT_ERR_NUM := 0;
          end;
          % Test the values
          if ((ACC_VALUE > MAX_ACC_VALUE) and (SPEED_VALUE = 0)) then
            % Increase the number of errors
            ACC_OUT_ERR_NUM := ACC_OUT_ERR_NUM +1;
            % Test number of errors
            if (ACC_OUT_ERR_NUM > MAX_OUT_ERR_NUM) then
              % Increase the number of abnormalities
              ABNORM_NUM := ABNORM_NUM +1;
              ACC_OUT_ERR_NUM := 0;
              ACC_OUT_TIME := 0;
              % Test its value
              if (ABNORM_NUM > MAX_ABN_NUM) then
                % Emit error signal
                emit ERR_ACC;
                % Wait an infinite amount of time until RESET
                halt;
              end;
            end;
          end;
        end;
      end;
    watching RESET; 
  end
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Diagnosis of open state of longitudinal speed sensor:
%
% The following condition causes abnormal state:
%
%    (D_TIME(t) < D_TIME_10_MS) and (D_TIME(t+1) > D_TIME_1_S) or
%    (D_TIME(t) < D_TIME_20_MS) and (D_TIME(t+1) > D_TIME_4_S).
%
% CONSTANTS:
%
% Name		D_TIME_10_MS
% Data size	unsigned 24 bit
% Range		0 - 536.8 sec
% Resolution	32 usec/bit
% Function	Threshold for diagnosis of open speed sensor
% Threshold	10 msec
% Value		312
%
% Name		D_TIME_20_MS
% Data size	unsigned 24 bit
% Range		0 - 536.8 sec
% Resolution	32 usec/bit
% Function	Threshold for diagnosis of open speed sensor
% Threshold	20 msec
% Value		625
%
% Name		D_TIME_1_S
% Data size	unsigned 24 bit
% Range		0 - 536.8 sec
% Resolution	32 usec/bit
% Function	Threshold for diagnosis of open speed sensor
% Threshold	1 sec
% Value		31250
%
% Name		D_TIME_4_S
% Data size	unsigned 24 bit
% Range		0 - 536.8 sec
% Resolution	32 usec/bit
% Function	Threshold for diagnosis of open speed sensor
% Threshold	4 sec
% Value		125000
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_32
% Period		32 usec
% Function		Sampling value of period of signal of speed sensor
%
% OUTPUTS:
%
% Name			ERR_OPEN
% Data size		1 bit
% Range			ON - OFF
% Function		Local error signals of open speed sensor
%
module LONG_SPEED_DIAG_OPEN:
input
  RESET,
  CLOCK_32,
  SPEED_SENS;
output
  ERR_OPEN;
constant
  D_TIME_10_MS : integer,
  D_TIME_1_S : integer,
  D_TIME_20_MS : integer,
  D_TIME_4_S : integer;
var
  D_TIME : integer,		% time of a slot
  D_TIME_OLD : integer		% time of a slot
in
  % Infinite loop
  loop
    % Reset sequence
    D_TIME := 0;
    D_TIME_OLD := 0;
    % When a RESET happens quit loop
    do
      loop
	% Wait for signals
	await 
	  case SPEED_SENS do
            if (((D_TIME_OLD < D_TIME_10_MS) and (D_TIME > D_TIME_1_S)) or ((D_TIME_OLD < D_TIME_20_MS) and (D_TIME > D_TIME_4_S))) then
              % Emit open speed sensor
              emit ERR_OPEN;
              % Wait an infinite amount of time, it quits when RESET takes place
              halt;
	    else
              % Memorize the old value
              D_TIME_OLD := D_TIME;
              % Reset timers
              D_TIME := 0;
            end;
	  case CLOCK_32 do
            % Increase timer
            D_TIME := D_TIME + 1;
	end;
      end;
    watching RESET;
  end;
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Diagnosis of parasite signal of longitudinal speed sensor:
%
% The following condition causes abnormal state:
%
% Parasite signal:
%    D_TIME < MIN_TPAR   for more than MAX_MIN_TPAR_NUM times  
%
% If it occurs then it sends an error and stays in halt condition
% until RESET.
%
% CONSTANTS:
%
% Name		MIN_TPAR
% Data size	Unsigned 16 bit
% Range		0 - 32 msec
% Resolution	500 nsec/bit
% Function	Threshold of discovering parasite signal
% Threshold     3 msec
% Value		6000
%
% Name		MAX_MIN_TPAR_NUM
% Data size	Unsigned 8 bit
% Range		0 - 255
% Resolution	1
% Function	Maximum number of parasite signals
% Threshold     3
% Value		3
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_500
% Period		500 nsec
% Function		Sampling value of period of signal of speed sensor
%
% Name			SPEED_SENS
% Data size		1 bit
% Range			0 - 255 Km/h
% Resolution		1.11 Hz/(Km/h)
% Function		Impulses from speed sensor
%
% OUTPUTS:
%
% Name			ERR_PAR
% Data size		1 bit
% Range			ON - OFF
% Function		Local error signals of parasite signal
%
module LONG_SPEED_DIAG_PAR:
input
  RESET,
  CLOCK_500,
  SPEED_SENS;
output
  ERR_PAR;
constant
  MIN_TPAR : integer,
  MAX_MIN_TPAR_NUM : integer;
var
  D_TIME : integer,		% time of a slot
  MIN_TPAR_NUM : integer	% number of parasite signals
in
  % Infinite loop
  loop
    % Reset sequence
    D_TIME := MIN_TPAR;
    MIN_TPAR_NUM := 0;
    % When a RESET happens quit loop
    do
      trap ERROR in
        loop
          % Test parazite signal
          if (D_TIME < MIN_TPAR) then
            MIN_TPAR_NUM := MIN_TPAR_NUM + 1;
            % Test its value
            if (MIN_TPAR_NUM > MAX_MIN_TPAR_NUM) then
              exit ERROR;
            end;
          end;
          % Reset timer
          D_TIME := 0;
          % Infinite loops for measuring time spent between two impulses
          every CLOCK_500 do
            % Increase timer
            D_TIME := D_TIME + 1;
          end;
        each SPEED_SENS;
      end;
      % If the number of parasite signals is greater than the given threshold
      emit ERR_PAR;
      % Wait an infinite amount of time, it quits when RESET takes place
      halt;
    watching RESET;
  end;
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Longitudinal speed value in km/h:
%
% It calculates the longitudinal speed value in km/h unit according to
% the following formula:
%
% LONG_SPEED_KM = LONG_SPEED_FILT / 256.
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			LONG_SPEED_FILT
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Filtered longitudinal speed
%
% OUTPUTS:
%
% Name			LONG_SPEED_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Instantenous speed in Km/h
%
module LONG_SPEED_KM:
input
  RESET,
  LONG_SPEED_FILT(integer);
output
  LONG_SPEED_KM(integer);
var
  VALUE : integer,
  VALUE_KM : integer
in
  % Infinite loop
  loop
    % Reset sequence
    VALUE_KM :=0;
    % When a RESET happens quit loop
    do
      loop
        % Emit value in Km/h
        emit LONG_SPEED_KM(VALUE_KM);
        % Wait for a new value
        await LONG_SPEED_FILT;
        % Get its value
        VALUE := ?LONG_SPEED_FILT;
        % Compute the speed value in Km/h
        VALUE_KM := VALUE / 256;
      end
    watching RESET;
  end
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Strategy of longitudinal speed:
%
% CONSTANTS:
%
% Name		HHHARD
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	210 Km/h
% Value		210
%
% Name		HLHARD
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	205 Km/h
% Value		205
%
% Name		HHMED
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	160 Km/h
% Value		160
%
% Name		HLMED
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	155 Km/h
% Value		155
%
% Name		LHMED
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	7 Km/h
% Value		7
%
% Name		LLMED
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	6 Km/h
% Value		6
%
% Name		LHHARD
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	5 Km/h
% Value		5
%
% Name		LLHARD
% Data size	Unsigned 8 bit
% Range		0 - 255 Km/h
% Resolution	1 Km/h
% Function	Speed threshold
% Threshold	4 Km/h
% Value		4
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			LONG_SPEED_KM
% Data size		Unsigned 8 bit
% Range			0 - 255 Km/h
% Resolution		1 Km/h
% Function		Instantenous speed in Km/h
%
% OUTPUTS:
%
% Name			LONG_SPEED_MOT
% Data size		2 bit
% Range			SOFT - MED - HARD
% Function		Control signal
%
module LONG_SPEED_STRAT:
input
  RESET,
  LONG_SPEED_KM(integer);
output
  LONG_SPEED_MOT(integer);
constant
  HARD, MED, SOFT : integer,
  UP, DOWN : integer,
  HHHARD : integer,
  HLHARD : integer,
  HHMED : integer,
  HLMED : integer,
  LHMED : integer,
  LLMED : integer,
  LHHARD : integer,
  LLHARD : integer;
var
  OLD_SPEED_VALUE : integer,
  SPEED_VALUE : integer,
  LONG_SPEED_MOT_VALUE : integer,
  DIRECTION : integer
in
  % Infinite loop
  loop
    % Reset sequence
    SPEED_VALUE := 0;
    OLD_SPEED_VALUE := 0;
    LONG_SPEED_MOT_VALUE := HARD;
    DIRECTION := UP;
    % When a RESET happens quit loop
    do
      loop
        % Emit condition of shock absorbers
        emit LONG_SPEED_MOT(LONG_SPEED_MOT_VALUE);
        % Memorize old value
        OLD_SPEED_VALUE := SPEED_VALUE;
        % Wait for a new value of speed
        await LONG_SPEED_KM;
        % Get its value
        SPEED_VALUE := ?LONG_SPEED_KM;
        % Set direction
        if (SPEED_VALUE < OLD_SPEED_VALUE) then
          DIRECTION := DOWN;
        else
          if (SPEED_VALUE > OLD_SPEED_VALUE) then
            DIRECTION := UP;
          end;
        end;
        % Calculate the condition of absorbers
        if (DIRECTION = UP) then
          % If speed is increasing
          if (SPEED_VALUE < LHHARD) then
            LONG_SPEED_MOT_VALUE := HARD;
          else
            if (SPEED_VALUE < LHMED) then
              LONG_SPEED_MOT_VALUE := MED;
            else
              if (SPEED_VALUE < HHMED) then
                LONG_SPEED_MOT_VALUE := SOFT;
              else
                if (SPEED_VALUE < HHHARD) then
                  LONG_SPEED_MOT_VALUE := MED;
                else
                  LONG_SPEED_MOT_VALUE := HARD;
                end;
              end;
            end;
          end;
        else
          % If speed is decreasing
          if (SPEED_VALUE > HLHARD) then
            LONG_SPEED_MOT_VALUE := HARD;
          else
            if (SPEED_VALUE > HLMED) then
              LONG_SPEED_MOT_VALUE := MED;
            else
              if (SPEED_VALUE > LLMED) then
                LONG_SPEED_MOT_VALUE := SOFT;
              else
                if (SPEED_VALUE > LLHARD) then
                  LONG_SPEED_MOT_VALUE := MED;
                else
                  LONG_SPEED_MOT_VALUE := HARD;
                end;
              end;
            end;
          end;
        end;
      end;
    watching RESET;
  end;
end;  
.
module mca200_sim : 
  input
    RESET,
    CLOCK_500,
    CLOCK_24,
    CLOCK_32,
    CLOCK_16,
    ANG_INPUT(integer),
    VELSTER(integer),
    VELINST(integer),
    ACC_SENS(integer),
    VBAT(integer),
    MOT_POS_A1(boolean),
    MOT_POS_B1(boolean),
    MOT_POS_A2(boolean),
    MOT_POS_B2(boolean),
    MOT_POS_A3(boolean),
    MOT_POS_B3(boolean),
    MOT_POS_A4(boolean),
    MOT_POS_B4(boolean);
  output
    MOT_CHANNEL_P1(boolean),
    MOT_CHANNEL_N1(boolean),
    MOT_CHANNEL_P2(boolean),
    MOT_CHANNEL_N2(boolean),
    MOT_CHANNEL_P3(boolean),
    MOT_CHANNEL_N3(boolean),
    MOT_CHANNEL_P4(boolean),
    MOT_CHANNEL_N4(boolean);
  signal
    STEER_ANG_MOT_REAR(integer),
    LONG_SPEED_KM(integer),
    VER_ACC_FREQ_MED(integer),
    STEER_ANG_DAMAGE(integer),
    STEER_SPEED_ERR,
    STEER1_SENS(boolean),
    LONG_DECC_MOT_FRONT(integer),
    BAT_ERR,
    STEER2_SENS(boolean),
    LONG_SPEED_MOT(integer),
    VER_ACC_MED_MOT_REAR(integer),
    LONG_SPEED_ERR,
    VER_ACC_ERR,
    VER_ACC_LOW_MOT_FRONT(integer),
    BAT_MOT_RES,
    STEER_SPEED_NO_SOFT,
    VER_ACC_MED_MOT_FRONT(integer),
    LONG_ACC_MOT_FRONT(integer),
    STEER_SPEED_MOT_REAR(integer),
    LONG_ACC_MOT_REAR(integer),
    BAT_MOT_HARD,
    STEER_ANG_MOT_FRONT(integer),
    VER_ACC_LOW_MOT_REAR(integer),
    LONG_DECC_MOT_REAR(integer),
    STEER_SPEED_MOT_FRONT(integer),
    LONG_ACC_DER_MOT_REAR(integer),
    SPEED_SENS,
    STEER_ANG_ERR,
    LONG_SPEED_FILT(integer),
    LONG_ACC_DER_MOT_FRONT(integer),
    STEER_SENS(boolean),
    ignored
  in
  run SPEED_SENS [
    signal RESET / RESET;
    signal CLOCK_32 / CLOCK_32;
    signal VELINST / VELINST;
    signal SPEED_SENS / SPEED_SENS  ]
  ||
  run STEER_WHEEL [
    signal RESET / RESET;
    signal CLOCK_16 / CLOCK_16;
    signal ANG_INPUT / ANG_INPUT;
    signal VELSTER / VELSTER;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal STEER_SENS / STEER_SENS  ]
  ||
  run BAT_DIAG [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal VBAT / VBAT;
    signal BAT_MOT_RES / BAT_MOT_RES;
    signal BAT_ERR / BAT_ERR;
    signal BAT_MOT_HARD / BAT_MOT_HARD  ]
  ||
  run long_speed [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal CLOCK_24 / CLOCK_24;
    signal CLOCK_32 / CLOCK_32;
    signal SPEED_SENS / SPEED_SENS;
    signal VER_ACC_FREQ_MED / VER_ACC_FREQ_MED;
    signal LONG_SPEED_KM / LONG_SPEED_KM;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal LONG_SPEED_MOT / LONG_SPEED_MOT;
    signal LONG_SPEED_ERR / LONG_SPEED_ERR  ]
  ||
  run long_acc [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal LONG_SPEED_KM / LONG_SPEED_KM;
    signal LONG_ACC_MOT_FRONT / LONG_ACC_MOT_FRONT;
    signal LONG_ACC_MOT_REAR / LONG_ACC_MOT_REAR;
    signal LONG_DECC_MOT_FRONT / LONG_DECC_MOT_FRONT;
    signal LONG_DECC_MOT_REAR / LONG_DECC_MOT_REAR;
    signal LONG_ACC_DER_MOT_FRONT / LONG_ACC_DER_MOT_FRONT;
    signal LONG_ACC_DER_MOT_REAR / LONG_ACC_DER_MOT_REAR  ]
  ||
  run ver_acc [
    signal RESET / RESET;
    signal ACC_SENS / ACC_SENS;
    signal LONG_SPEED_KM / LONG_SPEED_KM;
    signal VER_ACC_LOW_MOT_FRONT / VER_ACC_LOW_MOT_FRONT;
    signal VER_ACC_LOW_MOT_REAR / VER_ACC_LOW_MOT_REAR;
    signal VER_ACC_MED_MOT_FRONT / VER_ACC_MED_MOT_FRONT;
    signal VER_ACC_MED_MOT_REAR / VER_ACC_MED_MOT_REAR;
    signal VER_ACC_FREQ_MED / VER_ACC_FREQ_MED;
    signal VER_ACC_ERR / VER_ACC_ERR  ]
  ||
  run steer_ang [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal STEER_SENS / STEER_SENS;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal LONG_SPEED_KM / LONG_SPEED_KM;
    signal STEER_ANG_MOT_FRONT / STEER_ANG_MOT_FRONT;
    signal STEER_ANG_MOT_REAR / STEER_ANG_MOT_REAR;
    signal STEER_ANG_DAMAGE / STEER_ANG_DAMAGE;
    signal STEER_ANG_ERR / ANG_ERR  ]
  ||
  run steer_speed [
    signal RESET / RESET;
    signal CLOCK_16 / CLOCK_16;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal LONG_SPEED_KM / LONG_SPEED_KM;
    signal STEER_SPEED_NO_SOFT / STEER_NO_SOFT;
    signal STEER_SPEED_ERR / STEER_SPEED_ERR;
    signal STEER_SPEED_MOT_FRONT / STEER_SPEED_MOT_FRONT;
    signal STEER_SPEED_MOT_REAR / STEER_SPEED_MOT_REAR  ]
  ||
  run mot_ctrl [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal LONG_SPEED_MOT / LONG_SPEED_MOT;
    signal LONG_ACC_MOT_FRONT / LONG_ACC_MOT_FRONT;
    signal LONG_DECC_MOT_FRONT / LONG_DECC_MOT_FRONT;
    signal LONG_ACC_DER_MOT_FRONT / LONG_ACC_DER_MOT_FRONT;
    signal VER_ACC_LOW_MOT_FRONT / VER_ACC_LOW_MOT_FRONT;
    signal VER_ACC_MED_MOT_FRONT / VER_ACC_MED_MOT_FRONT;
    signal STEER_ANG_MOT_FRONT / STEER_ANG_MOT_FRONT;
    signal STEER_SPEED_MOT_FRONT / STEER_SPEED_MOT_FRONT;
    signal LONG_ACC_MOT_REAR / LONG_ACC_MOT_REAR;
    signal LONG_DECC_MOT_REAR / LONG_DECC_MOT_REAR;
    signal LONG_ACC_DER_MOT_REAR / LONG_ACC_DER_MOT_REAR;
    signal VER_ACC_LOW_MOT_REAR / VER_ACC_LOW_MOT_REAR;
    signal VER_ACC_MED_MOT_REAR / VER_ACC_MED_MOT_REAR;
    signal STEER_ANG_MOT_REAR / STEER_ANG_MOT_REAR;
    signal STEER_SPEED_MOT_REAR / STEER_SPEED_MOT_REAR;
    signal LONG_SPEED_ERR / LONG_SPEED_ERR;
    signal VER_ACC_ERR / VER_ACC_ERR;
    signal STEER_ANG_ERR / STEER_ANG_ERR;
    signal STEER_SPEED_ERR / STEER_SPEED_ERR;
    signal BAT_ERR / BAT_ERR;
    signal BAT_MOT_HARD / BAT_MOT_HARD;
    signal BAT_MOT_RES / BAT_MOT_RES;
    signal STEER_ANG_DAMAGE / STEER_ANG_DAMAGE;
    signal STEER_SPEED_NO_SOFT / STEER_SPEED_NO_SOFT;
    signal VBAT / VBAT;
    signal MOT_POS_A1 / MOT_POS_A1;
    signal MOT_POS_B1 / MOT_POS_B1;
    signal MOT_POS_A2 / MOT_POS_A2;
    signal MOT_POS_B2 / MOT_POS_B2;
    signal MOT_POS_A3 / MOT_POS_A3;
    signal MOT_POS_B3 / MOT_POS_B3;
    signal MOT_POS_A4 / MOT_POS_A4;
    signal MOT_POS_B4 / MOT_POS_B4;
    signal MOT_CHANNEL_P1 / MOT_CHANNEL_P1;
    signal MOT_CHANNEL_N1 / MOT_CHANNEL_N1;
    signal MOT_CHANNEL_P2 / MOT_CHANNEL_P2;
    signal MOT_CHANNEL_N2 / MOT_CHANNEL_N2;
    signal MOT_CHANNEL_P3 / MOT_CHANNEL_P3;
    signal MOT_CHANNEL_N3 / MOT_CHANNEL_N3;
    signal MOT_CHANNEL_P4 / MOT_CHANNEL_P4;
    signal MOT_CHANNEL_N4 / MOT_CHANNEL_N4  ]

  end signal
end module % mca200_sim


module long_speed : 
  input
    RESET,
    CLOCK_500,
    CLOCK_24,
    CLOCK_32,
    SPEED_SENS,
    VER_ACC_FREQ_MED(integer);
  output
    LONG_SPEED_KM(integer),
    LONG_SPEED_FILT(integer),
    LONG_SPEED_MOT(integer),
    LONG_SPEED_ERR;
  constant K1 : integer;
  signal
    SPEED_OFF,
    SPEED_INST(integer),
    ignored
  in
  run long_speed_cal [
    signal RESET / RESET;
    signal CLOCK_32 / CLOCK_32;
    signal SPEED_SENS / SPEED_SENS;
    signal SPEED_INST / SPEED_INST;
    signal SPEED_OFF / SPEED_OFF  ]
  ||
  run long_speed_diag [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal CLOCK_24 / CLOCK_24;
    signal CLOCK_32 / CLOCK_32;
    signal SPEED_SENS / SPEED_SENS;
    signal SPEED_INST / SPEED_INST;
    signal VER_ACC_FREQ_MED / VER_ACC_FREQ_MED;
    signal SPEED_OFF / SPEED_OFF;
    signal LONG_SPEED_ERR / LONG_SPEED_ERR  ]
  ||
  run FILTER [
    signal RESET / RESET;
    signal SPEED_INST / VALUE;
    signal LONG_SPEED_FILT / FILT_VALUE;
    constant K1 / K  ]
  ||
  run LONG_SPEED_KM [
    signal RESET / RESET;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal LONG_SPEED_KM / LONG_SPEED_KM  ]
  ||
  run LONG_SPEED_STRAT [
    signal RESET / RESET;
    signal LONG_SPEED_KM / LONG_SPEED_KM;
    signal LONG_SPEED_MOT / LONG_SPEED_MOT  ]

  end signal
end module % long_speed


module long_speed_cal : 
  input
    RESET,
    CLOCK_32,
    SPEED_SENS;
  output
    SPEED_INST(integer),
    SPEED_OFF;
  signal
    TRS_B(integer),
    TRS_A(integer),
    ignored
  in
  run LONG_SPEED_CAL_TRS [
    signal RESET / RESET;
    signal CLOCK_32 / CLOCK_32;
    signal SPEED_SENS / SPEED_SENS;
    signal TRS_A / TRS_A;
    signal TRS_B / TRS_B;
    signal SPEED_OFF / SPEED_OFF  ]
  ||
  run LONG_SPEED_CAL_VAL [
    signal RESET / RESET;
    signal TRS_A / TRS_A;
    signal TRS_B / TRS_B;
    signal SPEED_OFF / SPEED_OFF;
    signal SPEED_INST / SPEED_INST  ]

  end signal
end module % long_speed_cal


module long_speed_diag : 
  input
    RESET,
    CLOCK_500,
    CLOCK_24,
    CLOCK_32,
    SPEED_SENS,
    VER_ACC_FREQ_MED(integer),
    SPEED_INST(integer),
    SPEED_OFF;
  output
    LONG_SPEED_ERR;
  signal
    ERR_OPEN,
    ERR_ACC,
    ERR_PAR,
    ignored
  in
  run LONG_SPEED_DIAG_ACC [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal VER_ACC_FREQ_MED / VER_ACC_FREQ_MED;
    signal SPEED_INST / SPEED_INST;
    signal SPEED_OFF / SPEED_OFF;
    signal ERR_ACC / ERR_ACC  ]
  ||
  run LONG_SPEED_DIAG_PAR [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal SPEED_SENS / SPEED_SENS;
    signal ERR_PAR / ERR_PAR  ]
  ||
  run LONG_SPEED_DIAG_OPEN [
    signal RESET / RESET;
    signal CLOCK_32 / CLOCK_32;
    signal SPEED_SENS / SPEED_SENS;
    signal ERR_OPEN / ERR_OPEN  ]
  ||
  run ARB_3 [
    signal ERR_ACC / ERR1;
    signal ERR_OPEN / ERR2;
    signal ERR_PAR / ERR3;
    signal LONG_SPEED_ERR / ERR  ]

  end signal
end module % long_speed_diag


module long_acc : 
  input
    RESET,
    CLOCK_24,
    LONG_SPEED_FILT(integer),
    LONG_SPEED_KM(integer);
  output
    LONG_ACC_MOT_FRONT(integer),
    LONG_ACC_MOT_REAR(integer),
    LONG_DECC_MOT_FRONT(integer),
    LONG_DECC_MOT_REAR(integer),
    LONG_ACC_DER_MOT_FRONT(integer),
    LONG_ACC_DER_MOT_REAR(integer);
  constant DDEHF_4 : integer;
  constant DDEHF_5 : integer;
  constant ACHR_20 : integer;
  constant DDEHF_6 : integer;
  constant ACHR_21 : integer;
  constant DDEHF_7 : integer;
  constant ACHR_22 : integer;
  constant DDEHF_8 : integer;
  constant ACHR_23 : integer;
  constant DDEHF_9 : integer;
  constant ACHR_24 : integer;
  constant ACHR_25 : integer;
  constant ACMR_20 : integer;
  constant ACMR_21 : integer;
  constant ACMR_22 : integer;
  constant ACMR_23 : integer;
  constant ACMR_24 : integer;
  constant ACMR_25 : integer;
  constant DDEHF_10 : integer;
  constant DEHR_10 : integer;
  constant DDEHF_11 : integer;
  constant DEHR_11 : integer;
  constant DDEHF_12 : integer;
  constant DEHR_12 : integer;
  constant DDELFMD : integer;
  constant DDEHF_13 : integer;
  constant DEHR_13 : integer;
  constant DDEHF_14 : integer;
  constant DEHR_14 : integer;
  constant DDEHF_15 : integer;
  constant DDEMF_10 : integer;
  constant DEHR_15 : integer;
  constant DEMR_10 : integer;
  constant DDEHF_16 : integer;
  constant DDEMF_11 : integer;
  constant DEHR_16 : integer;
  constant DEMR_11 : integer;
  constant ACMR_1 : integer;
  constant Kd : integer;
  constant DDEHF_17 : integer;
  constant DDEMF_12 : integer;
  constant DEHR_17 : integer;
  constant DEMR_12 : integer;
  constant ACMR_2 : integer;
  constant DDEHF_18 : integer;
  constant DDEMF_13 : integer;
  constant DEHR_18 : integer;
  constant DEMR_13 : integer;
  constant ACMR_3 : integer;
  constant DDEHF_19 : integer;
  constant DDEMF_14 : integer;
  constant DEHR_19 : integer;
  constant DEMR_14 : integer;
  constant ACMR_4 : integer;
  constant DDEMF_15 : integer;
  constant DEMR_15 : integer;
  constant ACMR_5 : integer;
  constant DDEMF_16 : integer;
  constant DEMR_16 : integer;
  constant ACMR_6 : integer;
  constant DDEMF_17 : integer;
  constant DEMR_17 : integer;
  constant ACMR_7 : integer;
  constant DDEMF_18 : integer;
  constant DEMR_18 : integer;
  constant DELRHA : integer;
  constant ACMR_8 : integer;
  constant DDEMF_19 : integer;
  constant DEMR_19 : integer;
  constant DEHF_1 : integer;
  constant ACMR_9 : integer;
  constant DEHF_2 : integer;
  constant DELRHD : integer;
  constant DEHF_3 : integer;
  constant DEHF_4 : integer;
  constant DEHF_5 : integer;
  constant DEHF_6 : integer;
  constant DEHF_7 : integer;
  constant DEHF_8 : integer;
  constant DEHF_9 : integer;
  constant DDEHF_20 : integer;
  constant DEHR_20 : integer;
  constant DDEHF_21 : integer;
  constant DEHR_21 : integer;
  constant DDEHF_22 : integer;
  constant DEHR_22 : integer;
  constant DDEHF_23 : integer;
  constant DEHR_23 : integer;
  constant DDEHF_24 : integer;
  constant DEHR_24 : integer;
  constant DDEHF_25 : integer;
  constant DDEMF_20 : integer;
  constant DEHR_25 : integer;
  constant DEMR_20 : integer;
  constant DELFMA : integer;
  constant DDEMF_21 : integer;
  constant DEMR_21 : integer;
  constant DDEMF_22 : integer;
  constant DEMR_22 : integer;
  constant DDEMF_23 : integer;
  constant DEMR_23 : integer;
  constant DELFMD : integer;
  constant DDEMF_24 : integer;
  constant DEMR_24 : integer;
  constant DDEMF_25 : integer;
  constant DEMR_25 : integer;
  constant DDELFHD : integer;
  constant ACHR_1 : integer;
  constant ACHR_2 : integer;
  constant ACHR_3 : integer;
  constant ACHR_4 : integer;
  constant ACHR_5 : integer;
  constant ACHR_6 : integer;
  constant ACHR_7 : integer;
  constant ACHR_8 : integer;
  constant ACHR_9 : integer;
  constant ACHF_10 : integer;
  constant ACHF_11 : integer;
  constant ACHF_12 : integer;
  constant ACHF_13 : integer;
  constant ACHF_14 : integer;
  constant ACHF_15 : integer;
  constant ACMF_10 : integer;
  constant DDEMR_1 : integer;
  constant ACHF_16 : integer;
  constant ACMF_11 : integer;
  constant DDEMR_2 : integer;
  constant ACHF_17 : integer;
  constant ACMF_12 : integer;
  constant DDEMR_3 : integer;
  constant ACHF_18 : integer;
  constant ACMF_13 : integer;
  constant DDEMR_4 : integer;
  constant ACHF_19 : integer;
  constant ACMF_14 : integer;
  constant DDEMR_5 : integer;
  constant ACMF_15 : integer;
  constant DDEMR_6 : integer;
  constant ACMF_16 : integer;
  constant DDEMR_7 : integer;
  constant ACMF_17 : integer;
  constant DDEMR_8 : integer;
  constant ACMF_18 : integer;
  constant DDEMR_9 : integer;
  constant ACMF_19 : integer;
  constant ACMF_1 : integer;
  constant ACMF_2 : integer;
  constant ACMF_3 : integer;
  constant ACMF_4 : integer;
  constant ACMF_5 : integer;
  constant ACMF_6 : integer;
  constant ACMF_7 : integer;
  constant DELFHA : integer;
  constant ACMF_8 : integer;
  constant ACMF_9 : integer;
  constant DELFHD : integer;
  constant ACHF_20 : integer;
  constant ACHF_21 : integer;
  constant DDEHR_10 : integer;
  constant ACHF_22 : integer;
  constant DDEHR_11 : integer;
  constant ACHF_23 : integer;
  constant DDEHR_12 : integer;
  constant ACHF_24 : integer;
  constant DDEHR_13 : integer;
  constant ACHF_25 : integer;
  constant ACMF_20 : integer;
  constant DDEHR_14 : integer;
  constant ACMF_21 : integer;
  constant DDEHR_15 : integer;
  constant DDEMR_10 : integer;
  constant ACMF_22 : integer;
  constant DDEHR_16 : integer;
  constant DDEMR_11 : integer;
  constant ACMF_23 : integer;
  constant DDEHR_17 : integer;
  constant DDEMR_12 : integer;
  constant ACMF_24 : integer;
  constant DDEHR_18 : integer;
  constant DDEMR_13 : integer;
  constant ACMF_25 : integer;
  constant DDEHR_19 : integer;
  constant DDEMR_14 : integer;
  constant DEMR_1 : integer;
  constant DDEMR_15 : integer;
  constant DEMR_2 : integer;
  constant DDEMR_16 : integer;
  constant DEMR_3 : integer;
  constant DDEMR_17 : integer;
  constant DEMR_4 : integer;
  constant DDEMR_18 : integer;
  constant DEMR_5 : integer;
  constant DDEMR_19 : integer;
  constant DEMR_6 : integer;
  constant DEMR_7 : integer;
  constant DEMR_8 : integer;
  constant DEHF_10 : integer;
  constant DEMR_9 : integer;
  constant DEHF_11 : integer;
  constant DDEHR_1 : integer;
  constant DEHF_12 : integer;
  constant DDEHR_2 : integer;
  constant DEHF_13 : integer;
  constant DDEHR_3 : integer;
  constant DEHF_14 : integer;
  constant DDEHR_4 : integer;
  constant DEHF_15 : integer;
  constant DEMF_10 : integer;
  constant DDEHR_5 : integer;
  constant DEHF_16 : integer;
  constant DEMF_11 : integer;
  constant DDEHR_6 : integer;
  constant DEHF_17 : integer;
  constant DEMF_12 : integer;
  constant DDEHR_7 : integer;
  constant DEHF_18 : integer;
  constant DEMF_13 : integer;
  constant DDEHR_8 : integer;
  constant DEHF_19 : integer;
  constant DEMF_14 : integer;
  constant DDEHR_9 : integer;
  constant DEMF_15 : integer;
  constant DEMF_16 : integer;
  constant ACHF_1 : integer;
  constant DEMF_17 : integer;
  constant ACHF_2 : integer;
  constant DEMF_18 : integer;
  constant ACHF_3 : integer;
  constant DEMF_19 : integer;
  constant ACHF_4 : integer;
  constant DDEHR_20 : integer;
  constant ACHF_5 : integer;
  constant DDEHR_21 : integer;
  constant ACHF_6 : integer;
  constant DDEHR_22 : integer;
  constant ACHF_7 : integer;
  constant DDEHR_23 : integer;
  constant ACHF_8 : integer;
  constant DDEHR_24 : integer;
  constant ACHF_9 : integer;
  constant DDEHR_25 : integer;
  constant DDEMR_20 : integer;
  constant DDEMR_21 : integer;
  constant DDEMR_22 : integer;
  constant DDEMR_23 : integer;
  constant DDEMR_24 : integer;
  constant DDEMR_25 : integer;
  constant DDEMF_1 : integer;
  constant DDEMF_2 : integer;
  constant DDELRMD : integer;
  constant DDEMF_3 : integer;
  constant DDEMF_4 : integer;
  constant DDEMF_5 : integer;
  constant DDEMF_6 : integer;
  constant DDEMF_7 : integer;
  constant DEHF_20 : integer;
  constant DDEMF_8 : integer;
  constant DEHF_21 : integer;
  constant DDEMF_9 : integer;
  constant DEHF_22 : integer;
  constant DEHF_23 : integer;
  constant DEHF_24 : integer;
  constant DEHF_25 : integer;
  constant DEMF_20 : integer;
  constant DEMF_21 : integer;
  constant DEHR_1 : integer;
  constant DEMF_22 : integer;
  constant DEHR_2 : integer;
  constant DEMF_23 : integer;
  constant DEHR_3 : integer;
  constant DEMF_24 : integer;
  constant DEHR_4 : integer;
  constant DEMF_25 : integer;
  constant DEHR_5 : integer;
  constant DEHR_6 : integer;
  constant ACHR_10 : integer;
  constant DEHR_7 : integer;
  constant ACHR_11 : integer;
  constant DEHR_8 : integer;
  constant ACHR_12 : integer;
  constant DEHR_9 : integer;
  constant ACHR_13 : integer;
  constant ACHR_14 : integer;
  constant ACHR_15 : integer;
  constant ACMR_10 : integer;
  constant ACHR_16 : integer;
  constant ACMR_11 : integer;
  constant ACHR_17 : integer;
  constant ACMR_12 : integer;
  constant ACHR_18 : integer;
  constant ACMR_13 : integer;
  constant ACHR_19 : integer;
  constant ACMR_14 : integer;
  constant ACMR_15 : integer;
  constant ACMR_16 : integer;
  constant ACMR_17 : integer;
  constant ACMR_18 : integer;
  constant ACMR_19 : integer;
  constant DELRMA : integer;
  constant DEMF_1 : integer;
  constant DEMF_2 : integer;
  constant DELRMD : integer;
  constant DEMF_3 : integer;
  constant DEMF_4 : integer;
  constant DEMF_5 : integer;
  constant DEMF_6 : integer;
  constant DEMF_7 : integer;
  constant DEMF_8 : integer;
  constant DEMF_9 : integer;
  constant DDEHF_1 : integer;
  constant DDEHF_2 : integer;
  constant DDELRHD : integer;
  constant DDEHF_3 : integer;
  signal
    ACC_DER(integer),
    ACC(integer),
    ACC_FILT(integer),
    ignored
  in
  run LONG_ACC_CAL [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal ACC / ACC  ]
  ||
  run FILTER [
    signal RESET / RESET;
    signal ACC / VALUE;
    signal ACC_FILT / FILT_VALUE;
    constant Kd / K  ]
  ||
  run LONG_ACC_DER [
    signal RESET / RESET;
    signal ACC_FILT / ACC_FILT;
    signal ACC_DER / ACC_DER  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ACC_FILT / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal LONG_ACC_MOT_FRONT / CONTROL;
    constant ACMF_1 / V1_1;
    constant ACMF_2 / V1_2;
    constant ACMF_3 / V1_3;
    constant ACMF_4 / V1_4;
    constant ACMF_5 / V1_5;
    constant ACMF_6 / V1_6;
    constant ACMF_7 / V1_7;
    constant ACMF_8 / V1_8;
    constant ACMF_9 / V1_9;
    constant ACMF_10 / V1_10;
    constant ACMF_11 / V1_11;
    constant ACMF_12 / V1_12;
    constant ACMF_13 / V1_13;
    constant ACMF_14 / V1_14;
    constant ACMF_15 / V1_15;
    constant ACMF_16 / V1_16;
    constant ACMF_17 / V1_17;
    constant ACMF_18 / V1_18;
    constant ACMF_19 / V1_19;
    constant ACMF_20 / V1_20;
    constant ACMF_21 / V1_21;
    constant ACMF_22 / V1_22;
    constant ACMF_23 / V1_23;
    constant ACMF_24 / V1_24;
    constant ACMF_25 / V1_25;
    constant ACHF_1 / V2_1;
    constant ACHF_2 / V2_2;
    constant ACHF_3 / V2_3;
    constant ACHF_4 / V2_4;
    constant ACHF_5 / V2_5;
    constant ACHF_6 / V2_6;
    constant ACHF_7 / V2_7;
    constant ACHF_8 / V2_8;
    constant ACHF_9 / V2_9;
    constant ACHF_10 / V2_10;
    constant ACHF_11 / V2_11;
    constant ACHF_12 / V2_12;
    constant ACHF_13 / V2_13;
    constant ACHF_14 / V2_14;
    constant ACHF_15 / V2_15;
    constant ACHF_16 / V2_16;
    constant ACHF_17 / V2_17;
    constant ACHF_18 / V2_18;
    constant ACHF_19 / V2_19;
    constant ACHF_20 / V2_20;
    constant ACHF_21 / V2_21;
    constant ACHF_22 / V2_22;
    constant ACHF_23 / V2_23;
    constant ACHF_24 / V2_24;
    constant ACHF_25 / V2_25;
    constant DELFHA / T1;
    constant DELFMA / T2  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ACC_FILT / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal LONG_ACC_MOT_REAR / CONTROL;
    constant ACMR_1 / V1_1;
    constant ACMR_2 / V1_2;
    constant ACMR_3 / V1_3;
    constant ACMR_4 / V1_4;
    constant ACMR_5 / V1_5;
    constant ACMR_6 / V1_6;
    constant ACMR_7 / V1_7;
    constant ACMR_8 / V1_8;
    constant ACMR_9 / V1_9;
    constant ACMR_10 / V1_10;
    constant ACMR_11 / V1_11;
    constant ACMR_12 / V1_12;
    constant ACMR_13 / V1_13;
    constant ACMR_14 / V1_14;
    constant ACMR_15 / V1_15;
    constant ACMR_16 / V1_16;
    constant ACMR_17 / V1_17;
    constant ACMR_18 / V1_18;
    constant ACMR_19 / V1_19;
    constant ACMR_20 / V1_20;
    constant ACMR_21 / V1_21;
    constant ACMR_22 / V1_22;
    constant ACMR_23 / V1_23;
    constant ACMR_24 / V1_24;
    constant ACMR_25 / V1_25;
    constant ACHR_1 / V2_1;
    constant ACHR_2 / V2_2;
    constant ACHR_3 / V2_3;
    constant ACHR_4 / V2_4;
    constant ACHR_5 / V2_5;
    constant ACHR_6 / V2_6;
    constant ACHR_7 / V2_7;
    constant ACHR_8 / V2_8;
    constant ACHR_9 / V2_9;
    constant ACHR_10 / V2_10;
    constant ACHR_11 / V2_11;
    constant ACHR_12 / V2_12;
    constant ACHR_13 / V2_13;
    constant ACHR_14 / V2_14;
    constant ACHR_15 / V2_15;
    constant ACHR_16 / V2_16;
    constant ACHR_17 / V2_17;
    constant ACHR_18 / V2_18;
    constant ACHR_19 / V2_19;
    constant ACHR_20 / V2_20;
    constant ACHR_21 / V2_21;
    constant ACHR_22 / V2_22;
    constant ACHR_23 / V2_23;
    constant ACHR_24 / V2_24;
    constant ACHR_25 / V2_25;
    constant DELRHA / T1;
    constant DELRMA / T2  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ACC_FILT / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal LONG_DECC_MOT_FRONT / CONTROL;
    constant DEMF_1 / V1_1;
    constant DEMF_2 / V1_2;
    constant DEMF_3 / V1_3;
    constant DEMF_4 / V1_4;
    constant DEMF_5 / V1_5;
    constant DEMF_6 / V1_6;
    constant DEMF_7 / V1_7;
    constant DEMF_8 / V1_8;
    constant DEMF_9 / V1_9;
    constant DEMF_10 / V1_10;
    constant DEMF_11 / V1_11;
    constant DEMF_12 / V1_12;
    constant DEMF_13 / V1_13;
    constant DEMF_14 / V1_14;
    constant DEMF_15 / V1_15;
    constant DEMF_16 / V1_16;
    constant DEMF_17 / V1_17;
    constant DEMF_18 / V1_18;
    constant DEMF_19 / V1_19;
    constant DEMF_20 / V1_20;
    constant DEMF_21 / V1_21;
    constant DEMF_22 / V1_22;
    constant DEMF_23 / V1_23;
    constant DEMF_24 / V1_24;
    constant DEMF_25 / V1_25;
    constant DEHF_1 / V2_1;
    constant DEHF_2 / V2_2;
    constant DEHF_3 / V2_3;
    constant DEHF_4 / V2_4;
    constant DEHF_5 / V2_5;
    constant DEHF_6 / V2_6;
    constant DEHF_7 / V2_7;
    constant DEHF_8 / V2_8;
    constant DEHF_9 / V2_9;
    constant DEHF_10 / V2_10;
    constant DEHF_11 / V2_11;
    constant DEHF_12 / V2_12;
    constant DEHF_13 / V2_13;
    constant DEHF_14 / V2_14;
    constant DEHF_15 / V2_15;
    constant DEHF_16 / V2_16;
    constant DEHF_17 / V2_17;
    constant DEHF_18 / V2_18;
    constant DEHF_19 / V2_19;
    constant DEHF_20 / V2_20;
    constant DEHF_21 / V2_21;
    constant DEHF_22 / V2_22;
    constant DEHF_23 / V2_23;
    constant DEHF_24 / V2_24;
    constant DEHF_25 / V2_25;
    constant DELFHD / T1;
    constant DELFMD / T2  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ACC_FILT / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal LONG_DECC_MOT_REAR / CONTROL;
    constant DEMR_1 / V1_1;
    constant DEMR_2 / V1_2;
    constant DEMR_3 / V1_3;
    constant DEMR_4 / V1_4;
    constant DEMR_5 / V1_5;
    constant DEMR_6 / V1_6;
    constant DEMR_7 / V1_7;
    constant DEMR_8 / V1_8;
    constant DEMR_9 / V1_9;
    constant DEMR_10 / V1_10;
    constant DEMR_11 / V1_11;
    constant DEMR_12 / V1_12;
    constant DEMR_13 / V1_13;
    constant DEMR_14 / V1_14;
    constant DEMR_15 / V1_15;
    constant DEMR_16 / V1_16;
    constant DEMR_17 / V1_17;
    constant DEMR_18 / V1_18;
    constant DEMR_19 / V1_19;
    constant DEMR_20 / V1_20;
    constant DEMR_21 / V1_21;
    constant DEMR_22 / V1_22;
    constant DEMR_23 / V1_23;
    constant DEMR_24 / V1_24;
    constant DEMR_25 / V1_25;
    constant DEHR_1 / V2_1;
    constant DEHR_2 / V2_2;
    constant DEHR_3 / V2_3;
    constant DEHR_4 / V2_4;
    constant DEHR_5 / V2_5;
    constant DEHR_6 / V2_6;
    constant DEHR_7 / V2_7;
    constant DEHR_8 / V2_8;
    constant DEHR_9 / V2_9;
    constant DEHR_10 / V2_10;
    constant DEHR_11 / V2_11;
    constant DEHR_12 / V2_12;
    constant DEHR_13 / V2_13;
    constant DEHR_14 / V2_14;
    constant DEHR_15 / V2_15;
    constant DEHR_16 / V2_16;
    constant DEHR_17 / V2_17;
    constant DEHR_18 / V2_18;
    constant DEHR_19 / V2_19;
    constant DEHR_20 / V2_20;
    constant DEHR_21 / V2_21;
    constant DEHR_22 / V2_22;
    constant DEHR_23 / V2_23;
    constant DEHR_24 / V2_24;
    constant DEHR_25 / V2_25;
    constant DELRHD / T1;
    constant DELRMD / T2  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ACC_DER / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal LONG_ACC_DER_MOT_FRONT / CONTROL;
    constant DDEMF_1 / V1_1;
    constant DDEMF_2 / V1_2;
    constant DDEMF_3 / V1_3;
    constant DDEMF_4 / V1_4;
    constant DDEMF_5 / V1_5;
    constant DDEMF_6 / V1_6;
    constant DDEMF_7 / V1_7;
    constant DDEMF_8 / V1_8;
    constant DDEMF_9 / V1_9;
    constant DDEMF_10 / V1_10;
    constant DDEMF_11 / V1_11;
    constant DDEMF_12 / V1_12;
    constant DDEMF_13 / V1_13;
    constant DDEMF_14 / V1_14;
    constant DDEMF_15 / V1_15;
    constant DDEMF_16 / V1_16;
    constant DDEMF_17 / V1_17;
    constant DDEMF_18 / V1_18;
    constant DDEMF_19 / V1_19;
    constant DDEMF_20 / V1_20;
    constant DDEMF_21 / V1_21;
    constant DDEMF_22 / V1_22;
    constant DDEMF_23 / V1_23;
    constant DDEMF_24 / V1_24;
    constant DDEMF_25 / V1_25;
    constant DDEHF_1 / V2_1;
    constant DDEHF_2 / V2_2;
    constant DDEHF_3 / V2_3;
    constant DDEHF_4 / V2_4;
    constant DDEHF_5 / V2_5;
    constant DDEHF_6 / V2_6;
    constant DDEHF_7 / V2_7;
    constant DDEHF_8 / V2_8;
    constant DDEHF_9 / V2_9;
    constant DDEHF_10 / V2_10;
    constant DDEHF_11 / V2_11;
    constant DDEHF_12 / V2_12;
    constant DDEHF_13 / V2_13;
    constant DDEHF_14 / V2_14;
    constant DDEHF_15 / V2_15;
    constant DDEHF_16 / V2_16;
    constant DDEHF_17 / V2_17;
    constant DDEHF_18 / V2_18;
    constant DDEHF_19 / V2_19;
    constant DDEHF_20 / V2_20;
    constant DDEHF_21 / V2_21;
    constant DDEHF_22 / V2_22;
    constant DDEHF_23 / V2_23;
    constant DDEHF_24 / V2_24;
    constant DDEHF_25 / V2_25;
    constant DDELFHD / T1;
    constant DDELFMD / T2  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ACC_DER / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal LONG_ACC_DER_MOT_REAR / CONTROL;
    constant DDEMR_1 / V1_1;
    constant DDEMR_2 / V1_2;
    constant DDEMR_3 / V1_3;
    constant DDEMR_4 / V1_4;
    constant DDEMR_5 / V1_5;
    constant DDEMR_6 / V1_6;
    constant DDEMR_7 / V1_7;
    constant DDEMR_8 / V1_8;
    constant DDEMR_9 / V1_9;
    constant DDEMR_10 / V1_10;
    constant DDEMR_11 / V1_11;
    constant DDEMR_12 / V1_12;
    constant DDEMR_13 / V1_13;
    constant DDEMR_14 / V1_14;
    constant DDEMR_15 / V1_15;
    constant DDEMR_16 / V1_16;
    constant DDEMR_17 / V1_17;
    constant DDEMR_18 / V1_18;
    constant DDEMR_19 / V1_19;
    constant DDEMR_20 / V1_20;
    constant DDEMR_21 / V1_21;
    constant DDEMR_22 / V1_22;
    constant DDEMR_23 / V1_23;
    constant DDEMR_24 / V1_24;
    constant DDEMR_25 / V1_25;
    constant DDEHR_1 / V2_1;
    constant DDEHR_2 / V2_2;
    constant DDEHR_3 / V2_3;
    constant DDEHR_4 / V2_4;
    constant DDEHR_5 / V2_5;
    constant DDEHR_6 / V2_6;
    constant DDEHR_7 / V2_7;
    constant DDEHR_8 / V2_8;
    constant DDEHR_9 / V2_9;
    constant DDEHR_10 / V2_10;
    constant DDEHR_11 / V2_11;
    constant DDEHR_12 / V2_12;
    constant DDEHR_13 / V2_13;
    constant DDEHR_14 / V2_14;
    constant DDEHR_15 / V2_15;
    constant DDEHR_16 / V2_16;
    constant DDEHR_17 / V2_17;
    constant DDEHR_18 / V2_18;
    constant DDEHR_19 / V2_19;
    constant DDEHR_20 / V2_20;
    constant DDEHR_21 / V2_21;
    constant DDEHR_22 / V2_22;
    constant DDEHR_23 / V2_23;
    constant DDEHR_24 / V2_24;
    constant DDEHR_25 / V2_25;
    constant DDELRHD / T1;
    constant DDELRMD / T2  ]

  end signal
end module % long_acc


module ver_acc : 
  input
    RESET,
    ACC_SENS(integer),
    LONG_SPEED_KM(integer);
  output
    VER_ACC_LOW_MOT_FRONT(integer),
    VER_ACC_LOW_MOT_REAR(integer),
    VER_ACC_MED_MOT_FRONT(integer),
    VER_ACC_MED_MOT_REAR(integer),
    VER_ACC_FREQ_MED(integer),
    VER_ACC_ERR;
  constant DELCOM_18 : integer;
  constant DELCOM_1 : integer;
  constant ACLOWH_1 : integer;
  constant ACLOWM_15 : integer;
  constant DELCOM_19 : integer;
  constant DELCOM_2 : integer;
  constant DELCOL_10 : integer;
  constant ACLOWH_2 : integer;
  constant ACLOWM_16 : integer;
  constant DELCOM_3 : integer;
  constant DELFMME : integer;
  constant DELCOL_11 : integer;
  constant ACLOWH_3 : integer;
  constant ACLOWM_17 : integer;
  constant DELCOM_4 : integer;
  constant DELCOL_12 : integer;
  constant ACLOWH_4 : integer;
  constant ACLOWM_18 : integer;
  constant DELCOM_5 : integer;
  constant DELCOL_13 : integer;
  constant ACLOWH_5 : integer;
  constant ACLOWM_19 : integer;
  constant DELCOM_6 : integer;
  constant DELCOL_14 : integer;
  constant ACLOWH_6 : integer;
  constant ACLOWM_1 : integer;
  constant DELCOM_7 : integer;
  constant DELCOL_15 : integer;
  constant ACLOWH_7 : integer;
  constant ACLOWM_2 : integer;
  constant DELCOM_8 : integer;
  constant DELCOL_16 : integer;
  constant ACLOWH_8 : integer;
  constant ACLOWM_3 : integer;
  constant DELCOM_9 : integer;
  constant DELCOL_17 : integer;
  constant ACLOWH_9 : integer;
  constant ACLOWM_4 : integer;
  constant DELCOL_18 : integer;
  constant ACLOWM_5 : integer;
  constant DELCOL_19 : integer;
  constant ACLOWM_6 : integer;
  constant ACLOWM_7 : integer;
  constant ACLOWM_8 : integer;
  constant ACLOWM_9 : integer;
  constant DELCOM_20 : integer;
  constant DELCOM_21 : integer;
  constant DELCOM_22 : integer;
  constant DELCOM_23 : integer;
  constant ACLOWM_20 : integer;
  constant DELCOM_24 : integer;
  constant ACLOWM_21 : integer;
  constant DELCOM_25 : integer;
  constant ACLOWM_22 : integer;
  constant ACLOWM_23 : integer;
  constant ACLOWM_24 : integer;
  constant ACLOWM_25 : integer;
  constant DELCOL_20 : integer;
  constant DELCOL_21 : integer;
  constant DELCOL_22 : integer;
  constant DELCOL_23 : integer;
  constant DELCOL_24 : integer;
  constant DELCOL_25 : integer;
  constant DELCOL_1 : integer;
  constant DELCOL_2 : integer;
  constant ACLOWH_10 : integer;
  constant DELCOL_3 : integer;
  constant ACLOWH_11 : integer;
  constant DELCOL_4 : integer;
  constant ACLOWH_12 : integer;
  constant DELCOL_5 : integer;
  constant ACLOWH_13 : integer;
  constant DELCOL_6 : integer;
  constant ACLOWH_14 : integer;
  constant DELCOL_7 : integer;
  constant ACLOWH_15 : integer;
  constant DELCOL_8 : integer;
  constant ACLOWH_16 : integer;
  constant DELCOL_9 : integer;
  constant ACLOWH_17 : integer;
  constant ACLOWH_18 : integer;
  constant ACLOWH_19 : integer;
  constant MA0 : integer;
  constant MA1 : integer;
  constant ACMEDM_10 : integer;
  constant ACMEDM_11 : integer;
  constant ACMEDM_12 : integer;
  constant ACMEDM_13 : integer;
  constant ACMEDM_14 : integer;
  constant ACLOWH_20 : integer;
  constant ACMEDM_15 : integer;
  constant ACLOWH_21 : integer;
  constant ACMEDM_16 : integer;
  constant ACLOWH_22 : integer;
  constant ACMEDM_17 : integer;
  constant ACLOWH_23 : integer;
  constant ACMEDM_18 : integer;
  constant ACLOWH_24 : integer;
  constant ACMEDM_19 : integer;
  constant ACLOWH_25 : integer;
  constant MB0 : integer;
  constant MB1 : integer;
  constant MB2 : integer;
  constant ACMEDM_20 : integer;
  constant ACMEDM_21 : integer;
  constant LA0 : integer;
  constant ACMEDM_22 : integer;
  constant LA1 : integer;
  constant ACMEDM_23 : integer;
  constant ACMEDM_24 : integer;
  constant ACMEDM_25 : integer;
  constant ACMEDH_10 : integer;
  constant ACMEDH_1 : integer;
  constant ACMEDH_11 : integer;
  constant ACMEDH_2 : integer;
  constant ACMEDH_12 : integer;
  constant ACMEDH_3 : integer;
  constant ACMEDH_13 : integer;
  constant ACMEDH_4 : integer;
  constant ACMEDH_14 : integer;
  constant ACMEDH_5 : integer;
  constant ACMEDH_15 : integer;
  constant ACMEDH_6 : integer;
  constant ACMEDM_1 : integer;
  constant ACMEDH_16 : integer;
  constant ACMEDH_7 : integer;
  constant ACMEDM_2 : integer;
  constant ACMEDH_17 : integer;
  constant ACMEDH_8 : integer;
  constant ACMEDM_3 : integer;
  constant ACMEDH_18 : integer;
  constant ACMEDH_9 : integer;
  constant ACMEDM_4 : integer;
  constant ACMEDH_19 : integer;
  constant ACMEDM_5 : integer;
  constant ACMEDM_6 : integer;
  constant ACMEDM_7 : integer;
  constant ACMEDM_8 : integer;
  constant ACMEDM_9 : integer;
  constant LB0 : integer;
  constant LB1 : integer;
  constant LB2 : integer;
  constant ACMEDH_20 : integer;
  constant ACMEDH_21 : integer;
  constant ACMEDH_22 : integer;
  constant ACMEDH_23 : integer;
  constant ACMEDH_24 : integer;
  constant ACMEDH_25 : integer;
  constant DELFHLO : integer;
  constant DELFMLO : integer;
  constant DELCOM_10 : integer;
  constant DELCOM_11 : integer;
  constant DELCOM_12 : integer;
  constant DELCOM_13 : integer;
  constant ACLOWM_10 : integer;
  constant DELCOM_14 : integer;
  constant ACLOWM_11 : integer;
  constant DELCOM_15 : integer;
  constant DELFHME : integer;
  constant ACLOWM_12 : integer;
  constant DELCOM_16 : integer;
  constant ACLOWM_13 : integer;
  constant DELCOM_17 : integer;
  constant ACLOWM_14 : integer;
  signal
    ACC(integer),
    ACC_FREQ_LOW(integer),
    ignored
  in
  run VER_ACC_CAL [
    signal RESET / RESET;
    signal ACC_SENS / ACC_SENS;
    signal ACC / ACC  ]
  ||
  run VER_ACC_DIAG [
    signal RESET / RESET;
    signal ACC_SENS / ACC_SENS;
    signal VER_ACC_ERR / VER_ACC_ERR  ]
  ||
  run FILTER_FREQ [
    signal RESET / RESET;
    signal ACC / VALUE;
    signal ACC_FREQ_LOW / FILT_VALUE;
    constant LB0 / B0;
    constant LB1 / B1;
    constant LB2 / B2;
    constant LA0 / A0;
    constant LA1 / A1  ]
  ||
  run FILTER_FREQ [
    signal RESET / RESET;
    signal ACC / VALUE;
    signal VER_ACC_FREQ_MED / FILT_VALUE;
    constant MB0 / B0;
    constant MB1 / B1;
    constant MB2 / B2;
    constant MA0 / A0;
    constant MA1 / A1  ]
  ||
  run CURVE_FRONT [
    signal RESET / RESET;
    signal ACC_FREQ_LOW / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal VER_ACC_LOW_MOT_FRONT / CONTROL;
    constant ACLOWM_1 / V1_1;
    constant ACLOWM_2 / V1_2;
    constant ACLOWM_3 / V1_3;
    constant ACLOWM_4 / V1_4;
    constant ACLOWM_5 / V1_5;
    constant ACLOWM_6 / V1_6;
    constant ACLOWM_7 / V1_7;
    constant ACLOWM_8 / V1_8;
    constant ACLOWM_9 / V1_9;
    constant ACLOWM_10 / V1_10;
    constant ACLOWM_11 / V1_11;
    constant ACLOWM_12 / V1_12;
    constant ACLOWM_13 / V1_13;
    constant ACLOWM_14 / V1_14;
    constant ACLOWM_15 / V1_15;
    constant ACLOWM_16 / V1_16;
    constant ACLOWM_17 / V1_17;
    constant ACLOWM_18 / V1_18;
    constant ACLOWM_19 / V1_19;
    constant ACLOWM_20 / V1_20;
    constant ACLOWM_21 / V1_21;
    constant ACLOWM_22 / V1_22;
    constant ACLOWM_23 / V1_23;
    constant ACLOWM_24 / V1_24;
    constant ACLOWM_25 / V1_25;
    constant ACLOWH_1 / V2_1;
    constant ACLOWH_2 / V2_2;
    constant ACLOWH_3 / V2_3;
    constant ACLOWH_4 / V2_4;
    constant ACLOWH_5 / V2_5;
    constant ACLOWH_6 / V2_6;
    constant ACLOWH_7 / V2_7;
    constant ACLOWH_8 / V2_8;
    constant ACLOWH_9 / V2_9;
    constant ACLOWH_10 / V2_10;
    constant ACLOWH_11 / V2_11;
    constant ACLOWH_12 / V2_12;
    constant ACLOWH_13 / V2_13;
    constant ACLOWH_14 / V2_14;
    constant ACLOWH_15 / V2_15;
    constant ACLOWH_16 / V2_16;
    constant ACLOWH_17 / V2_17;
    constant ACLOWH_18 / V2_18;
    constant ACLOWH_19 / V2_19;
    constant ACLOWH_20 / V2_20;
    constant ACLOWH_21 / V2_21;
    constant ACLOWH_22 / V2_22;
    constant ACLOWH_23 / V2_23;
    constant ACLOWH_24 / V2_24;
    constant ACLOWH_25 / V2_25;
    constant DELFHLO / T1;
    constant DELFMLO / T2  ]
  ||
  run CURVE_REAR [
    signal RESET / RESET;
    signal ACC_FREQ_LOW / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal VER_ACC_LOW_MOT_REAR / CONTROL;
    constant ACLOWM_1 / V1_1;
    constant ACLOWM_2 / V1_2;
    constant ACLOWM_3 / V1_3;
    constant ACLOWM_4 / V1_4;
    constant ACLOWM_5 / V1_5;
    constant ACLOWM_6 / V1_6;
    constant ACLOWM_7 / V1_7;
    constant ACLOWM_8 / V1_8;
    constant ACLOWM_9 / V1_9;
    constant ACLOWM_10 / V1_10;
    constant ACLOWM_11 / V1_11;
    constant ACLOWM_12 / V1_12;
    constant ACLOWM_13 / V1_13;
    constant ACLOWM_14 / V1_14;
    constant ACLOWM_15 / V1_15;
    constant ACLOWM_16 / V1_16;
    constant ACLOWM_17 / V1_17;
    constant ACLOWM_18 / V1_18;
    constant ACLOWM_19 / V1_19;
    constant ACLOWM_20 / V1_20;
    constant ACLOWM_21 / V1_21;
    constant ACLOWM_22 / V1_22;
    constant ACLOWM_23 / V1_23;
    constant ACLOWM_24 / V1_24;
    constant ACLOWM_25 / V1_25;
    constant ACLOWH_1 / V2_1;
    constant ACLOWH_2 / V2_2;
    constant ACLOWH_3 / V2_3;
    constant ACLOWH_4 / V2_4;
    constant ACLOWH_5 / V2_5;
    constant ACLOWH_6 / V2_6;
    constant ACLOWH_7 / V2_7;
    constant ACLOWH_8 / V2_8;
    constant ACLOWH_9 / V2_9;
    constant ACLOWH_10 / V2_10;
    constant ACLOWH_11 / V2_11;
    constant ACLOWH_12 / V2_12;
    constant ACLOWH_13 / V2_13;
    constant ACLOWH_14 / V2_14;
    constant ACLOWH_15 / V2_15;
    constant ACLOWH_16 / V2_16;
    constant ACLOWH_17 / V2_17;
    constant ACLOWH_18 / V2_18;
    constant ACLOWH_19 / V2_19;
    constant ACLOWH_20 / V2_20;
    constant ACLOWH_21 / V2_21;
    constant ACLOWH_22 / V2_22;
    constant ACLOWH_23 / V2_23;
    constant ACLOWH_24 / V2_24;
    constant ACLOWH_25 / V2_25;
    constant DELCOL_1 / DELT_1;
    constant DELCOL_2 / DELT_2;
    constant DELCOL_3 / DELT_3;
    constant DELCOL_4 / DELT_4;
    constant DELCOL_5 / DELT_5;
    constant DELCOL_6 / DELT_6;
    constant DELCOL_7 / DELT_7;
    constant DELCOL_8 / DELT_8;
    constant DELCOL_9 / DELT_9;
    constant DELCOL_10 / DELT_10;
    constant DELCOL_11 / DELT_11;
    constant DELCOL_12 / DELT_12;
    constant DELCOL_13 / DELT_13;
    constant DELCOL_14 / DELT_14;
    constant DELCOL_15 / DELT_15;
    constant DELCOL_16 / DELT_16;
    constant DELCOL_17 / DELT_17;
    constant DELCOL_18 / DELT_18;
    constant DELCOL_19 / DELT_19;
    constant DELCOL_20 / DELT_20;
    constant DELCOL_21 / DELT_21;
    constant DELCOL_22 / DELT_22;
    constant DELCOL_23 / DELT_23;
    constant DELCOL_24 / DELT_24;
    constant DELCOL_25 / DELT_25;
    constant DELFHLO / T1;
    constant DELFMLO / T2  ]
  ||
  run CURVE_FRONT [
    signal RESET / RESET;
    signal VER_ACC_FREQ_MED / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal VER_ACC_MED_MOT_FRONT / CONTROL;
    constant ACMEDM_1 / V1_1;
    constant ACMEDM_2 / V1_2;
    constant ACMEDM_3 / V1_3;
    constant ACMEDM_4 / V1_4;
    constant ACMEDM_5 / V1_5;
    constant ACMEDM_6 / V1_6;
    constant ACMEDM_7 / V1_7;
    constant ACMEDM_8 / V1_8;
    constant ACMEDM_9 / V1_9;
    constant ACMEDM_10 / V1_10;
    constant ACMEDM_11 / V1_11;
    constant ACMEDM_12 / V1_12;
    constant ACMEDM_13 / V1_13;
    constant ACMEDM_14 / V1_14;
    constant ACMEDM_15 / V1_15;
    constant ACMEDM_16 / V1_16;
    constant ACMEDM_17 / V1_17;
    constant ACMEDM_18 / V1_18;
    constant ACMEDM_19 / V1_19;
    constant ACMEDM_20 / V1_20;
    constant ACMEDM_21 / V1_21;
    constant ACMEDM_22 / V1_22;
    constant ACMEDM_23 / V1_23;
    constant ACMEDM_24 / V1_24;
    constant ACMEDM_25 / V1_25;
    constant ACMEDH_1 / V2_1;
    constant ACMEDH_2 / V2_2;
    constant ACMEDH_3 / V2_3;
    constant ACMEDH_4 / V2_4;
    constant ACMEDH_5 / V2_5;
    constant ACMEDH_6 / V2_6;
    constant ACMEDH_7 / V2_7;
    constant ACMEDH_8 / V2_8;
    constant ACMEDH_9 / V2_9;
    constant ACMEDH_10 / V2_10;
    constant ACMEDH_11 / V2_11;
    constant ACMEDH_12 / V2_12;
    constant ACMEDH_13 / V2_13;
    constant ACMEDH_14 / V2_14;
    constant ACMEDH_15 / V2_15;
    constant ACMEDH_16 / V2_16;
    constant ACMEDH_17 / V2_17;
    constant ACMEDH_18 / V2_18;
    constant ACMEDH_19 / V2_19;
    constant ACMEDH_20 / V2_20;
    constant ACMEDH_21 / V2_21;
    constant ACMEDH_22 / V2_22;
    constant ACMEDH_23 / V2_23;
    constant ACMEDH_24 / V2_24;
    constant ACMEDH_25 / V2_25;
    constant DELFHME / T1;
    constant DELFMME / T2  ]
  ||
  run CURVE_REAR [
    signal RESET / RESET;
    signal VER_ACC_FREQ_MED / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal VER_ACC_MED_MOT_REAR / CONTROL;
    constant ACMEDM_1 / V1_1;
    constant ACMEDM_2 / V1_2;
    constant ACMEDM_3 / V1_3;
    constant ACMEDM_4 / V1_4;
    constant ACMEDM_5 / V1_5;
    constant ACMEDM_6 / V1_6;
    constant ACMEDM_7 / V1_7;
    constant ACMEDM_8 / V1_8;
    constant ACMEDM_9 / V1_9;
    constant ACMEDM_10 / V1_10;
    constant ACMEDM_11 / V1_11;
    constant ACMEDM_12 / V1_12;
    constant ACMEDM_13 / V1_13;
    constant ACMEDM_14 / V1_14;
    constant ACMEDM_15 / V1_15;
    constant ACMEDM_16 / V1_16;
    constant ACMEDM_17 / V1_17;
    constant ACMEDM_18 / V1_18;
    constant ACMEDM_19 / V1_19;
    constant ACMEDM_20 / V1_20;
    constant ACMEDM_21 / V1_21;
    constant ACMEDM_22 / V1_22;
    constant ACMEDM_23 / V1_23;
    constant ACMEDM_24 / V1_24;
    constant ACMEDM_25 / V1_25;
    constant ACMEDH_1 / V2_1;
    constant ACMEDH_2 / V2_2;
    constant ACMEDH_3 / V2_3;
    constant ACMEDH_4 / V2_4;
    constant ACMEDH_5 / V2_5;
    constant ACMEDH_6 / V2_6;
    constant ACMEDH_7 / V2_7;
    constant ACMEDH_8 / V2_8;
    constant ACMEDH_9 / V2_9;
    constant ACMEDH_10 / V2_10;
    constant ACMEDH_11 / V2_11;
    constant ACMEDH_12 / V2_12;
    constant ACMEDH_13 / V2_13;
    constant ACMEDH_14 / V2_14;
    constant ACMEDH_15 / V2_15;
    constant ACMEDH_16 / V2_16;
    constant ACMEDH_17 / V2_17;
    constant ACMEDH_18 / V2_18;
    constant ACMEDH_19 / V2_19;
    constant ACMEDH_20 / V2_20;
    constant ACMEDH_21 / V2_21;
    constant ACMEDH_22 / V2_22;
    constant ACMEDH_23 / V2_23;
    constant ACMEDH_24 / V2_24;
    constant ACMEDH_25 / V2_25;
    constant DELCOM_1 / DELT_1;
    constant DELCOM_2 / DELT_2;
    constant DELCOM_3 / DELT_3;
    constant DELCOM_4 / DELT_4;
    constant DELCOM_5 / DELT_5;
    constant DELCOM_6 / DELT_6;
    constant DELCOM_7 / DELT_7;
    constant DELCOM_8 / DELT_8;
    constant DELCOM_9 / DELT_9;
    constant DELCOM_10 / DELT_10;
    constant DELCOM_11 / DELT_11;
    constant DELCOM_12 / DELT_12;
    constant DELCOM_13 / DELT_13;
    constant DELCOM_14 / DELT_14;
    constant DELCOM_15 / DELT_15;
    constant DELCOM_16 / DELT_16;
    constant DELCOM_17 / DELT_17;
    constant DELCOM_18 / DELT_18;
    constant DELCOM_19 / DELT_19;
    constant DELCOM_20 / DELT_20;
    constant DELCOM_21 / DELT_21;
    constant DELCOM_22 / DELT_22;
    constant DELCOM_23 / DELT_23;
    constant DELCOM_24 / DELT_24;
    constant DELCOM_25 / DELT_25;
    constant DELFHME / T1;
    constant DELFMME / T2  ]

  end signal
end module % ver_acc


module steer_ang : 
  input
    RESET,
    CLOCK_24,
    STEER1_SENS(boolean),
    STEER2_SENS(boolean),
    STEER_SENS(boolean),
    LONG_SPEED_FILT(integer),
    LONG_SPEED_KM(integer);
  output
    STEER_ANG_MOT_FRONT(integer),
    STEER_ANG_MOT_REAR(integer),
    STEER_ANG_DAMAGE(integer),
    ANG_ERR;
  constant ANHR_1 : integer;
  constant ANHR_2 : integer;
  constant ANHR_3 : integer;
  constant ANHR_4 : integer;
  constant ANHR_5 : integer;
  constant ANHR_6 : integer;
  constant ANHR_7 : integer;
  constant ANHR_8 : integer;
  constant ANHR_9 : integer;
  constant ANMF_1 : integer;
  constant ANMF_2 : integer;
  constant ANMF_3 : integer;
  constant ANMF_4 : integer;
  constant ANMF_5 : integer;
  constant ANMF_6 : integer;
  constant ANMF_7 : integer;
  constant ANHR_10 : integer;
  constant ANMF_8 : integer;
  constant ANHR_11 : integer;
  constant ANMF_9 : integer;
  constant ANHR_12 : integer;
  constant ANHR_13 : integer;
  constant DELFHAN : integer;
  constant ANHR_14 : integer;
  constant ANHR_15 : integer;
  constant ANMR_10 : integer;
  constant ANHR_16 : integer;
  constant ANMR_11 : integer;
  constant ANHR_17 : integer;
  constant ANMR_12 : integer;
  constant ANHR_18 : integer;
  constant ANMR_13 : integer;
  constant DELFMAN : integer;
  constant ANHR_19 : integer;
  constant ANMR_14 : integer;
  constant ANMR_15 : integer;
  constant ANMR_16 : integer;
  constant ANMR_17 : integer;
  constant ANMR_18 : integer;
  constant ANMR_19 : integer;
  constant ANHR_20 : integer;
  constant ANHR_21 : integer;
  constant ANHR_22 : integer;
  constant ANHR_23 : integer;
  constant ANHR_24 : integer;
  constant ANHR_25 : integer;
  constant ANMR_20 : integer;
  constant ANMR_21 : integer;
  constant ANMR_22 : integer;
  constant ANHF_1 : integer;
  constant ANMR_23 : integer;
  constant ANHF_2 : integer;
  constant ANMR_24 : integer;
  constant ANHF_3 : integer;
  constant ANMR_25 : integer;
  constant ANHF_4 : integer;
  constant ANHF_5 : integer;
  constant ANHF_6 : integer;
  constant ANHF_7 : integer;
  constant ANHF_8 : integer;
  constant ANHF_9 : integer;
  constant DELRHAN : integer;
  constant DELRMAN : integer;
  constant ANHF_10 : integer;
  constant ANHF_11 : integer;
  constant ANHF_12 : integer;
  constant ANHF_13 : integer;
  constant ANHF_14 : integer;
  constant ANHF_15 : integer;
  constant ANMF_10 : integer;
  constant ANHF_16 : integer;
  constant ANMF_11 : integer;
  constant ANHF_17 : integer;
  constant ANMF_12 : integer;
  constant ANHF_18 : integer;
  constant ANMF_13 : integer;
  constant ANHF_19 : integer;
  constant ANMF_14 : integer;
  constant ANMF_15 : integer;
  constant ANMF_16 : integer;
  constant ANMF_17 : integer;
  constant ANMF_18 : integer;
  constant ANMF_19 : integer;
  constant ANMR_1 : integer;
  constant ANMR_2 : integer;
  constant ANMR_3 : integer;
  constant ANMR_4 : integer;
  constant ANMR_5 : integer;
  constant ANMR_6 : integer;
  constant ANMR_7 : integer;
  constant ANMR_8 : integer;
  constant ANMR_9 : integer;
  constant ANHF_20 : integer;
  constant ANHF_21 : integer;
  constant ANHF_22 : integer;
  constant ANHF_23 : integer;
  constant ANHF_24 : integer;
  constant ANHF_25 : integer;
  constant ANMF_20 : integer;
  constant ANMF_21 : integer;
  constant ANMF_22 : integer;
  constant ANMF_23 : integer;
  constant ANMF_24 : integer;
  constant ANMF_25 : integer;
  signal
    CORR_ERR,
    ANG(integer),
    ANG_CORR(integer),
    CAL_ERR,
    DIAG_ERR,
    ignored
  in
  run steer_ang_cal [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal STEER_SENS / STEER_SENS;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal ANG / ANG;
    signal CAL_ERR / CAL_ERR  ]
  ||
  run STEER_ANG_CORR [
    signal RESET / RESET;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal ANG / ANG;
    signal ANG_CORR / ANG_CORR;
    signal CORR_ERR / CORR_ERR  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ANG_CORR / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal STEER_ANG_MOT_FRONT / CONTROL;
    constant ANMF_1 / V1_1;
    constant ANMF_2 / V1_2;
    constant ANMF_3 / V1_3;
    constant ANMF_4 / V1_4;
    constant ANMF_5 / V1_5;
    constant ANMF_6 / V1_6;
    constant ANMF_7 / V1_7;
    constant ANMF_8 / V1_8;
    constant ANMF_9 / V1_9;
    constant ANMF_10 / V1_10;
    constant ANMF_11 / V1_11;
    constant ANMF_12 / V1_12;
    constant ANMF_13 / V1_13;
    constant ANMF_14 / V1_14;
    constant ANMF_15 / V1_15;
    constant ANMF_16 / V1_16;
    constant ANMF_17 / V1_17;
    constant ANMF_18 / V1_18;
    constant ANMF_19 / V1_19;
    constant ANMF_20 / V1_20;
    constant ANMF_21 / V1_21;
    constant ANMF_22 / V1_22;
    constant ANMF_23 / V1_23;
    constant ANMF_24 / V1_24;
    constant ANMF_25 / V1_25;
    constant ANHF_1 / V2_1;
    constant ANHF_2 / V2_2;
    constant ANHF_3 / V2_3;
    constant ANHF_4 / V2_4;
    constant ANHF_5 / V2_5;
    constant ANHF_6 / V2_6;
    constant ANHF_7 / V2_7;
    constant ANHF_8 / V2_8;
    constant ANHF_9 / V2_9;
    constant ANHF_10 / V2_10;
    constant ANHF_11 / V2_11;
    constant ANHF_12 / V2_12;
    constant ANHF_13 / V2_13;
    constant ANHF_14 / V2_14;
    constant ANHF_15 / V2_15;
    constant ANHF_16 / V2_16;
    constant ANHF_17 / V2_17;
    constant ANHF_18 / V2_18;
    constant ANHF_19 / V2_19;
    constant ANHF_20 / V2_20;
    constant ANHF_21 / V2_21;
    constant ANHF_22 / V2_22;
    constant ANHF_23 / V2_23;
    constant ANHF_24 / V2_24;
    constant ANHF_25 / V2_25;
    constant DELFHAN / T1;
    constant DELFMAN / T2  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal ANG_CORR / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal STEER_ANG_MOT_REAR / CONTROL;
    constant ANMR_1 / V1_1;
    constant ANMR_2 / V1_2;
    constant ANMR_3 / V1_3;
    constant ANMR_4 / V1_4;
    constant ANMR_5 / V1_5;
    constant ANMR_6 / V1_6;
    constant ANMR_7 / V1_7;
    constant ANMR_8 / V1_8;
    constant ANMR_9 / V1_9;
    constant ANMR_10 / V1_10;
    constant ANMR_11 / V1_11;
    constant ANMR_12 / V1_12;
    constant ANMR_13 / V1_13;
    constant ANMR_14 / V1_14;
    constant ANMR_15 / V1_15;
    constant ANMR_16 / V1_16;
    constant ANMR_17 / V1_17;
    constant ANMR_18 / V1_18;
    constant ANMR_19 / V1_19;
    constant ANMR_20 / V1_20;
    constant ANMR_21 / V1_21;
    constant ANMR_22 / V1_22;
    constant ANMR_23 / V1_23;
    constant ANMR_24 / V1_24;
    constant ANMR_25 / V1_25;
    constant ANHR_1 / V2_1;
    constant ANHR_2 / V2_2;
    constant ANHR_3 / V2_3;
    constant ANHR_4 / V2_4;
    constant ANHR_5 / V2_5;
    constant ANHR_6 / V2_6;
    constant ANHR_7 / V2_7;
    constant ANHR_8 / V2_8;
    constant ANHR_9 / V2_9;
    constant ANHR_10 / V2_10;
    constant ANHR_11 / V2_11;
    constant ANHR_12 / V2_12;
    constant ANHR_13 / V2_13;
    constant ANHR_14 / V2_14;
    constant ANHR_15 / V2_15;
    constant ANHR_16 / V2_16;
    constant ANHR_17 / V2_17;
    constant ANHR_18 / V2_18;
    constant ANHR_19 / V2_19;
    constant ANHR_20 / V2_20;
    constant ANHR_21 / V2_21;
    constant ANHR_22 / V2_22;
    constant ANHR_23 / V2_23;
    constant ANHR_24 / V2_24;
    constant ANHR_25 / V2_25;
    constant DELRHAN / T1;
    constant DELRMAN / T2  ]
  ||
  run STEER_ANG_DIAG [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal DIAG_ERR / DIAG_ERR;
    signal STEER_ANG_DAMAGE / STEER_ANG_DAMAGE  ]
  ||
  run ARB_3 [
    signal CAL_ERR / ERR1;
    signal CORR_ERR / ERR2;
    signal DIAG_ERR / ERR3;
    signal ANG_ERR / ERR  ]

  end signal
end module % steer_ang


module steer_ang_cal : 
  input
    RESET,
    CLOCK_24,
    STEER1_SENS(boolean),
    STEER2_SENS(boolean),
    STEER_SENS(boolean),
    LONG_SPEED_FILT(integer);
  output
    ANG(integer),
    CAL_ERR;
  signal
    INIT,
    ignored
  in
  run STEER_ANG_CAL_INIT [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal STEER_SENS / STEER_SENS;
    signal LONG_SPEED_FILT / LONG_SPEED_FILT;
    signal INIT / INIT  ]
  ||
  run STEER_ANG_CAL_VAL [
    signal RESET / RESET;
    signal CLOCK_24 / CLOCK_24;
    signal INIT / INIT;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal STEER_SENS / STEER_SENS;
    signal ANG / ANG;
    signal CAL_ERR / CAL_ERR  ]

  end signal
end module % steer_ang_cal


module steer_speed : 
  input
    RESET,
    CLOCK_16,
    STEER1_SENS(boolean),
    STEER2_SENS(boolean),
    LONG_SPEED_KM(integer);
  output
    STEER_NO_SOFT,
    STEER_SPEED_ERR,
    STEER_SPEED_MOT_FRONT(integer),
    STEER_SPEED_MOT_REAR(integer);
  constant VAHR_2 : integer;
  constant VAHF_13 : integer;
  constant VAHR_3 : integer;
  constant VAHF_14 : integer;
  constant VAHR_4 : integer;
  constant VAHF_15 : integer;
  constant VAMF_10 : integer;
  constant VAHR_5 : integer;
  constant VAHF_16 : integer;
  constant VAMF_11 : integer;
  constant VAHR_6 : integer;
  constant VAHF_17 : integer;
  constant VAMF_12 : integer;
  constant VAHR_7 : integer;
  constant VAHF_18 : integer;
  constant VAMF_13 : integer;
  constant VAHR_8 : integer;
  constant VAHF_19 : integer;
  constant VAMF_14 : integer;
  constant VAHR_9 : integer;
  constant VAMF_15 : integer;
  constant VAMF_16 : integer;
  constant VAMF_17 : integer;
  constant VAMF_18 : integer;
  constant VAMF_19 : integer;
  constant VAMF_1 : integer;
  constant VAMF_2 : integer;
  constant VAMF_3 : integer;
  constant VAMF_4 : integer;
  constant VAMF_5 : integer;
  constant VAMF_6 : integer;
  constant VAHF_20 : integer;
  constant VAMF_7 : integer;
  constant VAHF_21 : integer;
  constant VAMF_8 : integer;
  constant VAHF_22 : integer;
  constant VAMF_9 : integer;
  constant VAHF_23 : integer;
  constant VAHF_24 : integer;
  constant VAHF_25 : integer;
  constant VAMF_20 : integer;
  constant VAMF_21 : integer;
  constant VAMF_22 : integer;
  constant VAMF_23 : integer;
  constant VAMF_24 : integer;
  constant VAMF_25 : integer;
  constant Kv : integer;
  constant VAHF_1 : integer;
  constant VAHF_2 : integer;
  constant VAHF_3 : integer;
  constant VAHF_4 : integer;
  constant VAHF_5 : integer;
  constant DELFHVA : integer;
  constant VAHF_6 : integer;
  constant VAHF_7 : integer;
  constant VAHF_8 : integer;
  constant VAHF_9 : integer;
  constant DELFMVA : integer;
  constant VAHR_10 : integer;
  constant VAHR_11 : integer;
  constant VAHR_12 : integer;
  constant VAHR_13 : integer;
  constant VAHR_14 : integer;
  constant VAHR_15 : integer;
  constant VAMR_10 : integer;
  constant VAHR_16 : integer;
  constant VAMR_11 : integer;
  constant VAHR_17 : integer;
  constant VAMR_12 : integer;
  constant VAHR_18 : integer;
  constant VAMR_13 : integer;
  constant VAHR_19 : integer;
  constant VAMR_14 : integer;
  constant VAMR_15 : integer;
  constant VAMR_16 : integer;
  constant VAMR_17 : integer;
  constant VAMR_18 : integer;
  constant VAMR_19 : integer;
  constant VAHR_20 : integer;
  constant VAHR_21 : integer;
  constant VAHR_22 : integer;
  constant VAHR_23 : integer;
  constant VAHR_24 : integer;
  constant VAHR_25 : integer;
  constant VAMR_20 : integer;
  constant VAMR_21 : integer;
  constant VAMR_22 : integer;
  constant VAMR_23 : integer;
  constant VAMR_24 : integer;
  constant VAMR_25 : integer;
  constant VAMR_1 : integer;
  constant VAMR_2 : integer;
  constant VAMR_3 : integer;
  constant VAMR_4 : integer;
  constant VAMR_5 : integer;
  constant VAMR_6 : integer;
  constant VAMR_7 : integer;
  constant VAMR_8 : integer;
  constant VAMR_9 : integer;
  constant DELRHVA : integer;
  constant DELRMVA : integer;
  constant VAHF_10 : integer;
  constant VAHF_11 : integer;
  constant VAHR_1 : integer;
  constant VAHF_12 : integer;
  signal
    SPEED(integer),
    SPEED_FILT(integer),
    ignored
  in
  run STEER_SPEED_CAL [
    signal RESET / RESET;
    signal CLOCK_16 / CLOCK_16;
    signal STEER1_SENS / STEER1_SENS;
    signal STEER2_SENS / STEER2_SENS;
    signal SPEED / SPEED  ]
  ||
  run FILTER [
    signal RESET / RESET;
    signal SPEED / VALUE;
    signal SPEED_FILT / FILT_VALUE;
    constant Kv / K  ]
  ||
  run STEER_SPEED_DIAG [
    signal RESET / RESET;
    signal SPEED / SPEED;
    signal STEER_NO_SOFT / STEER_NO_SOFT;
    signal STEER_SPEED_ERR / STEER_SPEED_ERR  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal SPEED_FILT / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal STEER_SPEED_MOT_FRONT / CONTROL;
    constant VAMF_1 / V1_1;
    constant VAMF_2 / V1_2;
    constant VAMF_3 / V1_3;
    constant VAMF_4 / V1_4;
    constant VAMF_5 / V1_5;
    constant VAMF_6 / V1_6;
    constant VAMF_7 / V1_7;
    constant VAMF_8 / V1_8;
    constant VAMF_9 / V1_9;
    constant VAMF_10 / V1_10;
    constant VAMF_11 / V1_11;
    constant VAMF_12 / V1_12;
    constant VAMF_13 / V1_13;
    constant VAMF_14 / V1_14;
    constant VAMF_15 / V1_15;
    constant VAMF_16 / V1_16;
    constant VAMF_17 / V1_17;
    constant VAMF_18 / V1_18;
    constant VAMF_19 / V1_19;
    constant VAMF_20 / V1_20;
    constant VAMF_21 / V1_21;
    constant VAMF_22 / V1_22;
    constant VAMF_23 / V1_23;
    constant VAMF_24 / V1_24;
    constant VAMF_25 / V1_25;
    constant VAHF_1 / V2_1;
    constant VAHF_2 / V2_2;
    constant VAHF_3 / V2_3;
    constant VAHF_4 / V2_4;
    constant VAHF_5 / V2_5;
    constant VAHF_6 / V2_6;
    constant VAHF_7 / V2_7;
    constant VAHF_8 / V2_8;
    constant VAHF_9 / V2_9;
    constant VAHF_10 / V2_10;
    constant VAHF_11 / V2_11;
    constant VAHF_12 / V2_12;
    constant VAHF_13 / V2_13;
    constant VAHF_14 / V2_14;
    constant VAHF_15 / V2_15;
    constant VAHF_16 / V2_16;
    constant VAHF_17 / V2_17;
    constant VAHF_18 / V2_18;
    constant VAHF_19 / V2_19;
    constant VAHF_20 / V2_20;
    constant VAHF_21 / V2_21;
    constant VAHF_22 / V2_22;
    constant VAHF_23 / V2_23;
    constant VAHF_24 / V2_24;
    constant VAHF_25 / V2_25;
    constant DELFHVA / T1;
    constant DELFMVA / T2  ]
  ||
  run CURVE [
    signal RESET / RESET;
    signal SPEED_FILT / VALUE;
    signal LONG_SPEED_KM / SPEED;
    signal STEER_SPEED_MOT_REAR / CONTROL;
    constant VAMR_1 / V1_1;
    constant VAMR_2 / V1_2;
    constant VAMR_3 / V1_3;
    constant VAMR_4 / V1_4;
    constant VAMR_5 / V1_5;
    constant VAMR_6 / V1_6;
    constant VAMR_7 / V1_7;
    constant VAMR_8 / V1_8;
    constant VAMR_9 / V1_9;
    constant VAMR_10 / V1_10;
    constant VAMR_11 / V1_11;
    constant VAMR_12 / V1_12;
    constant VAMR_13 / V1_13;
    constant VAMR_14 / V1_14;
    constant VAMR_15 / V1_15;
    constant VAMR_16 / V1_16;
    constant VAMR_17 / V1_17;
    constant VAMR_18 / V1_18;
    constant VAMR_19 / V1_19;
    constant VAMR_20 / V1_20;
    constant VAMR_21 / V1_21;
    constant VAMR_22 / V1_22;
    constant VAMR_23 / V1_23;
    constant VAMR_24 / V1_24;
    constant VAMR_25 / V1_25;
    constant VAHR_1 / V2_1;
    constant VAHR_2 / V2_2;
    constant VAHR_3 / V2_3;
    constant VAHR_4 / V2_4;
    constant VAHR_5 / V2_5;
    constant VAHR_6 / V2_6;
    constant VAHR_7 / V2_7;
    constant VAHR_8 / V2_8;
    constant VAHR_9 / V2_9;
    constant VAHR_10 / V2_10;
    constant VAHR_11 / V2_11;
    constant VAHR_12 / V2_12;
    constant VAHR_13 / V2_13;
    constant VAHR_14 / V2_14;
    constant VAHR_15 / V2_15;
    constant VAHR_16 / V2_16;
    constant VAHR_17 / V2_17;
    constant VAHR_18 / V2_18;
    constant VAHR_19 / V2_19;
    constant VAHR_20 / V2_20;
    constant VAHR_21 / V2_21;
    constant VAHR_22 / V2_22;
    constant VAHR_23 / V2_23;
    constant VAHR_24 / V2_24;
    constant VAHR_25 / V2_25;
    constant DELRHVA / T1;
    constant DELRMVA / T2  ]

  end signal
end module % steer_speed


module mot_ctrl : 
  input
    RESET,
    CLOCK_500,
    LONG_SPEED_MOT(integer),
    LONG_ACC_MOT_FRONT(integer),
    LONG_DECC_MOT_FRONT(integer),
    LONG_ACC_DER_MOT_FRONT(integer),
    VER_ACC_LOW_MOT_FRONT(integer),
    VER_ACC_MED_MOT_FRONT(integer),
    STEER_ANG_MOT_FRONT(integer),
    STEER_SPEED_MOT_FRONT(integer),
    LONG_ACC_MOT_REAR(integer),
    LONG_DECC_MOT_REAR(integer),
    LONG_ACC_DER_MOT_REAR(integer),
    VER_ACC_LOW_MOT_REAR(integer),
    VER_ACC_MED_MOT_REAR(integer),
    STEER_ANG_MOT_REAR(integer),
    STEER_SPEED_MOT_REAR(integer),
    LONG_SPEED_ERR,
    VER_ACC_ERR,
    STEER_ANG_ERR,
    STEER_SPEED_ERR,
    BAT_ERR,
    BAT_MOT_HARD,
    BAT_MOT_RES,
    STEER_ANG_DAMAGE(integer),
    STEER_SPEED_NO_SOFT,
    VBAT(integer),
    MOT_POS_A1(boolean),
    MOT_POS_B1(boolean),
    MOT_POS_A2(boolean),
    MOT_POS_B2(boolean),
    MOT_POS_A3(boolean),
    MOT_POS_B3(boolean),
    MOT_POS_A4(boolean),
    MOT_POS_B4(boolean);
  output
    MOT_CHANNEL_P1(boolean),
    MOT_CHANNEL_N1(boolean),
    MOT_CHANNEL_P2(boolean),
    MOT_CHANNEL_N2(boolean),
    MOT_CHANNEL_P3(boolean),
    MOT_CHANNEL_N3(boolean),
    MOT_CHANNEL_P4(boolean),
    MOT_CHANNEL_N4(boolean);
  signal
    MOT_DAMAGE(integer),
    MOT_REAR(integer),
    MOT_FRONT(integer),
    ignored
  in
  run ARBITER [
    signal RESET / RESET;
    signal LONG_SPEED_MOT / CTRL_1;
    signal LONG_ACC_MOT_FRONT / CTRL_2;
    signal LONG_DECC_MOT_FRONT / CTRL_3;
    signal LONG_ACC_DER_MOT_FRONT / CTRL_4;
    signal VER_ACC_LOW_MOT_FRONT / CTRL_5;
    signal VER_ACC_MED_MOT_FRONT / CTRL_6;
    signal STEER_ANG_MOT_FRONT / CTRL_7;
    signal STEER_SPEED_MOT_FRONT / CTRL_8;
    signal MOT_FRONT / CTRL  ]
  ||
  run ARBITER [
    signal RESET / RESET;
    signal LONG_SPEED_MOT / CTRL_1;
    signal LONG_ACC_MOT_REAR / CTRL_2;
    signal LONG_DECC_MOT_REAR / CTRL_3;
    signal LONG_ACC_DER_MOT_REAR / CTRL_4;
    signal VER_ACC_LOW_MOT_REAR / CTRL_5;
    signal VER_ACC_MED_MOT_REAR / CTRL_6;
    signal STEER_ANG_MOT_REAR / CTRL_7;
    signal STEER_SPEED_MOT_REAR / CTRL_8;
    signal MOT_REAR / CTRL  ]
  ||
  run MOT_CTRL_DAMAGE [
    signal RESET / RESET;
    signal LONG_SPEED_ERR / LONG_SPEED_ERR;
    signal VER_ACC_ERR / VER_ACC_ERR;
    signal STEER_ANG_ERR / STEER_ANG_ERR;
    signal STEER_SPEED_ERR / STEER_SPEED_ERR;
    signal BAT_ERR / BAT_ERR;
    signal BAT_MOT_HARD / BAT_MOT_HARD;
    signal BAT_MOT_RES / BAT_MOT_RES;
    signal STEER_ANG_DAMAGE / STEER_ANG_DAMAGE;
    signal STEER_SPEED_NO_SOFT / STEER_SPEED_NO_SOFT;
    signal MOT_DAMAGE / MOT_DAMAGE  ]
  ||
  run DRIVER [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal MOT_FRONT / COMMAND;
    signal MOT_DAMAGE / DAMAGE;
    signal MOT_POS_A1 / POS_A;
    signal MOT_POS_B1 / POS_B;
    signal VBAT / VBAT;
    signal MOT_CHANNEL_P1 / CHANNEL_P;
    signal MOT_CHANNEL_N1 / CHANNEL_N  ]
  ||
  run DRIVER [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal MOT_FRONT / COMMAND;
    signal MOT_DAMAGE / DAMAGE;
    signal MOT_POS_A2 / POS_A;
    signal MOT_POS_B2 / POS_B;
    signal VBAT / VBAT;
    signal MOT_CHANNEL_P2 / CHANNEL_P;
    signal MOT_CHANNEL_N2 / CHANNEL_N  ]
  ||
  run DRIVER [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal MOT_REAR / COMMAND;
    signal MOT_DAMAGE / DAMAGE;
    signal MOT_POS_A3 / POS_A;
    signal MOT_POS_B3 / POS_B;
    signal VBAT / VBAT;
    signal MOT_CHANNEL_P3 / CHANNEL_P;
    signal MOT_CHANNEL_N3 / CHANNEL_N  ]
  ||
  run DRIVER [
    signal RESET / RESET;
    signal CLOCK_500 / CLOCK_500;
    signal MOT_REAR / COMMAND;
    signal MOT_DAMAGE / DAMAGE;
    signal MOT_POS_A4 / POS_A;
    signal MOT_POS_B4 / POS_B;
    signal VBAT / VBAT;
    signal MOT_CHANNEL_P4 / CHANNEL_P;
    signal MOT_CHANNEL_N4 / CHANNEL_N  ]

  end signal
end module % mot_ctrl


%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Motor control signal in a damage situation:
%
% It generates a damage signal according to the error signals of other
% modules.
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			LONG_SPEED_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Global error signals of longitudinal speed sensor
%
% Name			VER_ACC_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
% Name			STEER_ANG_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
% Name			STEER_SPEED_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
% Name			BAT_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
% Name			BAT_MOT_HARD
% Data size		1 bit
% Range			ON - OFF
% Function		Signal for set motors into HARD condition
%
% Name			BAT_MOT_RES
% Data size		1 bit
% Range			ON - OFF
% Function		Acts a reset sequence on motors
%
% Name			STEER_ANG_DAMAGE
% Data size		2 bit
% Range			SOFT - MED - HARD
% Function		Signal for set motor condition in the case of errror
%
% Name			STEER_SPEED_NO_SOFT
% Data size		1 bit
% Range			ON - OFF
% Function		Signal for set motors into not SOFT condition
%
% OUTPUTS:
%
% Name			MOT_DAMAGE
% Data size		2 bit
% Range			SOFT - MED - HARD
% Function		Signal for global damage situation
%
module MOT_CTRL_DAMAGE:
input
  RESET,
  LONG_SPEED_ERR,
  VER_ACC_ERR,
  STEER_ANG_ERR,
  STEER_SPEED_ERR,
  BAT_ERR,
  BAT_MOT_HARD,
  BAT_MOT_RES,
  STEER_ANG_DAMAGE(integer),
  STEER_SPEED_NO_SOFT;
output
  MOT_DAMAGE(integer);
constant
  SOFT, MED, HARD : integer;
var
  LONG_SPEED_ERR_VALUE : integer,
  VER_ACC_ERR_VALUE : integer,
  STEER_ANG_ERR_VALUE : integer,
  STEER_SPEED_ERR_VALUE : integer,
  BAT_ERR_VALUE : integer,
  BAT_MOT_HARD_VALUE : integer,
  STEER_ANG_DAMAGE_VALUE : integer,
  MOT_DAMAGE_VALUE : integer
in
  % Infinite loop
  loop
    % Reset sequence
    LONG_SPEED_ERR_VALUE := SOFT;
    VER_ACC_ERR_VALUE := SOFT;
    STEER_ANG_ERR_VALUE := SOFT;
    STEER_SPEED_ERR_VALUE := SOFT;
    BAT_ERR_VALUE := SOFT;
    BAT_MOT_HARD_VALUE := SOFT;
    STEER_ANG_DAMAGE_VALUE := SOFT;
    MOT_DAMAGE_VALUE := SOFT;
    do
      loop
        % Emit output
        emit MOT_DAMAGE(MOT_DAMAGE_VALUE);
        % Wait for input signals
        await
          case LONG_SPEED_ERR do
            LONG_SPEED_ERR_VALUE := HARD;
          case VER_ACC_ERR do
            VER_ACC_ERR_VALUE := HARD;
          case STEER_ANG_ERR do
            STEER_ANG_ERR_VALUE := HARD;
          case STEER_SPEED_ERR do
            STEER_SPEED_ERR_VALUE := HARD;
          case BAT_ERR do
            BAT_ERR_VALUE := HARD;
          case BAT_MOT_HARD do
            BAT_MOT_HARD_VALUE := HARD;
          case BAT_MOT_RES do
            BAT_ERR_VALUE := SOFT;
            BAT_MOT_HARD_VALUE := SOFT;
          case STEER_SPEED_NO_SOFT do
            if (STEER_SPEED_ERR_VALUE <> HARD) then
              STEER_SPEED_ERR_VALUE := MED;
            end; 
          case STEER_ANG_DAMAGE do
            STEER_ANG_DAMAGE_VALUE := ?STEER_ANG_DAMAGE;
        end;
        % Set output value
        if ((LONG_SPEED_ERR_VALUE = HARD) or (VER_ACC_ERR_VALUE = HARD) or
            (STEER_ANG_ERR_VALUE = HARD) or (STEER_SPEED_ERR_VALUE = HARD) or
            (BAT_ERR_VALUE = HARD) or (STEER_ANG_DAMAGE_VALUE = HARD)) then
          MOT_DAMAGE_VALUE := HARD;
        else
          if ((STEER_SPEED_ERR_VALUE = MED) or (STEER_ANG_DAMAGE_VALUE = MED)) then
            MOT_DAMAGE_VALUE := MED;
          else
            MOT_DAMAGE_VALUE := SOFT;
          end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% SPEED_SENS signal simulation:
%
% TRS = 1 / (VELINST [0.0039 Km/h] * S_SENS [Hz/(Km/h)])
%
% TRS = 1 / (VELINST [0.0039 Km/h] * 1.11 [Hz/(Km/h)])
%
% TRS = 1 / VELINST * 1 / (0.0039 * 1.11 Hz)
%
% TRS = 230.6306 / VELINST
%
% TRS [ 32 usec] = 7207207 / VELINST = K_SENS / VELINST 
%
% S_SENS = 1.11 Hz/(Km/h)
% K_SENS = 7207207
% TIME_3_Km = 9384
%
module SPEED_SENS:
input
  RESET,
  CLOCK_32,
  VELINST(integer);
output
  SPEED_SENS;
constant
  TIME_3_Km : integer,
  K_SENS : integer;
var
  VELINST_VAL : integer,
  TIME : integer,
  TRS : integer
in
  %infinite loop
  loop
    % Reset sequence
    TIME := TIME_3_Km;
    TRS := TIME_3_Km;
    VELINST_VAL := 0;
    % When a RESET occurs quit loop
    do
      % Infinite loop for sensor signal simulation
      loop
        % Wait for input
	await [CLOCK_32 or VELINST];
        present VELINST then
          % Get its value
          VELINST_VAL := ?VELINST;
          if (VELINST_VAL = 0) then
            TRS := TIME_3_Km;
            TIME := TIME_3_Km;
          else
            % Calculate period time
            TRS := K_SENS / VELINST_VAL;
          end;
        end;
	present CLOCK_32 then
	  % Decrease timer
	  TIME := TIME - 1;
	  % Test timer
	  if (TIME <= 0) then
	    % Emit sensor signal
	    emit SPEED_SENS;
	    % Set timer
	    TIME := TRS;
          end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Initialization of angle calculation of steer wheel:
%
% For the initialization it waits until speed is more than 50 Km/h and
% three steer-wheel signals equal to 0. If it does not exceed it for
% MAX_INIT_TIME then the speeed limit will be 30 Km/h. If this condition
% is satisfied the it sends an INIT signal to STEER_ANG_CAL_VAL module.
%
% CONSTANTS:
%
% Name			MAX_INIT_TIME
% Data size		Unsigned 16 bit
% Range			0 - 1572.8 sec
% Resolution		24 msec/bit
% Function		Time threshold for setting initial value
% Threshold		26 minutes
% Value			65000
%
% Name			INIT_SPEED1
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Speed threshold for setting initial value
% Threshold		50 Km/h
% Value			12850
%
% Name			INIT_SPEED2
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Speed threshold for setting initial value
% Threshold		30 Km/h
% Value			7710
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_24
% Period		24 msec
% Function		Clock
%
% Name			STEER1_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% Name			STEER2_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% Name			STEER_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% Name			LONG_SPEED_FILT
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Filtered longitudinal speed
%
% OUTPUT:
%
% Name			INIT
% Data size		1 bit
% Range			ON - OFF
% Function		Signals to initializa angle calculation
%
module STEER_ANG_CAL_INIT:
input
  RESET,
  CLOCK_24,
  STEER1_SENS(boolean),
  STEER2_SENS(boolean),
  STEER_SENS(boolean),
  LONG_SPEED_FILT(integer);
output
  INIT;
constant
  MAX_INIT_TIME : integer,
  INIT_SPEED1 : integer,
  INIT_SPEED2 : integer;
var
  STEER1_VALUE : boolean,	% Value of sensor
  STEER2_VALUE : boolean,	% Value of sensor
  STEER_VALUE : boolean,	% Value of sensor
  SPEED_VALUE : integer,        % Speed sensor
  INIT_TIME : integer		% Initial timer
in
  % Infinite loop
  loop
    % Reset sequence
    STEER1_VALUE := false;
    STEER2_VALUE := false;
    STEER_VALUE := false;
    SPEED_VALUE := 0;
    INIT_TIME := 0;
    % When a RESET happens quit the loop
    do
      % Infinite loop
      loop
        % Get input values
        await [STEER1_SENS or STEER2_SENS or STEER_SENS or LONG_SPEED_FILT or CLOCK_24];
        present STEER1_SENS then
          STEER1_VALUE := ?STEER1_SENS;
        end;
        present STEER2_SENS then
          STEER2_VALUE := ?STEER2_SENS;
        end;
        present STEER_SENS then
          STEER_VALUE := ?STEER_SENS;
        end;
        present LONG_SPEED_FILT then
          SPEED_VALUE := ?LONG_SPEED_FILT;
        end;
        present CLOCK_24 then
          INIT_TIME := INIT_TIME + 1;
        end;
        % Test initial condition
        if ((STEER1_VALUE = false) and (STEER2_VALUE = false) and (STEER_VALUE = false)) then
          % The angle of steer-wheel is 0, test the value of speed
          if (((INIT_TIME < MAX_INIT_TIME) and (SPEED_VALUE > INIT_SPEED1)) or ((INIT_TIME >= MAX_INIT_TIME) and (SPEED_VALUE > INIT_SPEED2))) then
	    % Send initialization signal
            emit INIT;
            % Wait an infinite amount of time, it quits when RESET takes place
            halt;            
          end;
        end;          
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Calculation of angle of steer-wheel:
%
% It gets the steer-wheel sensor's signals and calculates the angle of
% steer-wheel according to the following formula:
%
% ANG := ANG + INCR,
%
% where INCR comes calculated in the following way:
%
% - at the rising edge of STEER1_SENS if STEER1_SENS = STEER2_SENS
%   then INCR := +4.5 degrees else INCR := -4.5 degrees;
% - at the rising edge of STEER2_SENS if STEER1_SENS = STEER2_SENS
%   then INCR := -4.5 degrees else INCR := +4.5 degrees.
%
% The first initial increnment step is +/-2.5 degrees.
% The INIT signal triggers the calculation.
%
% Diagnosis:
%
% If STEER_SENS = 0 then the angle should be in the range of +/- 9
% degrees otherwise it sends an error. Only the RESET signal can bring
% it out from this state.
%
% CONSTANTS:
%
% Name			MIN_ANG_VALUE
% Data size		Signed 16 bit
% Range			127.5 degrees
% Range			+/-16383
% Resolution		0.5 degree/bit
% Function		Minimum angle of steer-wheel when STEER_SENS = 0
% Threshold		- 18 degrees
% Value			- 36
%
% Name			MAX_ANG_VALUE
% Data size		Signed 16 bit
% Range			127.5 degrees
% Range			+/-16383
% Resolution		0.5 degree/bit
% Function		Maximum angle of steer-wheel when STEER_SENS = 0
% Threshold		+ 18 degrees
% Value			36
%
% Name			ANG_INCR
% Data size		Unsigned 8 bit
% Range			127.5 degrees
% Resolution		0.5 degrees/bit
% Function		Angle increment
% Threshold		4.5
% Value			9
%
% Name			ANG_INCR_INIT
% Data size		Unsigned 8 bit
% Range			127.5 degrees
% Resolution		0.5 degrees/bit
% Function		Angle increment
% Threshold		2.5
% Value			5
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_24
% Period		24 msec
% Function		Clock
%
% Name			INIT
% Data size		1 bit
% Range			ON - OFF
% Function		Signals to initializa angle calculation
%
% Name			STEER1_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% Name			STEER2_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% Name			STEER_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% OUTPUTS:
%
% Name			ANG
% Data size		Signed 16 bit
% Range			+/-16383
% Resolution		0.5 degree/bit
% Function		Angle of steer-wheel
%
% Name			CAL_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
module STEER_ANG_CAL_VAL:
input
  RESET,
  CLOCK_24,
  INIT,
  STEER1_SENS(boolean),
  STEER2_SENS(boolean),
  STEER_SENS(boolean);
output
  ANG(integer),
  CAL_ERR;
constant
  MIN_ANG_VALUE : integer,
  MAX_ANG_VALUE : integer,
  ANG_INCR_INIT : integer,
  ANG_INCR : integer;
var
  STEER1_VALUE : boolean,	% Value of sensor
  STEER2_VALUE : boolean,	% Value of sensor
  STEER1_VALUE_OLD : boolean,	% Old value of sensor
  STEER2_VALUE_OLD : boolean,	% Old value of sensor
  STEER_VALUE : boolean,	% Value of sensor
  INCR : integer,		% angle increment
  ANG_VALUE : integer		% Angle value
in
  % Infinite loop
  loop
    % Reset sequence
    STEER1_VALUE := false;
    STEER2_VALUE := false;
    STEER1_VALUE_OLD := false;
    STEER2_VALUE_OLD := false;
    STEER_VALUE := false;
    INCR := ANG_INCR_INIT;
    ANG_VALUE := 0;
    % Wait for initialization
    await INIT;
    % When a RESET happens quit the loop
    do
      % Emit initial value
      emit ANG(ANG_VALUE);
      % Loop for getting signals from sensor and calculates angle
      loop
        % Get signals from sensor
        await [CLOCK_24 or STEER1_SENS or STEER2_SENS or STEER_SENS];
        present STEER1_SENS then
          STEER1_VALUE := ?STEER1_SENS;
          % Test condition of angle increment or decrement
          if ((STEER1_VALUE_OLD = false) and (STEER1_VALUE = true)) then
            % Increment or decrement the value of angle
            if (STEER1_VALUE_OLD = STEER2_VALUE) then
              ANG_VALUE := ANG_VALUE + INCR;
            else
              ANG_VALUE := ANG_VALUE - INCR;
            end;
          end;
          % Memorize its value
          STEER1_VALUE_OLD := STEER1_VALUE;
        end;
        present STEER2_SENS then
          STEER2_VALUE := ?STEER2_SENS;
          % Test condition of angle increment or decrement
          if ((STEER2_VALUE_OLD = false) and (STEER2_VALUE = true)) then
            % Increment or decrement the value of angle
            if (STEER1_VALUE = STEER2_VALUE_OLD) then
              ANG_VALUE := ANG_VALUE - INCR;
            else
              ANG_VALUE := ANG_VALUE + INCR;
            end;
          end;
          % Memorize its value
          STEER2_VALUE_OLD := STEER2_VALUE;
        end;
        present STEER_SENS then
          STEER_VALUE := ?STEER_SENS;
        end;
        % Diagnosis of sensors
        if ((not STEER_VALUE) and ((ANG_VALUE < MIN_ANG_VALUE) or (ANG_VALUE > MAX_ANG_VALUE))) then
          % Emit error
          emit CAL_ERR;
          % Wait an infinite amount of time, it quits when RESET takes place
          halt;
        end;
        % Emit result
        emit ANG(ANG_VALUE);
        % Set normal increment
        INCR := ANG_INCR;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Correction of angle of steer-wheel:
%
% It makes correction of the calculated steer-wheel angle according to
% the following formula:
%
% ZVOL(t) := ZVOL(Kt) + K * (ANG(t) - ZVOL(Kt));
%
% ANG_CORR(t) := ANG(t) + ZVOL(t).
%
% It corrects the angle if LONG_SPEED_FILT > 100 Km/h. K has two
% values according to the current phase:
%
% 1 phase: K := Kz for the first (non continual) 3 minutes;
% 2 phase: K := Ky for the next 20 minutes. After 2 phase comes again.
%
% Diagnosis:
%
% If ZVOL > 20 degrees then it sends an error and stays in halt
% condition until RESET.
%
% CONSTANTS:
%
% Name			Kz
% Data size		Unsigned 8 bit
% Range			0 - 1
% Resolution		0.0039 /bit
% Function		Coefficient
% Threshold		0.0195
% Value			5
%
% Name			T_Kz
% Data size		Unsigned 8 bit
% Range			0 - 6.12
% Resolution		24 msec/bit
% Function		Maximumtime for applying Kz
% Threshold		3 minutes
% Value			7500
%
% Name			MAX_SPEED_VALUE
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Speed threshold for correction
% Threshold		100 Km/h
% Value			25700
%
% Name			MIN_CORR_Kz
% Data size		Signed 16 bit
% Range			+/-65.5 degrees
% Resolution		0.0078 degrees /bit
% Function		Minimum threshold of correction
% Threshold		3 degrees
% Value			384
%
% Name			T_Kt
% Data size		Unsigned 8 bit
% Range			0 - 6.12 sec
% Resolution		24 msec/bit
% Function		Coefficient
% Threshold		2.16 sec
% Value			90
%
% Name			MAX_CORR
% Data size		Signed 16 bit
% Range			+/-65.5 degrees
% Resolution		0.0078 degrees /bit
% Function		Maximum threshold of correction
% Threshold		20 degrees
% Value			2560
%
% Name			Ky
% Data size		Unsigned 8 bit
% Range			0 - 1
% Resolution		0.0039 /bit
% Function		Coefficient
% Threshold		0.0039
% Value			1
%
% Name			T_Ky
% Data size		Unsigned 8 bit
% Range			0 - 6.12
% Resolution		24 msec/bit
% Function		Maximumtime for applying Ky
% Threshold		20 minutes
% Value			50000
%
% Name			MIN_CORR_Ky
% Data size		Signed 16 bit
% Range			+/-65.5 degrees
% Resolution		0.00078 degrees /bit
% Function		Minimum threshold of correction
% Threshold		1 degrees
% Value			128
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			LONG_SPEED_FILT
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Filtered longitudinal speed
%
% Name			ANG
% Data size		Signed 16 bit
% Range			+/-16383
% Resolution		0.5 degree/bit
% Function		Angle of steer-wheel
%
% OUTPUTS:
%
% Name			ANG_CORR
% Data size		Signed 16 bit
% Range			+/-16383
% Resolution		0.5 degree/bit
% Function		Corrected angle of steer-wheel
%
% Name			CORR_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
module STEER_ANG_CORR:
function POLIS_RSH(integer,integer) : integer;
input
  RESET,
  LONG_SPEED_FILT(integer),
  ANG(integer);
output
  ANG_CORR(integer),
  CORR_ERR;
constant
  Kz : integer,
  T_Kz : integer,
  MAX_SPEED_VALUE : integer,
  MIN_CORR_Kz : integer,
  T_Kt : integer,
  MAX_CORR : integer,
  Ky : integer,
  T_Ky : integer,
  MIN_CORR_Ky : integer;
var
  ANG_CORR_VALUE : integer,
  SPEED_VALUE_OLD : integer,
  SPEED_VALUE : integer,
  ANG_VALUE : integer,
  ZVOL : integer,
  ZVOL_Kt : integer,
  ZVOLM : integer,
  K : integer,
  T_K : integer,
  MIN_CORR_K : integer,
  INIT : boolean,
  TIME : integer,
  TIME_Kt : integer
in
  % Infinite loop
  loop
    % Reset sequence
    ANG_CORR_VALUE := 0;
    SPEED_VALUE_OLD := 0;
    SPEED_VALUE := 0;
    ANG_VALUE := 0;
    ZVOL := 0;
    ZVOL_Kt := 0;
    ZVOLM := 0;
    K := Kz;
    T_K := T_Kz;
    MIN_CORR_K := MIN_CORR_Kz;
    % When a RESET happens quit the loop
    do
      loop
        % Emit the result
        emit ANG_CORR(ANG_CORR_VALUE);
        await [LONG_SPEED_FILT or ANG];
        present LONG_SPEED_FILT then
	  % Memorize the old value
	  SPEED_VALUE_OLD := SPEED_VALUE;
	  % Get the new one
          SPEED_VALUE := ?LONG_SPEED_FILT;
	  % Test speed
	  if ((SPEED_VALUE_OLD < MAX_SPEED_VALUE) and (SPEED_VALUE > MAX_SPEED_VALUE)) then
	    % If speed exceeds 100 Km/h then angle correction starts
	    INIT := true;
	    % Reset timers
	    TIME := 0;
	    TIME_Kt := 0;
	  end;
        end;
        present ANG then
          % Get its value
          ANG_VALUE := ?ANG;
          % Test speed
          if (SPEED_VALUE > MAX_SPEED_VALUE) then
	    % Increase timer
            TIME_Kt := TIME_Kt + 1;
	    % Test timer
            if (TIME_Kt = T_Kt) then
	      % Compute correction
	      ZVOL := ZVOL_Kt + K * (ANG_VALUE - POLIS_RSH(ZVOL_Kt,8));
	      % Test correction
              if (ZVOL > MAX_CORR) then
                % If it is greater than maximum emit error
                emit CORR_ERR;
                % Wait an infinite amount of time, it quits when RESET takes place
                halt;
              end;
	      % Memorize the correction
	      ZVOL_Kt := ZVOL; 
	      % Reset timer
	      TIME_Kt := 0;
	    end;
	    % Increase timer
            TIME := TIME + 1;
	    % Test timer
            if (TIME = T_K) then
              % Test correction
              if (ZVOL > MIN_CORR_K) then
	        % If the correction more than the threshold then make it
                ZVOLM := ZVOLM + ZVOL;
		ZVOL_Kt := 0;
	      end;
	      % Test phase
	      if (INIT = true) then
		% Change phase and constants
		INIT := false;
		K := Ky;
		T_K := T_Ky;
		MIN_CORR_K := MIN_CORR_Ky;
	      end;
	      % Reset timer
	      TIME := 0;
            end;
	    % Correct angle
	    ANG_CORR_VALUE := ANG_VALUE + POLIS_RSH(ZVOLM,8);
	  else
	    % If speed condition is not true then do not correct angle
	    ANG_CORR_VALUE := ANG_VALUE;
          end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Diagnosis of sensors of angle of steer-wheel:
%
% It makes the following diagnosis:
%
% If the speed of car is not zero it verifies changes on STEER1_SENS
% and STEER2_SENS.
%
% Test A:
% If there is no changes none of two signals for more than
%
% a. TIME_A_1 (1 minute) ->  MED;
% b. TIME_A_2 (4 minutes) -> HARD;
% c. TIME_A_3 (12 minutes) -> ERROR.
%
% Test B:
% If there is no changes one of two signals for more than
%
% a. TIME_B_1 (2 minutes) -> MED;
% b. TIME_B_2 (8 minutes) -> HARD;
% c. TIME_B_3 (24 minutes) -> ERROR.
%
% CONSTANTS:
%
% Name			TIME_A_1
% Data size		Unsigned 16 bit
% Range			0 - 1572.8 sec
% Resolution		24 msec/bit
% Function		Time threshold for diagnosis
% Threshold		1 minute
% Value			42
%
% Name			TIME_A_2
% Data size		Unsigned 16 bit
% Range			0 - 1572.8 sec
% Resolution		24 msec/bit
% Function		Time threshold for diagnosis
% Threshold		4 minutes
% Value			167
%
% Name			TIME_A_3
% Data size		Unsigned 16 bit
% Range			0 - 1572.8 sec
% Resolution		24 msec/bit
% Function		Time threshold for diagnosis
% Threshold		12 minutes
% Value			500
%
% Name			TIME_B_1
% Data size		Unsigned 16 bit
% Range			0 - 1572.8 sec
% Resolution		24 msec/bit
% Function		Time threshold for diagnosis
% Threshold		2 minutes
% Value			83
%
% Name			TIME_B_2
% Data size		Unsigned 16 bit
% Range			0 - 1572.8 sec
% Resolution		24 msec/bit
% Function		Time threshold for diagnosis
% Threshold		8 minutes
% Value			333
%
% Name			TIME_B_3
% Data size		Unsigned 16 bit
% Range			0 - 1572.8 sec
% Resolution		24 msec/bit
% Function		Time threshold for diagnosis
% Threshold		24 minutes
% Value			1000
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_24
% Period		24 msec
% Function		Clock
%
% Name			STEER1_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulsde from steer-wheel sensor
%
% Name			STEER2_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% Name			LONG_SPEED_FILT
% Data size		Unsigned 16 bit
% Range			0 - 255 Km/h
% Resolution		0.0039 (Km/h)/bit
% Function		Filtered longitudinal speed
%
% OUTPUTS:
%
% Name			DIAG_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
% Name			STEER_ANG_DAMAGE
% Data size		2 bit
% Range			SOFT - MED - HARD
% Function		Signal for set motor condition in the case of errror
%
module STEER_ANG_DIAG:
input
  RESET,
  CLOCK_24,
  STEER1_SENS(boolean),
  STEER2_SENS(boolean),
  LONG_SPEED_FILT(integer);
output
  DIAG_ERR,
  STEER_ANG_DAMAGE(integer);
constant
  SOFT, MED, HARD : integer,
  TIME_A_1 : integer,
  TIME_A_2 : integer,
  TIME_A_3 : integer,
  TIME_B_1 : integer,
  TIME_B_2 : integer,
  TIME_B_3 : integer;
var
  TIME_STEER1 : integer,
  TIME_STEER2 : integer,
  SPEED_VALUE : integer,
  STEER_ANG_DAMAGE_VALUE : integer
in
  % Infinite loop
  loop
    % Reset sequence
    TIME_STEER1 := 0;
    TIME_STEER2 := 0;
    SPEED_VALUE := 0;
    STEER_ANG_DAMAGE_VALUE := SOFT;
    % When a RESET happens quit the loop
    do
      loop
        % Emit output
        emit STEER_ANG_DAMAGE(STEER_ANG_DAMAGE_VALUE);
        % Get input signals
        await
          case LONG_SPEED_FILT do
            % Get its value
            SPEED_VALUE := ?LONG_SPEED_FILT;
            % Test it
            if (SPEED_VALUE = 0) then
              % If speed is 0 then reset timers
              TIME_STEER1 := 0;
              TIME_STEER2 := 0;    
            end;
          case STEER1_SENS do
            % Reset timer
            TIME_STEER1 := 0;
          case STEER2_SENS do
            % Reset timer
            TIME_STEER2 := 0;
          case CLOCK_24 do
            % Increase timer
            TIME_STEER1 := TIME_STEER1 + 1;
            TIME_STEER2 := TIME_STEER2 + 1;
        end;
        % Test timers
        if (((TIME_STEER1 > TIME_A_3) and (TIME_STEER2 > TIME_A_3)) or (TIME_STEER1 > TIME_B_3) or (TIME_STEER1 > TIME_B_3)) then
          % Emit error
          emit DIAG_ERR;
          % Wait an infinite amount of time, it quits when RESET takes place
          halt;
        else
          if (((TIME_STEER1 > TIME_A_2) and (TIME_STEER2 > TIME_A_2)) or (TIME_STEER1 > TIME_B_2) or (TIME_STEER1 > TIME_B_2)) then
            % Set HARD
            STEER_ANG_DAMAGE_VALUE := HARD;
          else
            if (((TIME_STEER1 > TIME_A_1) and (TIME_STEER2 > TIME_A_1)) or (TIME_STEER1 > TIME_B_1) or (TIME_STEER1 > TIME_B_1)) then
              % Set MED
              STEER_ANG_DAMAGE_VALUE := MED;
            else
              % Set SOFT
              STEER_ANG_DAMAGE_VALUE := SOFT;
            end;
          end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Calculation of the speed of steer-wheel rotation:
%
% It calculates the following formula:
%
% SPEED := COANG / TIME_ANG.
%
% CONSTANTS:
%
% Name			COANG
% Data size		24 bit
% Range			0 - 16777216
% Resolution		1
% Function		Constant for speed calculation
% Threshold		9221311
% Value			9221311
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			CLOCK_16
% Period		16 usec
% Function		Sampling frequency of steer-wheel sensor signals
%
% Name			STEER1_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulsde from steer-wheel sensor
%
% Name			STEER2_SENS
% Data size		1 bit
% Resolution		4.5 degress
% Function		Impulse from steer-wheel sensor
%
% OUTPUTS:
%
% Name			SPEED
% Data size		Unsigned 16 bit
% Range			0 - 2000 degrees/sec
% Resolution		0.030 degrees/bit
% Function		Speed of steer-wheel rotation
%
module STEER_SPEED_CAL:
input
  RESET,
  CLOCK_16,
  STEER1_SENS(boolean),
  STEER2_SENS(boolean);
output
  SPEED(integer);
constant
  COANG : integer;
var
  TIME_ANG : integer,
  STEER1_VAL : boolean,
  STEER1_VAL_OLD : boolean,
  STEER2_VAL : boolean,
  STEER2_VAL_OLD : boolean,
  SPEED_VALUE : integer
in
  % Infinite loop
  loop
    % Reset sequence
    TIME_ANG := 0;
    STEER1_VAL := false;
    STEER1_VAL_OLD := false;
    STEER2_VAL := false;
    STEER2_VAL_OLD := false;
    SPEED_VALUE := 0;
    % When a RESET happens quit the loop
    do
      loop
        % Get inputs
        await [CLOCK_16 or STEER1_SENS or STEER2_SENS];
        present CLOCK_16 then
          % Increase time
          TIME_ANG := TIME_ANG + 1;
          emit SPEED(SPEED_VALUE);
        end;
        present STEER1_SENS then
          % Get its value
          STEER1_VAL := ?STEER1_SENS;
          if ((STEER1_VAL_OLD <> STEER1_VAL) and (TIME_ANG <> 0)) then
            % Calculate speed
            SPEED_VALUE := COANG / (TIME_ANG * 2);
            % Delete time
            TIME_ANG := 0;
          end;
          % Memorize its value
          STEER1_VAL_OLD := STEER1_VAL;
        end;
        present STEER2_SENS then
          % Get its value
          STEER2_VAL := ?STEER2_SENS;
          if ((STEER2_VAL_OLD <> STEER2_VAL) and (TIME_ANG <> 0)) then
            % Calculate speed
            SPEED_VALUE := COANG / (TIME_ANG * 2);
            % Delete time
            TIME_ANG := 0;
          end;
          % Memorize its value
          STEER2_VAL_OLD := STEER2_VAL;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Diagnosis of speed of angle of steer-wheel:
%
% If speed is greater than a threshold it does not set motors in SOFT
% condition for a minute. If it occurs more than three times then it
% sends an error.
%
% CONSTANTS:
%
% Name			MAX_SPEED_VAL
% Data size		Unsigned 16 bit
% Range			0 - 2000 degrees/sec
% Resolution		0.030 (degrees/sec)/bit
% Function		Speed of steer-wheel rotation
% Threshold		1900 degrees/sec
% Value			63333
%
% Name			MAX_NUM_SPEED_VAL_OUT
% Data size		Unsigned 8 bit
% Range			0 - 255
% Resolution		1
% Function		Max number of errors
% Threshold		3
% Value			3
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			SPEED
% Data size		Unsigned 16 bit
% Range			0 - 2000 degrees/sec
% Resolution		0.030 (degrees/sec)/bit
% Function		Speed of steer-wheel rotation
%
% OUTPUTS:
%
% Name			STEER_SPEED_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
% Name			STEER_NO_SOFT
% Data size		1 bit
% Range			ON - OFF
% Function		Signal for set motors into not SOFT condition
%
module STEER_SPEED_DIAG:
input
  RESET,
  SPEED(integer);
output
  STEER_NO_SOFT,
  STEER_SPEED_ERR;
constant
  MAX_SPEED_VAL : integer,
  MAX_NUM_SPEED_VAL_OUT : integer;
var
  NUM_SPEED_VAL_OUT : integer,
  SPEED_VALUE : integer
in
  % Infinite loop
  loop
    % Reset sequence
    NUM_SPEED_VAL_OUT := 0;
    SPEED_VALUE := 0;
    % When a RESET happens quit the loop
    do
      loop
        % Get input signals
        await SPEED do
          SPEED_VALUE := ?SPEED;
        end;
        % Test their values
        if (SPEED_VALUE > MAX_SPEED_VAL) then
          % If speed is greater than the enabled value than emit STEER_NO_SOFT
          emit STEER_NO_SOFT;
          % Increase counter
          NUM_SPEED_VAL_OUT := NUM_SPEED_VAL_OUT + 1;
          if (NUM_SPEED_VAL_OUT > MAX_NUM_SPEED_VAL_OUT) then
            % Emit error
            emit STEER_SPEED_ERR;
            % Wait an infinite amount of time, it quits when RESET takes place
            halt;
          end;
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Steer-wheel signal simulation:
%
module STEER_WHEEL:
input
  RESET,
  CLOCK_16,
  ANG_INPUT(integer),
  VELSTER(integer);
output
  STEER1_SENS(boolean),
  STEER2_SENS(boolean),
  STEER_SENS(boolean);
constant
  MINUS_9 :  integer,
  PLUS_9 : integer,
  INCR : integer,
  COANG : integer;
var
  ANG_VAL : integer,
  VELSTER_VAL : integer,
  STR_VAL : boolean,
  STR1_VAL : boolean,
  STR2_VAL : boolean,
  TIME : integer,
  Q_TEANG : integer,
  DIR : integer,
  ANG_CUR : integer
in
  % Infinite loop
  loop
    % Reset sequence
    ANG_VAL := 0;
    VELSTER_VAL := 0;
    STR_VAL := false;
    STR1_VAL := false;
    STR2_VAL := false;
    TIME := 0;
    Q_TEANG := 0;
    DIR := 0;
    ANG_CUR := 0;
    do
      % When a RESET occurs quit loop
      loop
        % Wait for input
	await
	  case CLOCK_16 do
            % Increase the timer
            TIME := TIME + 1;
            % Test timer
            if (TIME > Q_TEANG) then
              % Emit values
              emit STEER_SENS(STR_VAL);
              emit STEER1_SENS(STR1_VAL);
              emit STEER2_SENS(STR2_VAL);
              % If time slot is up then find the slot position
              if (DIR <> 0) then
                if ((not STR1_VAL) and (not STR2_VAL)) then
                  % STR1=L, STR2=L position
                  if ((DIR = 1) or (DIR = 3)) then
                    % Set output signal
                    STR1_VAL := true;
                    % Increment angle
                    ANG_CUR := ANG_CUR + INCR;
                  else
                    % Set output signal
                    STR2_VAL := true;
                    % Decrement angle
                    ANG_CUR := ANG_CUR - INCR;
                  end;
                else
                  if ((not STR1_VAL) and STR2_VAL) then
                    % STR1=L, STR2=H position
                    if ((DIR = 1) or (DIR = 3)) then
                      % Set output signal
                      STR2_VAL := false;
                    else
                      % Set output signal
                      STR1_VAL := true;
                      % Decrement angle
                      ANG_CUR := ANG_CUR - INCR;
                    end;
                  else
                    if (STR1_VAL and (not STR2_VAL)) then
                      % STR1=H, STR2=L position
                      if ((DIR = 1) or (DIR = 3)) then
                        % Set output signal
                        STR2_VAL := true;
                        % Increment angle
                        ANG_CUR := ANG_CUR + INCR;
                      else
                        % Set output signal
                        STR1_VAL := false;
                      end;
                    else
                      % STR1=H, STR2=H position
                      if (DIR = 1) then
                        % Set output signal
                        STR1_VAL := false;
                      else
                        if (DIR = 2) then
                          % Set output signal
                          STR2_VAL := false;
                        else
                          % Set output signal
                          STR1_VAL := false;
                          STR2_VAL := false;
                          if (DIR = 3) then
                            % Set direction
                            DIR := 2;
                          else
                            % Set direction
                            DIR := 1;
                          end;
                        end;
                      end;
                    end;
                  end;
                end;
              end;
              % Reset timer
              TIME := 0;
              if ((ANG_VAL > (ANG_CUR - INCR)) and (ANG_VAL < (ANG_CUR + INCR))) then
                % Stop
                DIR := 0;
              end;
	      % Test whether angle is out of +/- 9 degree
               if ((ANG_CUR <= MINUS_9) or (ANG_CUR >= PLUS_9)) then
                STR_VAL := true;
              else
                % Test whether angle is between +/- 9 degree
                if ((ANG_CUR > MINUS_9) and (ANG_CUR < PLUS_9)) then
                  STR_VAL := false;
                end;
              end;
            end;
          case ANG_INPUT do
            % Get its value
            ANG_VAL := ?ANG_INPUT;
            % Set direction
            if ((DIR = 1) and (ANG_VAL < (ANG_CUR - INCR))) then
              % Decrease
              DIR := 3;
            else
              if ((DIR = 2) and (ANG_VAL > (ANG_CUR + INCR))) then
                % Increase
                DIR := 4;
              else
                if ((ANG_VAL > (ANG_CUR - INCR)) and (ANG_VAL < (ANG_CUR + INCR))) then
                  % Stop
                  DIR := 0;
                else
                  if (ANG_VAL < (ANG_CUR - INCR)) then
                    DIR := 2;
                  else
                    DIR := 1;
                  end;
                end;
              end;
            end;
          case VELSTER do
            % Get its value
            VELSTER_VAL := ?VELSTER;
            % Compute the time between edges
            Q_TEANG := COANG / (2 * VELSTER_VAL);
        end;
      end;
    watching RESET;
  end;
end;
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Vertical acceleration calculation:
%
% It outputs the value of vertical acceleration according to the
% following formule:
%
% ACC = (ACC_SENS - ZERO_ACC) * GME_ACC.
%
% CONSTANTS:
%
% Name			ZERO_ACC
% Data size		Unsigned 8 bit
% Range			0 - 5 V
% Resolution		19 mV/bit
% Function		Reference voltage for 0 g
% Symbolic valuie	2.5 V
% Value			127
%
% Name			GME_ACC
% Data size		Unsigned 16 bit
% Range			0 - 500
% Resolution		0.0076 /bit
% Function		Coefficient
% Symbolic value	1.6
% Value			210
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			ACC_SENS
% Data size		8 bit
% Range:	Voltage level	Value		Function
%		0 - 200 mV	0 - 10		short circuit to GND
%		200 mV - 4.7 V	11 - 239 	functional range
%		4.7 V - 5 V	239 - 255	short circuit to sypply
% Resolution		19 mV
% Rate of sampling	12 msec
% Function		Voltage level of acceleration sensor
%
% OUTPUTS:
%
% Name			ACC
% Data size		Signed 16 bit
% Range			+/- 10 m/sec^2
% Resolution		0.00030 (m/sec^2)/bit
% Function		Vertical acceleration
%
module VER_ACC_CAL:
input
  RESET,
  ACC_SENS(integer);
output
  ACC(integer);
constant
  ZERO_ACC : integer,
  GME_ACC : integer;
var
  ACC_SENS_VAL : integer,	% vertical acceleration sensor value
  ACC_VALUE : integer		% vertical acceleration
in
  % infinite loop
  loop
    % Reset sequence
    ACC_VALUE := 0;
    % When a RESET happens quit loop
    do
      loop
	emit ACC(ACC_VALUE);
        await ACC_SENS;
	% Get the value of vertical acceleration 
        ACC_SENS_VAL := ?ACC_SENS;
        % Compute the value of vertical acceleration
        ACC_VALUE := ( ACC_SENS_VAL - ZERO_ACC) * GME_ACC;
      end;
    watching RESET;
  end
end
.
%  Copyright   [Copyright (c) 1994-1996 The Regents of the Univ. of California.
%  All rights reserved.
%
%  Permission is hereby granted, without written agreement and without license
%  or royalty fees, to use, copy, modify, and distribute this software and its
%  documentation for any purpose, provided that the above copyright notice and
%  the following two paragraphs appear in all copies of this software.
%
%  IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
%  DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
%  OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
%  CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%  THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
%  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
%  FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN
%  "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE
%  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
% Vertical acceleration diagnosis:
%
% It makes diagnosis of vertical acceleration sensor testing the
% following abnormal states:
%
% 1. If (SENS_VAL < MIN_ACC) for more than TIME_OUT time then there
%    is a short circuit to GND.
% 2. If (SENS_VAL > MAX_ACC) for more than TIME_OUT time then there
%    is a short circuit to supply.
% 3. If (SENS_VAL < MIN_R_ACC) or (SENS_VAL > MAX_R_ACC) for more
%    than TIME_R_OUT time then it is out of the real functional range.
%
% After MAX_ABNORM_NUM abnormal states the module sends a VER_ACC_ERR
% signal.
%
% CONSTANTS:
%
% Name		MAX_ACC
% Data size	Unsigned 8 bit
% Range		0 - 5 V
% Resolution	19 mV/bit
% Function	Threshold of acceleration for diagnosis of short circuit to supply
% Threshold	4.7 V
% Value		239
%
% Name		MIN_ACC
% Data size	Unsigned 8 bit
% Range		0 - 5 V
% Resolution	19 mV/bit
% Function	Threshold of acceleration for diagnosis of short circuit to GND
% Threshold	200 mV
% Value		10
%
% Name		MAX_R_ACC
% Data size	Unsigned 8 bit
% Range		0 - 5 V
% Resolution	19 mV/bit
% Function	Threshold of acceleration for diagnosis of real functional range
% Threshold	3.2 V
% Value		168
%
% Name		MIN_R_ACC
% Data size	Unsigned 8 bit
% Range		0 - 5 V
% Resolution	19 mV/bit
% Function	Threshold of acceleration for diagnosis of real functional range
% Threshold	1 V
% Value		52
%
% Name		TIME_OUT
% Data size	Unsigned 8 bit
% Range		0 - 3.072 sec
% Resolution	12 msec/bit
% Function	Time out of diagnosis of short circuit
% Threshold	160 msec
% Value		13
%
% Name		TIME_R_OUT
% Data size	Unsigned 8 bit
% Range		0 - 3.072 sec
% Resolution	12 msec/bit
% Function	Time out of diagnosis of real functional range
% Threshold	2 sec
% Value		166
%
% Name		MAX_ABNORM_NUM
% Data size	Unsigned 8 bit
% Range		0 - 255
% Resolution	1
% Function	Max number of abnormalities
% Threshold	4
% Value		4
%
% INPUTS:
%
% Name			RESET
% Data size		1 bit
% Range			ON - OFF
% Function		Sets the reset sequence
%
% Name			ACC_SENS
% Data size		8 bit
% Range:	Voltage level	Value		Function
%		0 - 200 mV	0 - 10		short circuit to GND
%		200 mV - 4.7 V	11 - 239 	functional range
%		4.7 V - 5 V	239 - 255	short circuit to sypply
% Resolution		19 mV
% Rate of sampling	12 msec
% Function		Voltage level of acceleration sensor
%
% OUTPUTS:
%
% Name			VER_ACC_ERR
% Data size		1 bit
% Range			ON - OFF
% Function		Signals a damage situation
%
module VER_ACC_DIAG:
input
  RESET,
  ACC_SENS(integer);
output
  VER_ACC_ERR;
constant
  ZERO_ACC : integer,
  MAX_ACC : integer,
  MIN_ACC : integer,
  MAX_R_ACC : integer,
  MIN_R_ACC : integer,
  TIME_OUT : integer,
  TIME_R_OUT : integer,
  MAX_ABNORM_NUM : integer;
var
  ACC_OUT_TIME : integer,		% time of out of functional range
  ACC_OUT_R_TIME : integer,	% timer of out of the real functional range
  SENS_VAL : integer,          % vertical acceleration sensor value
  ABNORM_NUM : integer		% number of abnormalities
in
  % infinite loop
  loop
    % Reset sequence
    SENS_VAL := ZERO_ACC;
    ACC_OUT_TIME := 0;
    ACC_OUT_R_TIME := 0;
    ABNORM_NUM := 0;
    % When a RESET happens quit loop
    do
      loop
        await ACC_SENS;
        % Get the value of vertical acceleration 
        SENS_VAL := ?ACC_SENS;
        % Diagnosis of out of the real functional range
        if ((SENS_VAL > MAX_R_ACC) or (SENS_VAL < MIN_R_ACC)) then
          % Increase the timers
          ACC_OUT_R_TIME := ACC_OUT_R_TIME + 1;
          ACC_OUT_TIME := ACC_OUT_TIME + 1;
	  % Test the value of timer
          if ((ACC_OUT_R_TIME >= TIME_R_OUT) or (ACC_OUT_TIME >= TIME_OUT)) then
	    % If it is out of the real func. range  for more than TIME_R_OUT time then increase the number of abnormalities
	    ABNORM_NUM := ABNORM_NUM +1;
            % Start to measure the time again
            ACC_OUT_R_TIME := 0;
            ACC_OUT_TIME := 0;
          end;
        else
          % If the value returned within the normal range then delete the timer
          ACC_OUT_R_TIME := 0;
          % Diagnosis of short circuit
          if ((SENS_VAL > MAX_ACC) or (SENS_VAL < MIN_ACC)) then
            % Increase the timer
            ACC_OUT_TIME := ACC_OUT_TIME + 1;
            % Test the value of timer
            if (ACC_OUT_TIME >= TIME_OUT) then
              % If there is a short circuit for more than TIME_OUT time then increase the number of abnormalities
 	      ABNORM_NUM := ABNORM_NUM +1;
	      % Start to measure the time again
              ACC_OUT_TIME := 0;
            end;
          else
            % If the value returned within the normal range then delete the timer
            ACC_OUT_TIME := 0;
          end;
        end;
        % Test the value of counter of abnormalities
        if (ABNORM_NUM >= MAX_ABNORM_NUM) then
           % Emit event for damage situation
           emit VER_ACC_ERR;
           % Wait an infinite amount of time, it quits when RESET takes place
           halt;
        end;
      end;
    watching RESET;
  end
end
.
