/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 * 
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2015 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.prom.templates

import com.google.common.base.Charsets
import com.google.common.io.Files
import com.google.common.io.LineProcessor
import de.cau.cs.kieler.prom.configurable.ResourceSubstitution
import freemarker.template.Template
import java.io.File
import java.io.IOException
import java.io.StringWriter
import java.util.List
import java.util.Map
import java.util.regex.Pattern
import org.eclipse.core.resources.IFile
import org.eclipse.emf.ecore.EObject
import freemarker.core.ParseException
import com.google.common.base.Strings
import org.eclipse.core.runtime.Path
import de.cau.cs.kieler.prom.PromPlugin
import freemarker.core.InvalidReferenceException
import org.eclipse.xtend.lib.annotations.Accessors

/**
 * This class generates wrapper code for models.
 * Annotations are mapped to macro calls which are injected in the input template.
 * Afterwards the macro calls are evaluated by the template engine and the wrapper code which they define is inserted.
 * 
 * @author aas
 */
class TemplateManager {

    /**
     * A template variable which is replaced with the name of the last analyzed model.
     */
    public static val MODEL_NAME_VARIABLE = "model_name"
    
    /**
     * The variable name in the target template
     * for code generated by KiCo.
     */
    public static val KICO_GENERATED_CODE_VARIABLE = "kico_code"
    
    /**
     * Macro definitions to use <@init>, <@input>, <@output> in wrapper code snippets.
     */
    private static var String macroDefinitions = null
    
    /**
     * An intermediate template that is processed
     */
    @Accessors(PUBLIC_GETTER)
    private static var String templateCodeWithMacroCalls
    
    /**
     * Processes the template context.
     * 
     * @param config The template context
     * @return the code after the template has been processed
     */
    public static def String process(TemplateContext config) {
        if(config.templateFile == null) {
            return ""
        }
        
        // Prepare template engine
        val project = config.templateFile.project
        val templatePath = config.templateFile.projectRelativePath.toOSString
        FreemarkerConfiguration.newConfiguration(project.location.toOSString)
        // The Freemarker template that will be processed 
        var Template template
        // The variables that are set in the template
        val map = newHashMap
        
        // Add additional mappings from configuration
        if(config.additionalMappings !== null) {
            map.putAll(config.additionalMappings)
        }
        
        // Get mapping of macro calls
        templateCodeWithMacroCalls = null
        if(config.macroCallDatas !== null) {
            templateCodeWithMacroCalls = getTemplateCodeWithMacroCalls(config.templateFile, config.macroCallDatas)
            // Add implicit include of assignment macros such as <@init> and <@output>
            FreemarkerConfiguration.stringTemplateLoader.putTemplate("injectionMacros", getOrInitializeMacroDefinitions )
            FreemarkerConfiguration.configuration.addAutoInclude("injectionMacros")
            // Get template with macro calls and now implicitly loaded snippet definitions.
            val tmpFileName = Files.getNameWithoutExtension(config.templateFile.name)+"_WithMacroCalls.ftl"
            template = new Template(tmpFileName, templateCodeWithMacroCalls, FreemarkerConfiguration.configuration)
        } else {
            template = FreemarkerConfiguration.configuration.getTemplate(templatePath)
        }
        // Add the template name, path, location, etc. to the mapping
        var templateFileSubstitution = new ResourceSubstitution("template") {
            override getValue() {
                config.templateFile
            }
        }
        map.putAll(templateFileSubstitution.variableMappings)
        
        // Process the template with the all mappings
        val writer = new StringWriter()
        template.process(map, writer)
        // Return the result
        val text = writer.toString()
        writer.close
        return text
    }

    /**
     * Searches for wrapper code annotations in the models
     * and injects macro calls accordingly in the template.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     * @param annotationDatas The annotations that injected as macro calls
     * @return a String with the input template,
     *         where placeholders for the different phases are replaced with the corresponding macro calls
     *         that have been injected.
     */
    private static def String getTemplateCodeWithMacroCalls(IFile templateFile, List<MacroCallData> macroCallDatas) {
        // Create macro calls from annotations
        val map = getMappingOfPhasePlaceholders(macroCallDatas)
        // Processor that injects macro calls in input template
        val lineProcessor = new LineProcessor<String>() {
            String text = ""
            
            override getResult() {
                return text
            }
            
            override processLine(String line) throws IOException {
                // Replace placeholders in the line
                // Freemarker should process the templates only after the macro calls have been injected.
                // Otherwise things like includes are processed, not needed in this case, yet gone in the next iteration,
                // in which macro calls should be processed.
                // Thus, injecting the macro calls is done here, before Freemarker is used.
                var lineWithoutPlaceholders = line
                for(entry : map.entrySet) {
                    val placeholderRegex = Pattern.quote("${"+entry.key+"}")
                    lineWithoutPlaceholders = lineWithoutPlaceholders.replaceAll(placeholderRegex, entry.value)
                }
                text += lineWithoutPlaceholders+"\n"
                // Continue reading the lines
                return true
            }
        }
        val code = Files.readLines(new File(templateFile.location.toOSString),
                                   Charsets.UTF_8,
                                   lineProcessor)
        return code
    }

    /**
     * Initializes the macro definitions when they are not yet initialized.
     * Afterwards they are returned.
     * 
     * @return the macro definitions of assignment macros such as <@input>
     */
    private static def String getOrInitializeMacroDefinitions() {
        // Initialize if not done yet
        if(macroDefinitions == null){
            macroDefinitions = ""
            
            for(phase : CodeGenerationPhase.phases ){
                for(macro : phase.injectionMacros){
                    macroDefinitions += macro.freeMarkerDefinition
                    macroDefinitions += "\n"
                }                
            }
        }
        return macroDefinitions
    }
    
    /**
     * Creates macro calls from wrapper code annotation datas.
     * 
     * @param annotationDatas List with the datas to generate macro calls for 
     * @return a map where the keys 'inits', 'inputs' and 'outputs'
     *         are mapped to the corresponding macro calls for the given annotations.
     */
    private static def Map<String, String> getMappingOfPhasePlaceholders(MacroCallData... macroCallDatas) {
        val Map<String, String> map = newHashMap
        
        // The assignment macros such as <@init> and <@output> use a variable
        // to determine if their snippet should be inserted.
        for(phase : CodeGenerationPhase.phases) {
            phase.codeToInject = phase.freeMarkerAssignment+"\n"
        }

        // Keep track of the annotations that were already seen before in this collection
        val doneDatas = <MacroCallData> newHashSet
        var isDoneAlready = false
        
        // Add macro calls for annotations to the different phases
        var MacroCallData prev = null; 
        for (data : macroCallDatas) {
            
            isDoneAlready = true
            if (!doneDatas.contains(data)) {
                doneDatas.add(data)
                isDoneAlready = false
            }

            for(phase : CodeGenerationPhase.phases) {
                // We initialize every annotation only once
                // although the same annotation might be used twice: as input and output.
                if(!phase.singleton || (phase.singleton && !isDoneAlready) ) {
                    // Use input annotations on inputs only, and output annotations on outputs only
                    if(phase.isApplicable(data)) {
                        // The macro of this annotation should be called in this phase
                        phase.codeToInject = phase.codeToInject + getTemplateCode(data)
                    }
                }
            }
            prev = data;
        }

        // Send FreeMarker the text to replace the placeholder of each phase
        for(phase : CodeGenerationPhase.phases) {
            map.putAll(phase.injectionMacroMappings)
        }
        return map
    }

    /**
     * Creates meta assignments and macro calls for an wrapper code annotation data.
     * 
     * @param data The annotation data
     * @return a string to set information about the variable which the annotation is used for.
     *         as well as the macro call for the annotation.    
     */
    private static def String getTemplateCode(MacroCallData data) {
        return getMetaAssignments(data) + getMacroCall(data);
    }

    /**
     * Creates a statements that sets meta information about the next variable to be used.
     * 
     * @param data The wrapper code annotation data 
     * @return a string which globally sets meta information.  
     */
    private static def String getMetaAssignments(MacroCallData data) {
        return '''<#assign varName = '«data.varName»' varType = '«data.varType»' />'''+"\n"
    }

    /**
     * Creates a statement that calls a macro to generate code for the wrapper code annotation data.
     * 
     * @param data The wrapper code annotation data
     * @return a string with the macro call for an wrapper code annotation data.
     */
    private static def String getMacroCall(MacroCallData data) {
        var txt = ""
        // Ignore non existing macro <=> only call if macro exists
        if (data.ignoreNonExistingSnippet)
            txt += '''<#if «data.name»??>'''

        txt += '''<@«data.name» '''
        // Append arguments
        var boolean isBooleanArgument
        var boolean isFloatArgument
        for (String arg : data.arguments) {
            isBooleanArgument = (arg.equalsIgnoreCase("true") || arg.equalsIgnoreCase("false"))
            try {
                isFloatArgument = (Float.valueOf(arg) != null)
            } catch (NumberFormatException e) {
                isFloatArgument = false
            }
            val isNonStringArgument = isBooleanArgument || isFloatArgument
            // Only string arguments need to be surrounded by single quotation marks
            if(isNonStringArgument)
                txt += '''«arg» '''   
            else 
                txt += ''''«arg»' '''
        }
        // Close macro call
        txt += '''/>''';

        // Close if
        if (data.ignoreNonExistingSnippet)
            txt += '''</#if>'''
        
        txt += "\n"

        return txt
    }

    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def List<MacroCallData> getAnnotationInterface(EObject model) {
        val allDatas = <MacroCallData> newArrayList
        // Load EObject from file
        if (model != null) {
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : ModelAnalyzer.analyzers) {
                val datas = analyzer.getAnnotationInterface(model)
                if (datas != null) {
                    allDatas.addAll(datas)    
                }
            }
        }
        return allDatas
    }

    /**
     * Looks for the interface (inputs / outputs) in the model
     * and based on this, creates data objects suited for simulation of the model.
     * 
     * @param model The model
     * @param datas List to add found datas objects to
     */
    public static def List<MacroCallData> getSimulationInterface(EObject model) {
        val allDatas = <MacroCallData> newArrayList
        // Load EObject from file
        if (model != null) {
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : ModelAnalyzer.analyzers) {
                val datas = analyzer.getSimulationInterface(model)
                if (!datas.isNullOrEmpty) {
                    allDatas.addAll(datas)    
                }
            }
        }
        return allDatas
    }
    
    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def String getModelName(EObject model) {
        // Load EObject from file
        if (model != null) {
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : ModelAnalyzer.analyzers) {
                val modelName = analyzer.getModelName(model)
                if(modelName != null) {
                    return modelName
                }
            }
        }
    }
}