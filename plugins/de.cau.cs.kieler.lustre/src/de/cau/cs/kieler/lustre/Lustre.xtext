grammar de.cau.cs.kieler.lustre.Lustre with de.cau.cs.kieler.kexpressions.kext.KExt

generate lustre "http://www.cau.de/cs/kieler/lustre/Lustre"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/0.1.0" as kext

/*
 * This implementation of the grammar (except for the automatons) is based on 
 * the Lustre V6 Reference manual. 
 */

LustreProgram hidden(WS, SL_COMMENT, ML_COMMENT):
    ('include' (includes+=STRING | includes+=STRING))*
    (packBody=PackBody | packList=PackList)
;

/*
 * -------------------- PACKLIST
 */
PackList:
    (
        modelDeclarations+=ModelDeclaration
        | packageDeclarations+=PackageDeclaration
        | packageEquations+=PackageEquation
    )+
;

ModelDeclaration:
   'model' name=ID 
   ('uses' usesIds+=ID (',' usesIds+=ID)* ';')?
   'needs' needsParams+=StaticParam (';' needsParams+=StaticParam)* ';'
   ('provides' provisions+=Provide ';' (provisions+=Provide ';')*)?
   'body'
   body=PackBody
   'end'
;

Provide:
    'const' name=ID ':' type=ValueType ('=' value=Expression)?
    | 'type' types=TypeDeclaration
    | (
        ('unsafe')? ('node' | 'function') 
        name=ID 
        ('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')?
        input=Params 'returns' output=Params)
;

PackageDeclaration:
    'package' name=ID 
    ('uses' usesIds+=ID (',' usesIds+=ID)* ';')?
    ('provides' provisions+=Provide ';' (provisions+=Provide ';')*)?
    'body'
    body=PackBody
    'end'
;

PackageEquation:    
    'package' name=ID
    // Lv6 reference manual referes to using 'Eq_Or_Is' which is not defined
    eqOrIs=ID
    '(' byNameStaticArgs+=ByNameStaticArg ((','|';') byNameStaticArgs+=ByNameStaticArg)* ')' ';'  
;

/*
 * -------------------- PACKBODY
 */
PackBody:
    {PackBody}
    (
        ('const' (constants+=VariableDeclaration ';')+)
        | ('type' (types+=TypeDeclaration)+)
        | externals+=ExternalNodeDeclaration
        | nodes+=NodeDeclaration
    )*
;

// Type Declaration
// TODO: This should be a VariableDeclaration too, since it can be a node parameter and thus must be scoped
TypeDeclaration:
    name=ID 
    ('=' 
        (
            type=ValueType
            | type=EnumType '{' enums+=PrimeID (',' enums+=PrimeID)* '}'
            // TODO: StructType may also be left empty
            | type=StructType '{' variables=VariableDeclaration (';' values+=VariableDeclaration)* (';')? '}'
        )
    )?    
    ';'
;

@Override 
enum ValueType returns kexpressions::ValueType:
    BOOL="bool" 
    | INT="int" 
    | FLOAT="real"
;

enum EnumType returns kexpressions::ValueType:
    ENUM="enum" 
;

// External Node Declaration
ExternalNodeDeclaration:
    (isUnsafe?='unsafe')? 'extern' ('function' | hasState?='node') 
    name=ID 
    input=Params
    'returns' 
    output=Params
    (';')?
;

// Node Declaration
NodeDeclaration returns kexpressions::Declaration:
    {NodeDeclaration}
    (isUnsafe?='unsafe')? ('function' | hasState?='node')
    valuedObjects+=NodeValuedObject
    
    // Allows parametric nodes
    ('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')?
    
    (( 
        input=Params 'returns' output=Params
        ( // --- Effective Node (with interface)
            ('=' effectiveNode=NodeReference ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?)
        | // Regular Body
            (
                (';')?
                
                // Local Declarations
                (
                    ('const' constants+=VariableDeclaration ';' (constants+=VariableDeclaration ';')* ) 
                    | 
                    ('var' variables+=ClockedVariableDeclaration (';' variables+=ClockedVariableDeclaration)* ';')
                )*
                
                // Body 
                'let' 
                (
                    equations+=Equation 
                    | assertions+=Assertion 
                    | automatons+=Automaton
                )*
                'tel'
                
                ('.' | (';')?)  
            )
        )
              
    )
    | ( // --- Effective Node (without interface)
        '=' effectiveNode=NodeReference 
        ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?        
    ))
;

NodeValuedObject returns kexpressions::ValuedObject:
    {NodeValuedObject}
    name=ID
;

// Node Declaration - Body Part 1: Equations
Equation returns keffects::Assignment:
    {Equation}
    (
        // Left side: (x, y, ...) or x, y, ... or x 
        ('(' references+=ValuedObjectReference ',' references+=ValuedObjectReference (',' references+=ValuedObjectReference)* ')')
        | (references+=ValuedObjectReference ',' references+=ValuedObjectReference (',' references+=ValuedObjectReference)*)
        | reference=ValuedObjectReference
    )
    operator=AssignOperator 
    expression=Expression   
    ';' 
;

// Node Declaration - Body Part 2: Assertions
Assertion returns kexpressions::Expression:
    {Assertion}
    'assert' expr=Expression ';'
;

// Node Declaration - Body Part 3: Automatons
Automaton:
    'automaton' name=ID states+=AState (states+=AState)* 'returns' '..' ';' 
;

AState:
    (initial?='initial')? 'state' valuedObject=StateValuedObject
    // Local Declarations
    (
        ('const' constants+=VariableDeclaration ';' (constants+=VariableDeclaration ';')* ) 
        | 
        ('var' variables+=ClockedVariableDeclaration (';' variables+=ClockedVariableDeclaration)* ';')
    )*
    
    // Body 
    ('let' 
        (
            equations+=Equation 
            | assertions+=Assertion 
            | automatons+=Automaton
        )*
    'tel')?
    
    ('.' | (';')?)
    transitions+=ATransition*
;

StateValuedObject returns kexpressions::ValuedObject:
    {StateValuedObject}
    name=ID
;

ATransition:
    {ATransition} 
    ('until'|strong?='unless') actions+=AnAction*
;

AnAction:
    ('if' condition=BoolExpression)? ('do' effects+=Equation*)? ('restart'|history?='resume') nextState=[StateValuedObject] ';'
;

/**
 * -------------------- Expression Adjustments
 * 
 * The precedence hierarchy is not as follows:
 * 
 * Expression
 * + BoolExpression
 *   + InitExpression
 *     + TernaryOperation *
 *       + ImpliesExpression
 *         + LogicalXorExpression
 *           + LogicalOrExpression
 *             + LogicalAndExpression
 *               + CompareExpression
 *                 + NotOrValuedExpression
 *                   + ValuedExpression (see valued expression below)
 *                   + NotExpression *
 *                     + AtomicExpression *
 *                       + BoolValue
 *                       + ValuedObjectTestExpression
 *                         + ValuedObjectReference
 *                       + FunctionCall
 *                       + TextExpression
 *                       + NoneOfExpression
 *                       + NorExpression
 * + ValuedExpression
 *   + SumExpression
 *      + ProductExpression
 *                  + IntDivExpression
 *                    + NegExpression *
 *                      + FBYExpression
 *                        + WhenExpression
 *                          + CurrentExpression
 *                            + PreExpression
 *                              + AtomicValuedExpression *
 *                                + IntValue
 *                                + FloatValue
 *                                + StringValue
 *                                + AtomicExpression
 * 
 */
// Needs override because of mod operator is 'mod' not '%' and IntDivExpressin comes next
@Override 
ProductExpression returns kexpressions::Expression:
    IntDivExpression  
    (
    ({kexpressions::OperatorExpression.subExpressions+=current} operator=MultOperator subExpressions+=IntDivExpression ('*' subExpressions+=IntDivExpression)*)
    |
    ({kexpressions::OperatorExpression.subExpressions+=current} operator=DivOperator subExpressions+=IntDivExpression ('/' subExpressions+=IntDivExpression)*)
    |
    ({kexpressions::OperatorExpression.subExpressions+=current} operator=ModOperator subExpressions+=IntDivExpression ('mod' subExpressions+=IntDivExpression)*)
    )*  
;   

IntDivExpression returns kexpressions::Expression:
    NegExpression 
    ({kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=IntDivOperator subExpressions+=NegExpression)
        ('div' subExpressions+=AtomicValuedExpression)*
    )?
;

// Skip TernaryOperation after NegExpression
@Override 
NegExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} operator=SubOperator subExpressions+=(NegExpression)
    | FBYExpression;

// Force WhenExpression, CurrentExpression and PreExpression inbetween FBYExpression and AtomicValuedExpression
FBYExpression returns kexpressions::Expression:
    WhenExpression
    (
        {kexpressions::OperatorExpression.subExpressions+=current}
        (operator=FBYOperator subExpressions+=AtomicValuedExpression)
        ('fby' subExpressions+=AtomicValuedExpression)*
    )?;

WhenExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} subExpressions += AtomicValuedExpression operator=WhenOperator subExpressions += AtomicValuedExpression
    | CurrentExpression;   

CurrentExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} operator=CurrentOperator subExpressions += AtomicValuedExpression
    | PreExpression;

PreExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} operator=PreOperator subExpressions+=AtomicValuedExpression
    | AtomicValuedExpression;

// Force TernaryOperation, InitExpression, ImpliesExpression and LogicalXorExpression inbetween BoolExpression and LogicalOrExpression
@Override
BoolExpression returns kexpressions::Expression: 
    InitExpression;

@Override    
InitExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} subExpressions += TernaryOperation operator=InitOperator subExpressions += TernaryOperation
    | TernaryOperation;   

// Overwide Ternary operator to support if ... then ... else
@Override 
TernaryOperation returns kexpressions::Expression:
    {kexpressions::OperatorExpression} 
    operator=ConditionalOperator subExpressions += TernaryOperation 'then' subExpressions += TernaryOperation 'else' subExpressions += TernaryOperation
    | 
    ImpliesExpression;

ImpliesExpression returns kexpressions::Expression:
    LogicalXorExpression
    (
        {kexpressions::OperatorExpression.subExpressions+=current}
        (operator=ImpliesOperator subExpressions+=LogicalXorExpression)
        ('=>' subExpressions+=LogicalXorExpression)*
    )?;
    
LogicalXorExpression returns kexpressions::Expression:
    LogicalOrExpression
    (
        {kexpressions::OperatorExpression.subExpressions+=current}
        (operator=LogicalXorOperator subExpressions+=LogicalOrExpression)
        ('xor' subExpressions+=LogicalOrExpression)*
    )?;
    
// Override LogicalAndExpresssion and LogicalOrExpression to allow asssociativity
@Override 
LogicalOrExpression returns kexpressions::Expression:
    LogicalAndExpression 
    ({kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=LogicalOrOperator subExpressions+=LogicalAndExpression)
        ('or' subExpressions+=LogicalAndExpression)*
    )?;

// Directly redirect to CompareOperation to exclude the bitwise operations
@Override 
LogicalAndExpression returns kexpressions::Expression:
    CompareOperation 
    ({kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=LogicalAndOperator subExpressions+=CompareOperation)
        ('and' subExpressions+=CompareOperation)*
    )?;

// Directly redirect to SumExpression to exclude shift operations
@Override
ValuedExpression returns kexpressions::Expression:
    SumExpression;

// Exclude FunctionCall, RandomCall, RandomizeCall and TextExpression
@Override
AtomicExpression returns kexpressions::Expression:
    BoolValue
    | '(' BoolExpression ')'
    | ReferenceCall
    | ValuedObjectTestExpression // Last to allow detection of calls
    | NorAtMostOneExpression
    ;

NorAtMostOneExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression}
    (operator=AtMostOneOperator | operator=NorOperator)
    '('
    subExpressions+=Expression (',' subExpressions+=Expression)*
    ')'
;

// Exclude BitwiseNotExpression
@Override 
NotExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} operator=NotOperator subExpressions+=(NotExpression)
    | AtomicExpression
;

/**
 * -------------------- Operator Adjustments
 */
// Override operators that are different in Lustre 
@Override 
enum AssignOperator returns keffects::AssignOperator:
    // Reduce possible assignments to only work with '='
    ASSIGN="=";
    
@Override 
enum CompareOperator returns kexpressions::OperatorType:
    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";

@Override 
enum LogicalOrOperator returns kexpressions::OperatorType:
    LOGICAL_OR="or";

@Override 
enum LogicalAndOperator returns kexpressions::OperatorType:
    LOGICAL_AND="and";

@Override 
enum NotOperator returns kexpressions::OperatorType:
    NOT="not";

enum FBYOperator returns kexpressions::OperatorType:  
    FBY="fby";

@Override 
enum ModOperator returns kexpressions::OperatorType:  
    MOD="mod";

// Define operators that are Lustre specific
enum CurrentOperator returns kexpressions::OperatorType:  
    CURRENT="current";
    
enum WhenOperator returns kexpressions::OperatorType:  
    WHEN="when";

@Override 
enum InitOperator returns kexpressions::OperatorType:  
    INIT="->";

enum LogicalXorOperator returns kexpressions::OperatorType:  
    LOGICAL_XOR="xor";

enum ImpliesOperator returns kexpressions::OperatorType:  
    IMPLIES="=>";

enum IntDivOperator returns kexpressions::OperatorType:  
    INTDIV="div";

@Override 
enum ConditionalOperator returns kexpressions::OperatorType:
    CONDITIONAL = "if";

enum AtMostOneOperator returns kexpressions::OperatorType:  
    ATMOSTONEOF="#";

enum NorOperator returns kexpressions::OperatorType:  
    NOR="nor";

 
/**
 * -------------------- Variable parameter types.
 */ 
 
// Used everywhere where there need to be parameter
Params:
    {Params} 
    (
        ('(' (parameter+=VariableDeclaration (';' parameter+=VariableDeclaration)*)? ')')
        | '()'
    )
;

// Declarations and used within << ... >>
// Examples: type test
//           const a : int
//           node ydd( ) returns( )
StaticParam:
    'type' name=ID
    | 'const' name=ID ':' type=ValueType
    | ('unsafe')? ('node'|'function') name=ID nodeInput=Params 'returns' nodeOutput=Params
;

// Calls and used within << ... >>
StaticArg:
    'type' type=ValueType
    | 'const' expr=Expression
    | ('node'|'function') name=NodeReference ('<<' staticArgs+=StaticArg ((';'|',') staticArgs+=StaticArg)* '>>')?      
//    | PredefOp
//    | SimpleExpr
//    | SurelyType
//    | SurelyNode
;

// Used in package equation
// Examples: const ddd = 5
//           type three = bool
//           node whatever = He::ne<<type b; const 6, node b>>
ByNameStaticArg:  
    ('type' name=ID '=' type=ValueType)
    | ('const' name=ID '=' expr=Expression)
//    | (('function' | 'node') name=ID '=' (nodePath=ID '::')? nodeRef=ID ('<<' staticArgs+=StaticArg ((';'|',') staticArgs+=StaticArg)* '>>')?)
    | (name=ID '=' /*(PredefOp | SimpleExpr | SurelyType | SurelyNode))*/ )    
;

/**
 * -------------------- Variable declaration
 */
@Override 
VariableDeclaration returns kexpressions::VariableDeclaration:
    // TODO: Constants use this too, and they may be declared without specifying a type.
    // This is not possible at the moment.
    (
        valuedObjects+=LustreValuedObjectInit
        |
        valuedObjects+=LustreValuedObjectList (',' valuedObjects+=LustreValuedObjectList)* ':' type=ValueType
    )
;

LustreValuedObjectInit returns kexpressions::ValuedObject:
    {LustreValuedObject}
    annotations+=QuotedStringAnnotation*
    name=PrimeID
    ('^' cardinalities+=Expression)*
    (':' type=ValueType)
    ('=' initialValue=Expression)
;

LustreValuedObjectList returns kexpressions::ValuedObject:
    annotations+=QuotedStringAnnotation*
    name=PrimeID
    ('^' cardinalities+=Expression)*
;

ClockedVariableDeclaration: 
    vardecl=VariableDeclaration ('when' clockExpr=BoolExpression)?
;

NodeReference returns kexpressions::ValuedObjectReference:
    {NodeReference}
    valuedObject=[NodeValuedObject]    
;

/*
 * -------------------- Lexical tokens
 */
@Override 
terminal ML_COMMENT: 
    '(*' -> '*)'
;
 
@Override 
terminal SL_COMMENT: 
    '--' !('\n'|'\r')* ('\r'? '\n')?
;