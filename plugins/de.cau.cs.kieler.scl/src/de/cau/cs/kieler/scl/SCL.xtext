grammar de.cau.cs.kieler.scl.SCL with de.cau.cs.kieler.kexpressions.kext.KExt
  
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/0.1.0" as kext
import "http://kieler.cs.cau.de/scl/0.2.0"

SCLProgram returns SCLProgram:
    pragmas+=Pragma*
    modules+=Module*
;

Module returns Module:
    (annotations += Annotation)*
    'module' name = ID ':'?
    (declarations += Declaration)*
    (statements += Statement)*
;

Statement returns Statement:
    SclAssignment | SclPostfixAssignment | Label | Conditional | LegacyConditional | Goto | Parallel | Pause | ModuleCall | ScopeStatement
;

Pause returns Pause:
    {Pause}
    (annotations += Annotation)*
    'pause'
    semicolon?=';'?
;

Label returns Label:
    (annotations += Annotation)*
    name = ID ':'
;

Goto returns Goto:
    (annotations += Annotation)*
    'goto' target = [Label|ID]
    semicolon?=';'?
;

SclAssignment returns Assignment:
    (annotations += Annotation)*
    reference = ValuedObjectReference
    operator = AssignOperator
    expression = Expression
    ('schedule' schedule+=ScheduleObjectReference+)?
    semicolon?=';'?
;

SclPostfixAssignment returns Assignment:
    (annotations+=Annotation)*    
    reference=ValuedObjectReference
    operator=PostfixOperator
    ('schedule' schedule+=ScheduleObjectReference+)?
    semicolon?=';'?
;

Return returns Return:
    (annotations += Annotation)*
    'return'
    expression = Expression
;

Conditional returns Conditional: 
    (annotations += Annotation)*
    'if' expression = BoolExpression
    '{'
    (declarations+=Declaration)*
    (statements += Statement)*
    '}'
    (else = ElseScope | semicolon?=';')?
;

ElseScope returns ElseScope:
    {ElseScope}
    (annotations += Annotation)*
    'else' '{'
    (declarations+=Declaration)*
    (statements += Statement)*      
    '}'
    semicolon?=';'?
;

LegacyConditional returns Conditional: 
    (annotations += Annotation)*
    'if' expression = BoolExpression
    'then'
    (statements += Statement)*
    ( 'end' semicolon?=';'? | (else = LegacyElseScope))
;

LegacyElseScope returns ElseScope:
    {ElseScope}
    (annotations += Annotation)*
    'else'
    (statements += Statement)*      
    'end'
    semicolon?=';'?
;

Thread returns Thread:
    {Thread}
    (
        (
            (annotations += Annotation)*
            '{'
            (declarations+=Declaration)*
            (statements += Statement)*
            '}'
        ) | (
            (statements += Statement)*
        )
    )
;

Parallel returns Parallel:
    'fork'
    (
        threads += Thread
        (
            'par'
            threads += Thread
        )*
    )
    'join'
    semicolon?=';'?
;

ScopeStatement returns ScopeStatement:
    {ScopeStatement}
    (annotations += Annotation)*
    '{'
        (declarations+=Declaration)*
        (statements += Statement)*
    '}'
;

ModuleCall returns ModuleCall:
    (annotations += Annotation)*
    'run'
    module = [Module|ID]
    ('(' parameters += Parameter (',' parameters += Parameter)* ')' | '()')?
    semicolon?=';'?
;
    
Parameter returns kexpressions::Parameter:
    ((pureOutput ?= '!')? callByReference ?= '&')?
    expression = Expression
    ('to' explicitBinding = [kexpressions::ValuedObject|ID] ('[' explicitBindingIndices+=Expression ']')*)?
;    