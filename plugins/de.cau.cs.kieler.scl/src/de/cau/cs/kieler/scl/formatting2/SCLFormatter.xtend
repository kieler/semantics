/*
 * generated by Xtext
 */
package de.cau.cs.kieler.scl.formatting2;

import com.google.inject.Inject;
import de.cau.cs.kieler.annotations.Annotation;
import de.cau.cs.kieler.annotations.Pragma;
import de.cau.cs.kieler.kexpressions.Declaration;
import de.cau.cs.kieler.kexpressions.Expression;
import de.cau.cs.kieler.kexpressions.ScheduleObjectReference;
import de.cau.cs.kieler.kexpressions.kext.formatting2.KExtFormatter;
import de.cau.cs.kieler.scl.Assignment;
import de.cau.cs.kieler.scl.Conditional;
import de.cau.cs.kieler.scl.ElseScope;
import de.cau.cs.kieler.scl.Label;
import de.cau.cs.kieler.scl.Module;
import de.cau.cs.kieler.scl.Parallel;
import de.cau.cs.kieler.scl.Pause;
import de.cau.cs.kieler.scl.SCLProgram;
import de.cau.cs.kieler.scl.ScopeStatement;
import de.cau.cs.kieler.scl.Statement;
import de.cau.cs.kieler.scl.services.SCLGrammarAccess;
import org.eclipse.xtext.formatting2.IFormattableDocument;

class SCLFormatter extends KExtFormatter {
	
	@Inject extension SCLGrammarAccess

	def dispatch void format(SCLProgram sclprogram, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Pragma pragmas : sclprogram.getPragmas()) {
			format(pragmas, document);
            pragmas.append[ newLine ]
		}
		for (Module modules : sclprogram.getModules()) {
			format(modules, document);
            modules.append[ newLine ]
		}
	}

	def dispatch void format(Module module, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : module.getAnnotations()) {
			format(annotations, document);
		}
		for (Declaration declarations : module.getDeclarations()) {
			format(declarations, document);
		}
		for (Statement statement : module.getStatements()) {
			format(statement, document);
		}
		
		module.regionFor.keyword(moduleAccess.colonKeyword_3).prepend[ noSpace ].append[ newLine ]
        module.regionFor.keywords(moduleAccess.semicolonKeyword_5_0_1).forEach[prepend[ noSpace ].append[ newLine ]]
	}

	def dispatch void format(Pause pause, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : pause.getAnnotations()) {
			format(annotations, document);
		}
	}

	def dispatch void format(Label label, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : label.getAnnotations()) {
			format(annotations, document);
		}
		
        label.regionFor.keyword(labelAccess.colonKeyword_1_1).prepend[ noSpace ].append[ newLine ]
	}

	def dispatch void format(Assignment assignment, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		super.format(assignment as de.cau.cs.kieler.kexpressions.keffects.Assignment, document)
	}

	def dispatch void format(Conditional conditional, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : conditional.getAnnotations()) {
			format(annotations, document);
		}
		format(conditional.getExpression(), document);
		for (Declaration declarations : conditional.getDeclarations()) {
			format(declarations, document);
		}
		for (Statement statements : conditional.getStatements()) {
			format(statements, document);
		}
		format(conditional.getElse(), document);

        conditional.regionFor.keywords(conditionalAccess.semicolonKeyword_3_3_0_1).forEach[prepend[ noSpace ].append[ newLine ]]
        conditional.regionFor.keywordPairs("{", "}").head?.interior[ indent ]
	}

	def dispatch void format(ElseScope elsescope, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : elsescope.getAnnotations()) {
			format(annotations, document);
		}
		for (Declaration declarations : elsescope.getDeclarations()) {
			format(declarations, document);
		}
		for (Statement statements : elsescope.getStatements()) {
			format(statements, document);
		}
		
		elsescope.regionFor.keywords(elseScopeAccess.semicolonKeyword_5_0_1).forEach[prepend[ noSpace ].append[ newLine ]]
        elsescope.regionFor.keywordPairs("{", "}").head?.interior[ indent ]
	}

	def dispatch void format(de.cau.cs.kieler.scl.Thread thread, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : thread.getAnnotations()) {
			format(annotations, document);
		}
		for (Declaration declarations : thread.getDeclarations()) {
			format(declarations, document);
		}
		for (Statement statements : thread.getStatements()) {
			format(statements, document);
		}
		
		thread.regionFor.keywords(conditionalAccess.semicolonKeyword_3_3_0_1).forEach[prepend[ noSpace ].append[ newLine ]]
        thread.regionFor.keywordPairs("{", "}").head?.interior[ indent ]
	}

	def dispatch void format(Parallel parallel, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (de.cau.cs.kieler.scl.Thread threads : parallel.getThreads()) {
			format(threads, document);
		}
	}

	def dispatch void format(ScopeStatement scopestatement, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		for (Annotation annotations : scopestatement.getAnnotations()) {
			format(annotations, document);
		}
		for (Declaration declarations : scopestatement.getDeclarations()) {
			format(declarations, document);
		}
		for (Statement statements : scopestatement.getStatements()) {
			format(statements, document);
		}
		
		scopestatement.regionFor.keywords(scopeStatementAccess.semicolonKeyword_4_0_1).forEach[prepend[ noSpace ].append[ newLine ]]
        scopestatement.regionFor.keywordPairs("{", "}").head?.interior[ indent ]
	}
}
