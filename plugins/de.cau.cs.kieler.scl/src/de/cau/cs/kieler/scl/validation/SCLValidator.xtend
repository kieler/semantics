/*
 * generated by Xtext
 */
package de.cau.cs.kieler.scl.validation

import com.google.inject.Inject
import de.cau.cs.kieler.kexpressions.TextExpression
import de.cau.cs.kieler.kexpressions.ValueType
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsValuedObjectExtensions
import de.cau.cs.kieler.kexpressions.keffects.Assignment
import de.cau.cs.kieler.kexpressions.kext.ClassDeclaration
import de.cau.cs.kieler.scl.Conditional
import de.cau.cs.kieler.scl.Label
import de.cau.cs.kieler.scl.MethodImplementationDeclaration
import de.cau.cs.kieler.scl.Parallel
import de.cau.cs.kieler.scl.Pause
import de.cau.cs.kieler.scl.Return
import de.cau.cs.kieler.scl.SCLProgram
import de.cau.cs.kieler.scl.SCLResource
import de.cau.cs.kieler.scl.Statement
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import de.cau.cs.kieler.kexpressions.AccessModifier
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsDeclarationExtensions
import de.cau.cs.kieler.kexpressions.ReferenceDeclaration
import de.cau.cs.kieler.kexpressions.kext.extensions.KExtEnumExtensions
import de.cau.cs.kieler.kexpressions.OperatorExpression
import de.cau.cs.kieler.kexpressions.StaticAccessExpression

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SCLValidator extends AbstractSCLValidator {
    
    public static val DUBLICATE_LABEL = "Duplicate label"
    public static val LEAGACY_CONDITIONAL = "This conditional uses legacy syntax. Please use if {...} else {...} instead."
    public static val RETURN_NOT_IN_METHOD = "Return statements can only be used in method bodies."
    public static val RETURN_NO_TYPE = "Return statement is used but no return type is declared in method signature."
    public static val RESTRICTED_METHOD_STATEMENTS = "This statement is not allowed in method bodies."
    
    static val String NO_ASSIGNMENTS_TO_CLASS = "Assignments to class/struct types are not supported. Please specify a member."
    static val String NO_REFERENCE_TO_CLASS = "Referencing class/struct types is not supported. Please specify a member."  
    
    static val String CLASS_NO_NAME = "A class/struct must have a unique name."
    static val String CLASS_NO_VO = "A class/struct should have at least one variable defined (Type definitions are not supported)."
    static val String CLASS_INIT = "Composed types (class/struct) cannot be initialized. Please initialize each field individually."
    
    static val String ENUM_INIT = "An enum typed variable can only be initialized with a value of the correct enum type."
    static val String ENUM_ASSIGN = "Cannot assign enum value of an incompatible type."
    
    @Inject extension KExpressionsDeclarationExtensions
    @Inject extension KExpressionsValuedObjectExtensions
    @Inject extension KExtEnumExtensions

    @Check
    def checkEnumTypeCompatibility(ReferenceDeclaration decl) {
        if (decl?.isEnumRef) {
            val enumType = decl.referencedEnum
            for (vo : decl.valuedObjects) {
                if (vo.initialValue !== null && !(vo.initialValue instanceof TextExpression)) {
                    val ini = vo.initialValue
                    val enumVal = if (ini instanceof ValuedObjectReference) {
                        ini.lowermostReference
                    } else if (ini instanceof StaticAccessExpression) {
                        ini.subReference.lowermostReference
                    }
                    if (enumVal !== null) {
                        if (!enumVal.isEnumValue || enumVal.valuedObject.declaration.enclosingClass !== enumType) {
                            error(ENUM_INIT, vo.initialValue, null, -1) 
                        }
                    } else {
                        error(ENUM_INIT, vo.initialValue, null, -1) 
                    }
                }
            }
        }
    }

    @Check
    def checkEnumTypeCompatibility(Assignment asm) {
        if (asm?.reference?.lowermostReference?.isEnumRef) {
            val targetType = asm?.reference?.lowermostReference?.valuedObject?.declaration?.referencedEnum
            val exp = asm.expression
            val enumVal = if (exp instanceof ValuedObjectReference) {
                exp.lowermostReference
            } else if (exp instanceof StaticAccessExpression) {
                exp.subReference.lowermostReference
            }
            if (enumVal !== null) {
                if (!enumVal.isEnumValue || enumVal.valuedObject.declaration.enclosingClass !== targetType) {
                    error(ENUM_ASSIGN, exp, null, -1) 
                }
            } else {
                error(ENUM_ASSIGN, exp, null, -1) 
            }
        }
    }

    @Check
    def checkClassDeclaration(ClassDeclaration decl) {
        if (decl.type === ValueType.STRUCT || decl.type === ValueType.CLASS) {
            if (decl.name.nullOrEmpty) {
                error(CLASS_NO_NAME, decl, null, -1)
            }
            if (decl.valuedObjects.nullOrEmpty) {
                warning(CLASS_NO_VO, decl, null, -1)
            } else {
                for (vo : decl.valuedObjects) {
                    if (vo.initialValue !== null && !(vo.initialValue instanceof TextExpression)) {
                        error(CLASS_INIT, vo.initialValue, null, -1)
                    }
                }
            }
        }
    }
    
    @Check
    def checkClassReferenceDeclaration(ReferenceDeclaration decl) {
        val rDecl = decl.reference
        if (rDecl instanceof ClassDeclaration) {
            if (rDecl.type === ValueType.STRUCT || rDecl.type === ValueType.CLASS) {
                for (vo : decl.valuedObjects) {
                    if (vo.initialValue !== null && !(vo.initialValue instanceof TextExpression)) {
                        error(CLASS_INIT, vo.initialValue, null, -1)
                    }
                }
            }
        }
    }

    @Check
    def checkClassReference(ValuedObjectReference ref) {
        val decl = ref.valuedObject?.eContainer
        if (decl instanceof ClassDeclaration) {
            if (decl.isClass && ref.subReference === null && !(ref.eContainer instanceof ValuedObjectReference)) {
                error(NO_REFERENCE_TO_CLASS, ref, null, -1)
            }
        }
        if (decl instanceof ReferenceDeclaration) {
            val rDecl = decl.reference
            if (rDecl instanceof ClassDeclaration) {
                if (rDecl.isClass && ref.subReference === null && !(ref.eContainer instanceof ValuedObjectReference)) {
                    error(NO_REFERENCE_TO_CLASS, ref, null, -1)
                }
            }
        }
    }
    
    @Check
    def void checkReferenceAssignment(Assignment asm) {
        val decl = asm.reference?.valuedObject?.eContainer
        if (decl instanceof ClassDeclaration) {
            if (decl.isClass && asm.reference.subReference === null && !(asm.expression instanceof TextExpression)) {
                error(NO_ASSIGNMENTS_TO_CLASS, asm.reference, null, -1)
            }
        }
        if (decl instanceof ReferenceDeclaration) {
            val rDecl = decl.reference
            if (rDecl instanceof ClassDeclaration) {
                if (rDecl.isClass && asm.reference.subReference === null && !(asm.expression instanceof TextExpression)) {
                    error(NO_REFERENCE_TO_CLASS, asm.reference, null, -1)
                }
            }
        }
    }

    @Check
    def checkReturn(Return ret) {
        var container = ret.eContainer
        while(container !== null) {
            if(container instanceof MethodImplementationDeclaration) {
                if (container.returnType === null || container.returnType === ValueType.PURE || container.returnType === ValueType.VOID) {
                    error(RETURN_NO_TYPE, ret, null, -1)
                }
                return
            }
            container = container.eContainer
        }
        error(RETURN_NOT_IN_METHOD, ret, null, -1)
    }
    
    @Check
    def checkMethod(MethodImplementationDeclaration method) {
        for (stm : method.eAllContents.filter(Statement).toIterable) {
            if (stm instanceof Pause || stm instanceof Parallel) {
                error(RESTRICTED_METHOD_STATEMENTS, stm, null, -1)
            }
        }
    }

     /*
     * Checks if labels are unique
     */
    @Check
    def checkUniqueLabel(SCLProgram program) {
        for(module : program.modules) {
            module.eAllContents().filter(Label).groupBy[name].forEach[name, labels|
                if (labels.size > 1) {
                    labels.forEach[error(DUBLICATE_LABEL, it, null, -1)]
                }
            ]
        }
    }
    
     /*
     * Checks legacy conditionals
     */
    @Check(CheckType.NORMAL)
    def checkLegacyConditional(SCLProgram program) {
        val res = program.eResource
        if (res instanceof SCLResource) {
            val conditionals = res.parseResult.rootNode.asTreeIterable.filter[semanticElement instanceof Conditional].groupBy[semanticElement]
            for (cond : conditionals.keySet) {
                if (conditionals.get(cond).filter[grammarElement instanceof Keyword].exists["then".equals((grammarElement as Keyword).value)]) {
                    info(LEAGACY_CONDITIONAL, cond, null)
                }
            }
        }
    }

}
