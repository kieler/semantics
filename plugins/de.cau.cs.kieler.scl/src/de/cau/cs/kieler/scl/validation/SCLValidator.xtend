/*
 * generated by Xtext
 */
package de.cau.cs.kieler.scl.validation

import com.google.inject.Inject
import de.cau.cs.kieler.kexpressions.TextExpression
import de.cau.cs.kieler.kexpressions.ValueType
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsValuedObjectExtensions
import de.cau.cs.kieler.kexpressions.keffects.Assignment
import de.cau.cs.kieler.kexpressions.kext.ClassDeclaration
import de.cau.cs.kieler.scl.Conditional
import de.cau.cs.kieler.scl.Label
import de.cau.cs.kieler.scl.MethodImplementationDeclaration
import de.cau.cs.kieler.scl.Parallel
import de.cau.cs.kieler.scl.Pause
import de.cau.cs.kieler.scl.Return
import de.cau.cs.kieler.scl.SCLProgram
import de.cau.cs.kieler.scl.SCLResource
import de.cau.cs.kieler.scl.Statement
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SCLValidator extends AbstractSCLValidator {
    
    public static val DUBLICATE_LABEL = "Duplicate label"
    public static val LEAGACY_CONDITIONAL = "This conditional uses legacy syntax. Please use if {...} else {...} instead."
    public static val RETURN_NOT_IN_METHOD = "Return statements can only be used in method bodies."
    public static val RETURN_NO_TYPE = "Return statement is used but no return type is declared in method signature."
    public static val RESTRICTED_METHOD_STATEMENTS = "This statement is not allowed in method bodies."
    
    static val String NO_ASSIGNMENTS_TO_CLASS = "Assignments to class/struct types are not supported. Please specify a member."
    static val String NO_REFERENCE_TO_CLASS = "Referencing class/struct types is not supported. Please specify a member."  
    
    static val String CLASS_NO_NAME = "A class/struct must have a unique name."
    static val String CLASS_NO_VO = "A class/struct should have at least one variable defined (Type definitions are not supported)."

    @Check
    def checkClassDeclaration(ClassDeclaration decl) {
        if (decl.name.nullOrEmpty) {
            error(CLASS_NO_NAME, decl, null, -1)
        }
        if (decl.valuedObjects.nullOrEmpty) {
            warning(CLASS_NO_VO, decl, null, -1)
        }
    }

    @Check
    def checkClassReference(ValuedObjectReference ref) {
        val decl = ref.valuedObject?.eContainer
        if (decl instanceof ClassDeclaration) {
            if (ref.subReference === null && !(ref.eContainer instanceof ValuedObjectReference)) {
                error(NO_REFERENCE_TO_CLASS, ref, null, -1)
            }
        }
    }
    
    @Check
    def void checkReferenceAssignment(Assignment asm) {
        val decl = asm.reference?.valuedObject?.eContainer
        if (decl instanceof ClassDeclaration) {
            if (asm.reference.subReference === null && !(asm.expression instanceof TextExpression)) {
                error(NO_ASSIGNMENTS_TO_CLASS, asm.reference, null, -1)
            }
        }
    }

    @Check
    def checkReturn(Return ret) {
        var container = ret.eContainer
        while(container !== null) {
            if(container instanceof MethodImplementationDeclaration) {
                if (container.returnType === null || container.returnType === ValueType.PURE || container.returnType === ValueType.VOID) {
                    error(RETURN_NO_TYPE, ret, null, -1)
                }
                return
            }
            container = container.eContainer
        }
        error(RETURN_NOT_IN_METHOD, ret, null, -1)
    }
    
    @Check
    def checkMethod(MethodImplementationDeclaration method) {
        for (stm : method.eAllContents.filter(Statement).toIterable) {
            if (stm instanceof Pause || stm instanceof Parallel) {
                error(RESTRICTED_METHOD_STATEMENTS, stm, null, -1)
            }
        }
    }

     /*
     * Checks if labels are unique
     */
    @Check
    def checkUniqueLabel(SCLProgram program) {
        for(module : program.modules) {
            module.eAllContents().filter(Label).groupBy[name].forEach[name, labels|
                if (labels.size > 1) {
                    labels.forEach[error(DUBLICATE_LABEL, it, null, -1)]
                }
            ]
        }
    }
    
     /*
     * Checks legacy conditionals
     */
    @Check(CheckType.NORMAL)
    def checkLegacyConditional(SCLProgram program) {
        val res = program.eResource
        if (res instanceof SCLResource) {
            val conditionals = res.parseResult.rootNode.asTreeIterable.filter[semanticElement instanceof Conditional].groupBy[semanticElement]
            for (cond : conditionals.keySet) {
                if (conditionals.get(cond).filter[grammarElement instanceof Keyword].exists["then".equals((grammarElement as Keyword).value)]) {
                    info(LEAGACY_CONDITIONAL, cond, null)
                }
            }
        }
    }

}
