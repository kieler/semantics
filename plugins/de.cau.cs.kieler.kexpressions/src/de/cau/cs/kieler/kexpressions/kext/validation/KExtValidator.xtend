/*
 * generated by Xtext
 */
package de.cau.cs.kieler.kexpressions.kext.validation

import com.google.inject.Inject
import de.cau.cs.kieler.annotations.StringAnnotation
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.IntValue
import de.cau.cs.kieler.kexpressions.StaticAccessExpression
import de.cau.cs.kieler.kexpressions.Value
import de.cau.cs.kieler.kexpressions.ValueType
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.VectorValue
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsDeclarationExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsValuedObjectExtensions
import de.cau.cs.kieler.kexpressions.keffects.Assignment
import de.cau.cs.kieler.kexpressions.kext.AnnotatedExpression
import de.cau.cs.kieler.kexpressions.kext.ClassDeclaration
import de.cau.cs.kieler.kexpressions.kext.Kext
import de.cau.cs.kieler.kexpressions.kext.TestEntity
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsAccessVisibilityExtensions

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class KExtValidator extends AbstractKExtValidator {
    
    @Inject extension KExpressionsValuedObjectExtensions
    @Inject extension KExpressionsDeclarationExtensions
    @Inject extension KExpressionsAccessVisibilityExtensions

    public static val CHECK_ANNOTATION_NAME = "check"
    public static val CHECKALIAS_ANNOTATION_NAME = "aliasCheck"
    
    public static val CHECK_ANNOTATION_ID_ALREADY_EXISTS = "The ID of a check annotation must be unique!";
    public static val CHECK_CHECKALIAS_ANNOTATION_MATCHES_NOTHING = "The alias check reference matches nothing!"
    
    static val WRONG_CARDINALITY_TYPE = "Array cardinalities must be an int literal or a reference to a constant int object."
    static val String NO_CONST_LITERAL = "Const objects must be bound to literals";
    static val WRONG_ARRAY_INITIALISATION = "Initial value of an array can not be a single value."
    
    static val STRUCT_NON_PUBLIC_MEMBER = "All members of a struct must be publicly accessible."
    static val STRUCT_COMPLEX_MEMBER = "A struct may only contain primitive members or other structs."
       
    @Check
    public def void checkCheckAnnotation(TestEntity testEntity) {
        val rootElement = EcoreUtil2.getRootContainer(testEntity) as Kext;
        val ownCheckId = testEntity.eAllContents.filter(StringAnnotation).filter[ name.equals(CHECK_ANNOTATION_NAME) ].head.values.head 
        
        val identicalCheckIds = rootElement.eAllContents.filter(StringAnnotation).
            filter[ name.equals(CHECK_ANNOTATION_NAME) && values.head.equals(ownCheckId) ].toList
        
        if (identicalCheckIds.size > 1) {
            for(checkId : identicalCheckIds) {
                error(CHECK_ANNOTATION_ID_ALREADY_EXISTS, checkId, null, -1)
            }
        }       
    }
    
    @Check
    public def void checkCheckAliasAnnotation(StringAnnotation stringAnnotation) {
        if (!CHECKALIAS_ANNOTATION_NAME.equals(stringAnnotation.name)) { return; }
        val parent = stringAnnotation.eContainer
        val VOs = <ValuedObject> newArrayList
        if (parent instanceof Assignment) {
            VOs += parent.reference.valuedObject
            if (parent.expression instanceof ValuedObjectReference) {
                VOs += (parent.expression as ValuedObjectReference).valuedObject
            } else {
                VOs += parent.expression.eAllContents.filter(ValuedObjectReference).map[ valuedObject ].toList
            }
        } else if (parent instanceof AnnotatedExpression) {
            if (parent.expression instanceof ValuedObjectReference) {
                VOs += (parent.expression as ValuedObjectReference).valuedObject
            } else {
                VOs += parent.expression.eAllContents.filter(ValuedObjectReference).map[ valuedObject ].toList
            }
        }
        
        val matches = VOs.filter[ name.equals(stringAnnotation.values.head) ]
        if (matches.empty) {
            warning(CHECK_CHECKALIAS_ANNOTATION_MATCHES_NOTHING, stringAnnotation, null, -1)
        }
        
    }
    
    @Check
    def void checkConstDeclarationInArrays(Declaration declaration) {
        for (vo : declaration.valuedObjects) {
            for (card : vo.cardinalities) {
                var ok = false
                if (card instanceof IntValue) ok = true
                if (card instanceof ValuedObjectReference) {
                    val refVO = card.lowermostReference.valuedObject
                    val refDecl = refVO.variableDeclaration
                    if (refDecl !== null && refDecl.const && refDecl.type == ValueType.INT) {
                        if (refVO.initialValue !== null && refVO.initialValue instanceof IntValue) ok = true
                    }
                }
                if (card instanceof StaticAccessExpression) {
                    val refVO = card.subReference?.lowermostReference?.valuedObject
                    if (refVO !== null) {
                        val refDecl = refVO.variableDeclaration
                        if (refDecl !== null && refDecl.const && refDecl.type == ValueType.INT) {
                            if (refVO.initialValue !== null && refVO.initialValue instanceof IntValue) ok = true
                        }
                    }
                }
                
                if (!ok) {
                    error(WRONG_CARDINALITY_TYPE, card, null)
                } 
            }
            if (vo.cardinalities.size > 0 && vo.initialValue !== null) {
                if( vo.initialValue instanceof Value && !(vo.initialValue instanceof VectorValue) ){
                    error(WRONG_ARRAY_INITIALISATION, vo.initialValue, null)
                }
            }
        }
    }

//   @Check
//   def void checkConstBinding(VariableDeclaration declaration) {
//       if (declaration.isConst) {
//           for (valuedObject : declaration.getValuedObjects) {
//               val initialValue = valuedObject.getInitialValue
//               if (initialValue != null) {
//                   var ok = false
//                   // If it is a literal, it's ok.
//                   if (initialValue instanceof Value) ok = true
//                   
//                   // If it is an subtraction operator expression with a single literal, it's ok. E.g., -12
//                   if (initialValue instanceof OperatorExpression) {
//                       if (initialValue.operator == OperatorType.SUB) {
//                           if (initialValue.subExpressions.size == 1 &&
//                               initialValue.subExpressions.head instanceof Value) ok = true
//                       } 
//                   }
//                   if (!ok) error(NO_CONST_LITERAL, valuedObject, null, -1);
//               }
//           }
//       }
//    }
    
    @Check
    def void checkPureSignal(VariableDeclaration declaration) {
        if (declaration.type == ValueType.PURE && (!declaration.signal)) {
            if (!(declaration.eContainer instanceof ClassDeclaration) || !(declaration.eContainer as ClassDeclaration).isEnum) {
                error("Pure types are only allowed if used in combination with signals.", declaration, null, -1)
            }
        }
    }

    @Check
    def void checkStruct(ClassDeclaration declaration) {
        if (declaration.isStruct) {
            for (member : declaration.declarations) {
                if (!member.isPublic) {
                    error(STRUCT_NON_PUBLIC_MEMBER, member, null, -1)
                }
                if (member instanceof VariableDeclaration) {
                    if (member instanceof ClassDeclaration) {
                        if (!member.isStruct) {
                            error(STRUCT_COMPLEX_MEMBER, member, null, -1)
                        }
                    }
                } else {
                    error(STRUCT_COMPLEX_MEMBER, member, null, -1)
                }
            }
        }
    }

}
