/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.scoping

import com.google.inject.Inject
import de.cau.cs.kieler.annotations.NamedObject
import de.cau.cs.kieler.annotations.extensions.AnnotationsExtensions
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.GenericParameterDeclaration
import de.cau.cs.kieler.kexpressions.GenericTypeReference
import de.cau.cs.kieler.kexpressions.KExpressionsPackage
import de.cau.cs.kieler.kexpressions.MethodDeclaration
import de.cau.cs.kieler.kexpressions.Parameter
import de.cau.cs.kieler.kexpressions.ReferenceCall
import de.cau.cs.kieler.kexpressions.ReferenceDeclaration
import de.cau.cs.kieler.kexpressions.SpecialAccessExpression
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsAccessVisibilityExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsDeclarationExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsGenericParameterExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsValuedObjectExtensions
import de.cau.cs.kieler.kexpressions.kext.ClassDeclaration
import de.cau.cs.kieler.kexpressions.kext.DeclarationScope
import de.cau.cs.kieler.kexpressions.kext.scoping.KExtScopeProvider
import de.cau.cs.kieler.sccharts.BaseStateReference
import de.cau.cs.kieler.sccharts.ControlflowRegion
import de.cau.cs.kieler.sccharts.DataflowRegion
import de.cau.cs.kieler.sccharts.Region
import de.cau.cs.kieler.sccharts.SCCharts
import de.cau.cs.kieler.sccharts.SCChartsPackage
import de.cau.cs.kieler.sccharts.Scope
import de.cau.cs.kieler.sccharts.ScopeCall
import de.cau.cs.kieler.sccharts.State
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.extensions.SCChartsCoreExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsInheritanceExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsScopeExtensions
import de.cau.cs.kieler.sccharts.processors.MethodSignaling
import de.cau.cs.kieler.sccharts.processors.StaticAccess
import de.cau.cs.kieler.scl.Loop
import de.cau.cs.kieler.scl.MethodImplementationDeclaration
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.xbase.lib.Functions.Function1
import com.google.common.collect.Iterables

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class SCTXScopeProvider extends KExtScopeProvider {
    
    @Inject extension SCChartsCoreExtensions
    @Inject extension SCChartsScopeExtensions
    @Inject extension SCChartsInheritanceExtensions
    @Inject extension AnnotationsExtensions
    @Inject extension KExpressionsDeclarationExtensions
    @Inject extension KExpressionsValuedObjectExtensions
    @Inject extension KExpressionsGenericParameterExtensions
    @Inject extension KExpressionsAccessVisibilityExtensions
    
    @Inject SCTXQualifiedNameProvider nameProvider

    override getScope(EObject context, EReference reference) {
        switch(context) {
            Transition: return getScopeForTransition(context, reference)
            Region: return getScopeForRegion(context, reference)
            ScopeCall: return getScopeForScopeCall(context, reference)
            GenericTypeReference: return getScopeForGenericTypeReference(context, reference)
            GenericParameterDeclaration: return getScopeForGenericParameterDeclaration(context, reference)
            BaseStateReference: return getScopeForBaseStateReference(context, reference)
            SpecialAccessExpression: return getScopeForSpecialAccess(context, reference)
        }
        
        return super.getScope(context, reference);
    }
    
    protected def IScope getScopeForTransition(Transition transition, EReference reference) {
        val states = <State> newArrayList
        val parentState = transition.eContainer as State
        val parentRegion = parentState.eContainer as ControlflowRegion
        
        parentRegion.states.forEach[ 
            states += it 
        ]
        
        return SCTXScopes.scopeFor(states)
    }
    
    protected def IScope getScopeForBaseStateReference(BaseStateReference ref, EReference reference) {
        if (reference == SCChartsPackage.Literals.BASE_STATE_REFERENCE__TARGET) {
            return SCTXScopes.scopeFor(ref.eResource.allAvailableRootStates)
        }
        
        return super.getScope(ref, reference)
    }
    
    protected def IScope getScopeForRegion(Region region, EReference reference) {
        if (reference == SCChartsPackage.Literals.SCOPE_CALL__TARGET) {
            return SCTXScopes.scopeFor(region.nextSuperStateWithBaseStates.allVisibleInheritedRegions)
        }
        
        return super.getScope(region, reference)
    }
    
    protected def IScope getScopeForScopeCall(ScopeCall scopeCall, EReference reference) {
        if (reference == SCChartsPackage.Literals.SCOPE_CALL__TARGET) {
            if (scopeCall.eContainer instanceof State) {
                val candidates = <NamedObject>newLinkedList
                var rootState = scopeCall.eContainer?.asScope.rootState
                if (rootState instanceof State && !(rootState as State).genericParameterDeclarations.nullOrEmpty) {
                    candidates += (rootState as State).genericComplexTypeParameters
                }
                candidates += scopeCall.eResource.allAvailableRootStates
                return SCTXScopes.scopeFor(candidates)
            } else if (scopeCall.eContainer instanceof Region) {
                return SCTXScopes.scopeFor((scopeCall.eContainer as Scope).nextSuperStateWithBaseStates.getAllVisibleInheritedRegions(!scopeCall.super))
            }
            
            return IScope.NULLSCOPE
        }
        
        return super.getScope(scopeCall as EObject, reference)
    }
        
    override IScope getScopeForParameter(Parameter parameter, EReference reference) {        
        if (reference == KExpressionsPackage.Literals.PARAMETER__EXPLICIT_BINDING) {
            val voCandidates = <ValuedObject> newArrayList
            
            var EObject target
            val container = parameter.eContainer
            
            if (container instanceof ScopeCall) {
                target = container.target
            } else if (container instanceof BaseStateReference) {
                target = container.target
            } else if (container instanceof ValuedObject) {
                target = container.referenceDeclaration?.reference
            }
            
            if (target !== null) {
                if (target instanceof Scope) {
                    for (declaration : target.IODeclarations.filter[ input || output ]) {
                        voCandidates += declaration.valuedObjects
                    }
                } else if (target instanceof ValuedObject) {
                    if (target.isGenericParamter) {
                        val type = target.genericParameterDeclaration?.type
                        if (type instanceof Scope) {
                            for (declaration : type.IODeclarations.filter[ input || output ]) {
                                voCandidates += declaration.valuedObjects
                            }
                        }
                    }
                }
                // Inherited Decls
                if (target instanceof State) {
                    for (declaration : target.allVisibleInheritedDeclarations.filter(VariableDeclaration).filter[ input || output ]) {
                        voCandidates += declaration.valuedObjects
                    }
                }
            }
            
            return SCTXScopes.scopeFor(voCandidates)
        }
        
        return super.getScopeForParameter(parameter, reference)
    }
    
    override IScope getScopeForReferenceDeclaration(EObject context, EReference reference) {
        if (reference == KExpressionsPackage.Literals.REFERENCE_DECLARATION__REFERENCE || reference == KExpressionsPackage.Literals.REFERENCE_DECLARATION__REFERENCE_CONTAINER) {
            val declaration = context
            if (declaration instanceof ReferenceDeclaration) {
                val candidates = <NamedObject>newLinkedList
                val rootState = declaration.nextScope?.rootState
                val rootStates = declaration.eResource.allAvailableRootStates
                
                if (reference == KExpressionsPackage.Literals.REFERENCE_DECLARATION__REFERENCE) {
                    val refContainer = declaration.referenceContainer
                    if (refContainer !== null) {
                        if (refContainer instanceof DeclarationScope) {
                            candidates += refContainer.declarations.filter(ClassDeclaration).map[(it.isEnum ? valuedObjects.head : it) as NamedObject]
                        }
                    } else {
                        candidates += rootStates
                        candidates += rootState.declarations.filter(ClassDeclaration).map[(it.isEnum ? valuedObjects.head : it) as NamedObject]
                        if (!rootState.baseStateReferences.nullOrEmpty) {
                            candidates += rootState.getAllVisibleInheritedDeclarations.filter(ClassDeclaration).map[(it.isEnum ? valuedObjects.head : it) as NamedObject]
                        }
                        if (rootState !== null && !rootState.genericParameterDeclarations.nullOrEmpty) {
                            if (declaration.simple) {
                                candidates += (rootState as State).genericPrimitiveTypeParameters
                            } else {
                                candidates += (rootState as State).genericComplexTypeParameters
                            }
                        }
                    }
                } else if (reference == KExpressionsPackage.Literals.REFERENCE_DECLARATION__REFERENCE_CONTAINER) {
                    candidates += rootStates
                }
                
                return SCTXScopes.scopeFor(candidates)
            }
        } 
        return context.getScopeHierarchical(reference)
    }
    
    def IScope getScopeForGenericTypeReference(GenericTypeReference context, EReference reference) {
        val declaration = context.getGenericParameterDeclaration
        val candidates = <NamedObject>newLinkedList
        
        // States
        var states = context.eResource.allAvailableRootStates.toList
        if (declaration !== null && !states.empty) {
            val type = declaration.type
            if (type instanceof Scope) {
                states = states.filter[
                    it === type || it.baseStates.contains(type)
                ].toList
            }
        }
        candidates += states
        
        // Special case for parser ambiguity => also match ValuedObjects for later transformation into VOReference
        if (context.genericParameters.nullOrEmpty) {
            var rootState = context.nextScope?.rootState
            if (rootState !== null && !rootState.genericParameterDeclarations.nullOrEmpty) {
                candidates += (rootState as State).genericComplexTypeParameters
                candidates += (rootState as State).genericPrimitiveTypeParameters
            }
            return SCTXScopes.scopeFor(candidates, context.getScopeForValuedObjectReference(reference))
        }
        return SCTXScopes.scopeFor(candidates)
    }
    
    def IScope getScopeForGenericParameterDeclaration(GenericParameterDeclaration context, EReference reference) {
        if (reference == KExpressionsPackage.Literals.GENERIC_PARAMETER_DECLARATION__TYPE) {
            return SCTXScopes.scopeFor(context.eResource.allAvailableRootStates)
        }
        return IScope.NULLSCOPE
    }
    
    def IScope getScopeForSpecialAccess(SpecialAccessExpression context, EReference reference) {
        switch(context.access) {
            case StaticAccess.ACCESS_KEYWORD: {
                if (reference == KExpressionsPackage.Literals.SPECIAL_ACCESS_EXPRESSION__CONTAINER) {
                    return IScope.NULLSCOPE // SCChart access does not allows container
                } else if (reference == KExpressionsPackage.Literals.SPECIAL_ACCESS_EXPRESSION__TARGET) {
                    return SCTXScopes.scopeFor(context.eResource.getAllAvailableRootStates)
                }
            }
            case MethodSignaling.ACCESS_KEYWORD: {
                val scope = context.nextScope
                if (reference == KExpressionsPackage.Literals.SPECIAL_ACCESS_EXPRESSION__CONTAINER) {
                    if (scope instanceof State) {
                        return SCTXScopes.scopeFor(scope.regions.filter[!name.nullOrEmpty])
                    }
                } else if (reference == KExpressionsPackage.Literals.SPECIAL_ACCESS_EXPRESSION__TARGET) {
                    if (context.container !== null) {
                        val region = context.container
                        if (region instanceof ControlflowRegion) {
                            return SCTXScopes.scopeFor(region.states)
                        }
                    } else if (scope instanceof State) {
                        // Validator will check for ambiguity
                        return SCTXScopes.scopeFor(scope.regions.filter(ControlflowRegion).filter[name.nullOrEmpty].map[states].flatten)
                    } else if (scope instanceof ControlflowRegion) {
                        return SCTXScopes.scopeFor(scope.states)
                    }
                }
            }
            default: return IScope.NULLSCOPE
        }
        return IScope.NULLSCOPE
    }
    
    override protected getScopeForValuedObjectReference(EObject context, EReference reference) {
        val contextContainer = context.eContainer
        if (contextContainer instanceof SpecialAccessExpression && (contextContainer as SpecialAccessExpression).subReference === context) {
            val target = (contextContainer as SpecialAccessExpression).target
            // The context is a subreference of static access!
            if (target instanceof DeclarationScope) {
                return Scopes.scopeFor(target.declarations.filter[allowsGlobalAccess].map[valuedObjects].flatten)
            } else {
                return IScope.NULLSCOPE
            }
        } else if (context instanceof ReferenceCall && (context as ReferenceCall).subReference === null) { // is call and has no sub-reference
            val call = context as ReferenceCall
            val candidates = <ValuedObject> newArrayList
            var declarationScope = context.nextDeclarationScope
            while (declarationScope !== null) {
                if (call.isSuper) {
                    if (declarationScope instanceof State) {
                        // Only inherited Methods
                        if (!declarationScope.baseStateReferences.nullOrEmpty) {
                            for (decl : declarationScope.allVisibleInheritedDeclarations.filter[isMethod]) {
                                for(VO : decl.valuedObjects) {
                                    candidates += VO
                                }
                            }
                        }
                    }
                } else {
                    for(declaration : declarationScope.declarations.filter[isCallable]) {
                        for(VO : declaration.valuedObjects) {
                            candidates += VO
                        }
                    }
                    if (declarationScope instanceof State) {
                        // Inherited VOs
                        if (!declarationScope.baseStateReferences.nullOrEmpty) {
                            for (decl : declarationScope.allVisibleInheritedDeclarations.filter[isCallable]) {
                                for(VO : decl.valuedObjects) {
                                    candidates += VO
                                }
                            }
                        }
                        // Generic Parameters
                        candidates += declarationScope.genericValuedObjectParameters.filter[declaration.isCallable]
                    }
                }
                
                // This also gives nested classes access to variable of surrounding scopes (only partially supported in code gen)
                declarationScope = declarationScope.nextDeclarationScope
            }
            return Scopes.scopeFor(candidates)
        } else {
            return super.getScopeForValuedObjectReference(context, reference)
        }
    }

    override IScope getScopeHierarchical(EObject context, EReference reference) {
        val candidates = <ValuedObject> newArrayList
        var declarationScope = context.nextDeclarationScope
        while (declarationScope !== null) {
            for(declaration : declarationScope.declarations) {
                for(VO : declaration.valuedObjects) {
                    candidates += VO
                }
            }
            
            // Add for regions counter variable            
            if (declarationScope instanceof Region) {
                if (declarationScope.counterVariable !== null) {
                    candidates += declarationScope.counterVariable
                }
            }
            
            // Add for loop counter variable            
            if (declarationScope instanceof Loop) {
                if (declarationScope.initializationDeclaration !== null) {
                    candidates += declarationScope.initializationDeclaration.valuedObjects
                }
            }
            
            // Add method parameters           
            if (declarationScope instanceof MethodImplementationDeclaration) {
                candidates += declarationScope.parameterDeclarations.map[valuedObjects].flatten
            }
            
            if (declarationScope instanceof State) {
                // Inherited VOs
                if (!declarationScope.baseStateReferences.nullOrEmpty) {
                    if (context.eContainer instanceof Parameter
                        && context.eContainer.eContainer instanceof BaseStateReference
                        && context.eContainer.eContainer.eContainer == declarationScope) {
                        val bsr = context.eContainer.eContainer as BaseStateReference
                        for (base : declarationScope.baseStateReferences.takeWhile[it != bsr]) {
                            if (base.target != null) {
                                for (decl : Iterables.concat(
                                    base.target.declarations.filter[!it.isPrivate],
                                    base.target.allVisibleInheritedDeclarations)) {
                                    for(VO : decl.valuedObjects) {
                                        candidates += VO
                                    }
                                }
                            }
                        }
                    } else {
                        for (decl : declarationScope.allVisibleInheritedDeclarations) {
                            for(VO : decl.valuedObjects) {
                                candidates += VO
                            }
                        }
                    }
                }
                // Generic Parameters
                candidates += declarationScope.genericValuedObjectParameters
            }
            
            // This also give nested classes access to variable of surrounding scopes (only partially supported in code gen)
            declarationScope = declarationScope.nextDeclarationScope
        }
        
        return Scopes.scopeFor(candidates)
    }
    
    def getAllAvailableRootStates(Resource eResource) {
        if (eResource !== null) {
            val scchartsInScope = newHashSet(eResource.contents.head as SCCharts)
            val eResourceSet = eResource.resourceSet
            if (eResourceSet !== null) {
                eResourceSet.resources.filter[!contents.empty].map[contents.head].filter(SCCharts).forEach[ 
                    scchartsInScope += it
                ]
            }
            return scchartsInScope.map[rootStates].flatten
        }
        return emptyList
    }
    
    override IScope getScopeForReferencedType(EObject reference, ValuedObjectReference context,
        Function1<? super VariableDeclaration, Boolean> predicate) {
        var EObject region = context
        while (region !== null && !(region instanceof Region)) {
            region = region.eContainer
        }
        
        val adjustedPredicate = if (region instanceof DataflowRegion) predicate else [VariableDeclaration vd | vd.isPublic]
        
        if (reference instanceof State) {
            val additionalCandidates = newArrayList
            additionalCandidates += reference.declarations.filter(MethodDeclaration).map[valuedObjects.head]
            if (!reference.baseStateReferences.nullOrEmpty) {
                for (decl : reference.allVisibleInheritedDeclarations) {
                    for(VO : decl.valuedObjects) {
                        additionalCandidates += VO
                    }
                }
            }
            return Scopes.scopeFor(additionalCandidates, super.getScopeForReferencedType(reference, context, adjustedPredicate))
        } else {
            return super.getScopeForReferencedType(reference, context, adjustedPredicate)
        }
    }
    
    private def boolean allowsGlobalAccess(Declaration decl) {
        if (decl instanceof VariableDeclaration) {
            if (!decl.input && decl.isPublic) {
                if (decl.const || decl instanceof ClassDeclaration) {
                    return true
                }
            }
        }
        if (decl instanceof MethodDeclaration) {
            return decl.isStatic
        }
        return false
    }
    
    private def boolean isCallable(Declaration decl) {
        if (decl instanceof MethodDeclaration) {
            return true
        }
        if (decl instanceof ReferenceDeclaration) {
            return !decl.extern.empty
        }
        return false
    }
}
