/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.serializer

import com.google.inject.Inject
import de.cau.cs.kieler.kexpressions.Expression
import de.cau.cs.kieler.kexpressions.IntValue
import de.cau.cs.kieler.kexpressions.OperatorExpression
import de.cau.cs.kieler.kexpressions.ReferenceCall
import de.cau.cs.kieler.sccharts.ControlflowRegion
import de.cau.cs.kieler.sccharts.DeferredType
import de.cau.cs.kieler.sccharts.DelayType
import de.cau.cs.kieler.sccharts.HistoryType
import de.cau.cs.kieler.sccharts.SCChartsPackage
import de.cau.cs.kieler.sccharts.State
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.text.parser.InternalSCTXParser
import de.cau.cs.kieler.sccharts.text.services.SCTXGrammarAccess
import de.cau.cs.kieler.scl.Assignment
import de.cau.cs.kieler.scl.MethodImplementationDeclaration
import org.eclipse.xtext.serializer.ISerializationContext

import static de.cau.cs.kieler.kexpressions.OperatorType.*

/**
 * @author als
 * @kieler.design proposed
 * @kieler.rating proposed yellow
 */
class SCTXSemanticSequencer extends AbstractSCTXSemanticSequencer {
    
    @Inject
    extension SCTXGrammarAccess;
    val SCChartsPackage pkg = SCChartsPackage.eINSTANCE
    

    override sequence_Transition(ISerializationContext context, Transition transition) {
        val feeder = createSequencerFeeder(transition, createNodeProvider(transition))
        val nodes = nodeProvider.getNodesForSemanticObject(transition, null)
        val tg = transitionAccess
        
        for (idxAnnotation : transition.annotations.indexed) {
            feeder.accept(tg.annotationsRestrictedTypeAnnotationParserRuleCall_1_0, idxAnnotation.value, idxAnnotation.key)
        }
        
        // immediate / delayed ?
        if (transition.delay != DelayType.UNDEFINED) {
            feeder.accept(tg.delayDelayTypeEnumRuleCall_2_0, transition.delay)
        }
        // if?
        if (transition.trigger !== null) {
            if (transition.triggerDelay > 1) {
                feeder.accept(tg.triggerDelayINTTerminalRuleCall_3_1_0, transition.triggerDelay)
            }
            
            // This handles separation of count delay together with expressions starting with an integer
            if (transition.triggerDelay == 1 && transition.trigger.requiresParentheses) {
                feeder.accept(tg.triggerAtomicExpressionParserRuleCall_3_2_1_0, transition.trigger)
            } else {
                feeder.accept(tg.triggerBoolScheduleExpressionParserRuleCall_3_2_0_0, transition.trigger)
            }
            
            // Propability
            if (transition.triggerProbability > 0) {
                feeder.accept(tg.triggerProbabilityFLOATTerminalRuleCall_3_3_1_0, transition.triggerProbability)
            }
            if (transition.nondeterministic) {
                feeder.accept(tg.nondeterministicNondeterministicKeyword_3_4_0)
            }
        }
        // do?
        for (idxEffect : transition.effects.indexed) {
            if (idxEffect.key == 0) {
                feeder.accept(tg.effectsEffectParserRuleCall_4_1_0, idxEffect.value, idxEffect.key)
            } else {
                feeder.accept(tg.effectsEffectParserRuleCall_4_2_1_0, idxEffect.value, idxEffect.key)
            }
        }
        // go to / abort to / join to
        feeder.accept(tg.preemptionPreemptionTypeEnumRuleCall_5_0, transition.preemption)
        // <state>
        feeder.accept(tg.targetStateStateIDTerminalRuleCall_7_0_1 , transition.targetState) 
        // deferred?
        if (transition.deferred != DeferredType::NONE) {
            feeder.accept(tg.deferredDeferredTypeEnumRuleCall_8_0, transition.deferred)
        }
        // history?
        if (transition.history != HistoryType.RESET) {
            feeder.accept(tg.historyHistoryTypeEnumRuleCall_9_0, transition.history)
        }

        if (!transition.label.nullOrEmpty) {
            feeder.accept(tg.labelSTRINGTerminalRuleCall_10_1_0, transition.label)
        } 
                
        feeder.finish
    }
    
    override protected sequence_ControlflowRegion(ISerializationContext context, ControlflowRegion region) {
        val feeder = createSequencerFeeder(region, createNodeProvider(region))
        val nodes = nodeProvider.getNodesForSemanticObject(region, null)
        val rg = controlflowRegionAccess
        
        // annotations
        for (idxAnnotation : region.annotations.indexed) {
            feeder.accept(rg.annotationsAnnotationParserRuleCall_1_0, idxAnnotation.value, idxAnnotation.key)
        }
        // override
        if (region.abort) {
            feeder.accept(rg.abortAbortKeyword_2_0_0)
        } else {
            // override
            if (region.override) {
                feeder.accept(rg.overrideOverrideKeyword_2_1_0_0)
            }
            // final
            if (region.final) {
                feeder.accept(rg.finalFinalKeyword_2_1_1_0)
            }
        }
        // name
        if (!region.name.nullOrEmpty) {
            feeder.accept(rg.nameExtendedIDParserRuleCall_4_0, region.name)
        }
        // label
        if (!region.label.nullOrEmpty && !region.label.equals(region.name)) {
            feeder.accept(rg.labelSTRINGTerminalRuleCall_5_0, region.label)
        }
        // is
        if (region.reference !== null) {
            feeder.accept(rg.referenceScopeCallParserRuleCall_6_0_1_0, region.reference)
            //for
            if (region.counterVariable !== null) {
                feeder.accept(rg.counterVariableCounterVariableParserRuleCall_6_0_2_1_0, region.counterVariable)
                feeder.accept(rg.forStartIntOrReferenceParserRuleCall_6_0_2_3_0, region.forStart)
                if (region.forEnd !== null) {
                    feeder.accept(rg.forEndIntOrReferenceParserRuleCall_6_0_2_4_1_0, region.forEnd)
                }
            }
            // schedule
            for (idxSchedule : region.schedule.indexed) {
                feeder.accept(rg.scheduleScheduleObjectReferenceParserRuleCall_6_0_3_1_0, idxSchedule.value, idxSchedule.key)
            }
        } else { // normal region
            // for
            if (region.counterVariable !== null) {
                feeder.accept(rg.counterVariableCounterVariableParserRuleCall_6_1_0_1_0, region.counterVariable)
                feeder.accept(rg.forStartIntOrReferenceParserRuleCall_6_1_0_3_0, region.forStart)
                if (region.forEnd !== null) {
                    feeder.accept(rg.forEndIntOrReferenceParserRuleCall_6_1_0_4_1_0, region.forEnd)
                }
            }
            // schedule
            for (idxSchedule : region.schedule.indexed) {
                feeder.accept(rg.scheduleScheduleObjectReferenceParserRuleCall_6_1_1_1_0, idxSchedule.value, idxSchedule.key)
            }
            // Decide wich variant schould be used
            val isImplicit = !region.states.nullOrEmpty
                && region.states.size == 1
                && InternalSCTXParser.IMPLICIT_STATE_NAME.equals(region.states.head.name)
                && region.states.head.initial
                && !region.states.head.final
                && region.states.head.declarations.nullOrEmpty
                && region.states.head.actions.nullOrEmpty
                && region.states.head.outgoingTransitions.nullOrEmpty
                && !region.states.head.regions.nullOrEmpty
            val node = if (!region.states.nullOrEmpty) nodes.getNodeForMultiValue(pkg.controlflowRegion_States, 0, 0, region.states.head)
            // Prefer curly bracket version when model does not already has a textuel preference (user typed region:)
            val prefersColon = node !== null && node.grammarElement === rg.statesStateParserRuleCall_6_1_2_1_3_0

            if (isImplicit || !prefersColon) { // region {}
                // declarations
                for (idxDecl : region.declarations.filter[!(it instanceof MethodImplementationDeclaration)].indexed) {
                    feeder.accept(rg.declarationsDeclarationOrMethodWithKeywordWOSemicolonParserRuleCall_6_1_2_0_1_0, idxDecl.value, idxDecl.key)
                }
                // actions
                for (idxAction : region.actions.indexed) {
                    feeder.accept(rg.actionsLocalActionParserRuleCall_6_1_2_0_2_0, idxAction.value, idxAction.key)
                }
                // states
                if (isImplicit) {
                    feeder.accept(rg.statesImplicitStateParserRuleCall_6_1_2_0_3_0_0, region.states.head, 0)
                } else {
                    for (idxState : region.states.indexed) {
                        feeder.accept(rg.statesStateParserRuleCall_6_1_2_0_3_1_0, idxState.value, idxState.key)
                    }
                }
            } else { // region:
                // declarations
                for (idxDecl : region.declarations.filter[!(it instanceof MethodImplementationDeclaration)].indexed) {
                    feeder.accept(rg.declarationsDeclarationOrMethodWithKeywordWOSemicolonParserRuleCall_6_1_2_1_1_0, idxDecl.value, idxDecl.key)
                }
                // actions
                for (idxAction : region.actions.indexed) {
                    feeder.accept(rg.actionsLocalActionParserRuleCall_6_1_2_1_2_0, idxAction.value, idxAction.key)
                }
                // states
                for (idxState : region.states.indexed) {
                    feeder.accept(rg.statesStateParserRuleCall_6_1_2_1_3_0, idxState.value, idxState.key)
                }
            }
        }
                
        feeder.finish
    }
    
    override protected sequence_ImplicitState(ISerializationContext context, State state) {
        val feeder = createSequencerFeeder(state, createNodeProvider(state))
        val g = implicitStateAccess
        
        for (idxRegion : state.regions.indexed) {
            feeder.accept(g.regionsRegionParserRuleCall_1_0, idxRegion.value, idxRegion.key)
        }
        
        feeder.finish
    }
    
    
    /**
     * Helps backtracking to serialize method calls
     */
    override protected sequence_SclAssignment_SclEffectAssignment_SclPostfixAssignment(ISerializationContext context, Assignment asm) {
        if (asm.expression instanceof ReferenceCall) {
            sequence_SclEffectAssignment(context, asm);
        } else {
            genericSequencer.createSequence(context, asm);
        }
    }
    
    /**
     * Helps backtracking to serialize method calls
     */
    override protected sequence_SclEffectAssignment(ISerializationContext context, Assignment asm) {
        if (asm.expression instanceof ReferenceCall) {
            val feeder = createSequencerFeeder(asm, createNodeProvider(asm))
            val nodes = nodeProvider.getNodesForSemanticObject(asm, null)
            val g = sclEffectAssignmentAccess
            
            feeder.accept(g.expressionReferenceCallParserRuleCall_1_0_0, asm.expression)
            if (!asm.schedule.empty) {
                feeder.accept(g.scheduleScheduleObjectReferenceParserRuleCall_2_1_0, asm.schedule)
            }
            if (asm.semicolon) {
                feeder.accept(g.semicolonSemicolonKeyword_3_0)
            }        
        } else {
            super.sequence_SclEffectAssignment(context, asm)
        }
    }
    
    private static val prefixOperators = newHashSet(NOT, PRE, VAL)
    
    private def boolean requiresParentheses(Expression exp) {
        if (exp instanceof IntValue) {
            return true
        } else if (exp instanceof OperatorExpression) {
            if (!prefixOperators.contains(exp.operator)) {
                return exp.subExpressions.head.requiresParentheses
            } else {
                return false
            }
        } else {
            return false
        }
    }

}
