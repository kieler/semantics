/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.serializer

import com.google.inject.Inject
import de.cau.cs.kieler.kexpressions.Expression
import de.cau.cs.kieler.kexpressions.IntValue
import de.cau.cs.kieler.kexpressions.OperatorExpression
import de.cau.cs.kieler.sccharts.ControlflowRegion
import de.cau.cs.kieler.sccharts.DelayType
import de.cau.cs.kieler.sccharts.HistoryType
import de.cau.cs.kieler.sccharts.SCChartsPackage
import de.cau.cs.kieler.sccharts.State
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.text.parser.InternalSCTXParser
import de.cau.cs.kieler.sccharts.text.services.SCTXGrammarAccess
import org.eclipse.xtext.serializer.ISerializationContext

import static de.cau.cs.kieler.kexpressions.OperatorType.*

/**
 * @author als
 * @kieler.design proposed
 * @kieler.rating proposed yellow
 */
class SCTXSemanticSequencer extends AbstractSCTXSemanticSequencer {
    
    @Inject
    extension SCTXGrammarAccess;
    val SCChartsPackage pkg = SCChartsPackage.eINSTANCE
    

    override sequence_Transition(ISerializationContext context, Transition transition) {
        val feeder = createSequencerFeeder(transition, createNodeProvider(transition))
        val nodes = nodeProvider.getNodesForSemanticObject(transition, null)
        val tg = transitionAccess
        
        for (idxAnnotation : transition.annotations.indexed) {
            feeder.accept(tg.annotationsRestrictedTypeAnnotationParserRuleCall_1_0, idxAnnotation.value, idxAnnotation.key)
        }
        
        // Decide wich order to use
        val node = nodes.getNodeForSingelValue(pkg.transition_Preemption, transition.preemption)
        // Prefer goto last version when model does not already has a textuel preference
        val prefersGotoFirst = node !== null && node.grammarElement === tg.preemptionPreemptionTypeEnumRuleCall_2_0_0_0
        
        if (prefersGotoFirst) {
            // go to / abort to / join to
            feeder.accept(tg.preemptionPreemptionTypeEnumRuleCall_2_0_0_0, transition.preemption)
            // <state>
            feeder.accept(tg.targetStateStateIDTerminalRuleCall_2_0_1_0_1 , transition.targetState)
            // immediate / delayed ?
            if (transition.delay != DelayType.UNDEFINED) {
                feeder.accept(tg.delayDelayTypeEnumRuleCall_2_0_2_0, transition.delay)
            }
            // deferred?
            if (transition.deferred) {
                feeder.accept(tg.deferredDeferredKeyword_2_0_3_0)
            }
            // history?
            if (transition.history != HistoryType.RESET) {
                feeder.accept(tg.historyHistoryTypeEnumRuleCall_2_0_4_0, transition.history)
            }
            // if?
            if (transition.trigger !== null) {
                if (transition.triggerDelay > 1) {
                    feeder.accept(tg.triggerDelayINTTerminalRuleCall_2_0_5_1_0, transition.triggerDelay)
                }
                
                // This handles separation of count delay together with expressions starting with an integer
                if (transition.triggerDelay == 1 && transition.trigger.requiresParentheses) {
                    feeder.accept(tg.triggerAtomicExpressionParserRuleCall_2_0_5_2_1_0, transition.trigger)
                } else {
                    feeder.accept(tg.triggerBoolScheduleExpressionParserRuleCall_2_0_5_2_0_0, transition.trigger)
                }
            }
            // do?
            for (idxEffect : transition.effects.indexed) {
                if (idxEffect.key == 0) {
                    feeder.accept(tg.effectsEffectParserRuleCall_2_0_6_1_0, idxEffect.value, idxEffect.key)
                } else {
                    feeder.accept(tg.effectsEffectParserRuleCall_2_0_6_2_1_0, idxEffect.value, idxEffect.key)
                }
            }
        } else {
            // immediate / delayed ?
            if (transition.delay != DelayType.UNDEFINED) {
                feeder.accept(tg.delayDelayTypeEnumRuleCall_2_1_0_0, transition.delay)
            }
            // if?
            if (transition.trigger !== null) {
                if (transition.triggerDelay > 1) {
                    feeder.accept(tg.triggerDelayINTTerminalRuleCall_2_1_1_1_0, transition.triggerDelay)
                }
                
                // This handles separation of count delay together with expressions starting with an integer
                if (transition.triggerDelay == 1 && transition.trigger.requiresParentheses) {
                    feeder.accept(tg.triggerAtomicExpressionParserRuleCall_2_1_1_2_1_0, transition.trigger)
                } else {
                    feeder.accept(tg.triggerBoolScheduleExpressionParserRuleCall_2_1_1_2_0_0, transition.trigger)
                }
            }
            // do?
            for (idxEffect : transition.effects.indexed) {
                if (idxEffect.key == 0) {
                    feeder.accept(tg.effectsEffectParserRuleCall_2_1_2_1_0, idxEffect.value, idxEffect.key)
                } else {
                    feeder.accept(tg.effectsEffectParserRuleCall_2_1_2_2_1_0, idxEffect.value, idxEffect.key)
                }
            }
            // go to / abort to / join to
            feeder.accept(tg.preemptionPreemptionTypeEnumRuleCall_2_1_3_0, transition.preemption)
            // <state>
            feeder.accept(tg.targetStateStateIDTerminalRuleCall_2_1_4_0_1 , transition.targetState) 
            // deferred?
            if (transition.deferred) {
                feeder.accept(tg.deferredDeferredKeyword_2_1_5_0)
            }
            // history?
            if (transition.history != HistoryType.RESET) {
                feeder.accept(tg.historyHistoryTypeEnumRuleCall_2_1_6_0, transition.history)
            }
        }

        if (!transition.label.nullOrEmpty) {
            feeder.accept(tg.labelSTRINGTerminalRuleCall_3_1_0, transition.label)
        } 
                
        feeder.finish
    }
    
    override protected sequence_ControlflowRegion(ISerializationContext context, ControlflowRegion region) {
        val feeder = createSequencerFeeder(region, createNodeProvider(region))
        val nodes = nodeProvider.getNodesForSemanticObject(region, null)
        val rg = controlflowRegionAccess
        
        // annotations
        for (idxAnnotation : region.annotations.indexed) {
            feeder.accept(rg.annotationsAnnotationParserRuleCall_1_0, idxAnnotation.value, idxAnnotation.key)
        }
        // override
        if (region.override) {
            feeder.accept(rg.overrideOverrideKeyword_2_0)
        }
        // final
        if (region.final) {
            feeder.accept(rg.finalFinalKeyword_3_0)
        }
        // name
        if (!region.name.nullOrEmpty) {
            feeder.accept(rg.nameExtendedIDParserRuleCall_5_0, region.name)
        }
        // label
        if (!region.label.nullOrEmpty && !region.label.equals(region.name)) {
            feeder.accept(rg.labelSTRINGTerminalRuleCall_6_0, region.label)
        }
        // is
        if (region.reference !== null) {
            feeder.accept(rg.referenceScopeCallParserRuleCall_7_0_1_0, region.reference)
            //for
            if (region.counterVariable !== null) {
                feeder.accept(rg.counterVariableCounterVariableParserRuleCall_7_0_2_1_0, region.counterVariable)
                feeder.accept(rg.forStartIntOrReferenceParserRuleCall_7_0_2_3_0, region.forStart)
                if (region.forEnd !== null) {
                    feeder.accept(rg.forEndIntOrReferenceParserRuleCall_7_0_2_4_1_0, region.forStart)
                }
            }
            // schedule
            for (idxSchedule : region.schedule.indexed) {
                feeder.accept(rg.scheduleScheduleObjectReferenceParserRuleCall_7_0_3_1_0, idxSchedule.value, idxSchedule.key)
            }
        } else { // normal region
            // for
            if (region.counterVariable !== null) {
                feeder.accept(rg.counterVariableCounterVariableParserRuleCall_7_1_0_1_0, region.counterVariable)
                feeder.accept(rg.forStartIntOrReferenceParserRuleCall_7_1_0_3_0, region.forStart)
                if (region.forEnd !== null) {
                    feeder.accept(rg.forEndIntOrReferenceParserRuleCall_7_1_0_4_1_0, region.forStart)
                }
            }
            // schedule
            for (idxSchedule : region.schedule.indexed) {
                feeder.accept(rg.scheduleScheduleObjectReferenceParserRuleCall_7_1_1_1_0, idxSchedule.value, idxSchedule.key)
            }
            // Decide wich variant schould be used
            val isImplicit = !region.states.nullOrEmpty
                && region.states.size == 1
                && InternalSCTXParser.IMPLICIT_STATE_NAME.equals(region.states.head.name)
                && region.states.head.initial
                && !region.states.head.final
                && region.states.head.declarations.nullOrEmpty
                && region.states.head.actions.nullOrEmpty
                && region.states.head.outgoingTransitions.nullOrEmpty
                && !region.states.head.regions.nullOrEmpty
            val node = if (!region.states.nullOrEmpty) nodes.getNodeForMultiValue(pkg.controlflowRegion_States, 0, 0, region.states.head)
            // Prefer curly bracket version when model does not already has a textuel preference (user typed region:)
            val prefersColon = node !== null && node.grammarElement === rg.statesStateParserRuleCall_7_1_2_1_3_0

            if (isImplicit || !prefersColon) { // region {}
                // declarations
                for (idxDecl : region.declarations.indexed) {
                    feeder.accept(rg.declarationsDeclarationWOSemicolonParserRuleCall_7_1_2_0_1_0, idxDecl.value, idxDecl.key)
                }
                // actions
                for (idxAction : region.actions.indexed) {
                    feeder.accept(rg.actionsLocalActionParserRuleCall_7_1_2_0_2_0, idxAction.value, idxAction.key)
                }
                // states
                if (isImplicit) {
                    feeder.accept(rg.statesImplicitStateParserRuleCall_7_1_2_0_3_0_0, region.states.head, 0)
                } else {
                    for (idxState : region.states.indexed) {
                        feeder.accept(rg.statesStateParserRuleCall_7_1_2_0_3_1_0, idxState.value, idxState.key)
                    }
                }
            } else { // region:
                // declarations
                for (idxDecl : region.declarations.indexed) {
                    feeder.accept(rg.declarationsDeclarationWOSemicolonParserRuleCall_7_1_2_1_1_0, idxDecl.value, idxDecl.key)
                }
                // actions
                for (idxAction : region.actions.indexed) {
                    feeder.accept(rg.actionsLocalActionParserRuleCall_7_1_2_1_2_0, idxAction.value, idxAction.key)
                }
                // states
                for (idxState : region.states.indexed) {
                    feeder.accept(rg.statesStateParserRuleCall_7_1_2_1_3_0, idxState.value, idxState.key)
                }
            }
        }
                
        feeder.finish
    }
    
    override protected sequence_ImplicitState(ISerializationContext context, State state) {
        val feeder = createSequencerFeeder(state, createNodeProvider(state))
        val g = implicitStateAccess
        
        for (idxRegion : state.regions.indexed) {
            feeder.accept(g.regionsRegionParserRuleCall_1_0, idxRegion.value, idxRegion.key)
        }
        
        feeder.finish
    }
    
    private static val prefixOperators = newHashSet(NOT, PRE, VAL)
    
    private def boolean requiresParentheses(Expression exp) {
        if (exp instanceof IntValue) {
            return true
        } else if (exp instanceof OperatorExpression) {
            if (!prefixOperators.contains(exp.operator)) {
                return exp.subExpressions.head.requiresParentheses
            } else {
                return false
            }
        } else {
            return false
        }
    }

}
