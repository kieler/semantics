/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.validation

import com.google.common.collect.HashMultimap
import com.google.common.collect.Iterables
import com.google.inject.Inject
import de.cau.cs.kieler.annotations.Annotation
import de.cau.cs.kieler.annotations.AnnotationsPackage
import de.cau.cs.kieler.annotations.StringPragma
import de.cau.cs.kieler.annotations.TypedStringAnnotation
import de.cau.cs.kieler.annotations.extensions.AnnotationsExtensions
import de.cau.cs.kieler.annotations.extensions.PragmaExtensions
import de.cau.cs.kieler.annotations.registry.PragmaRegistry
import de.cau.cs.kieler.kexpressions.Call
import de.cau.cs.kieler.kexpressions.CombineOperator
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.GenericParameterDeclaration
import de.cau.cs.kieler.kexpressions.KExpressionsPackage
import de.cau.cs.kieler.kexpressions.MethodDeclaration
import de.cau.cs.kieler.kexpressions.OperatorExpression
import de.cau.cs.kieler.kexpressions.OperatorType
import de.cau.cs.kieler.kexpressions.ReferenceCall
import de.cau.cs.kieler.kexpressions.ReferenceDeclaration
import de.cau.cs.kieler.kexpressions.SpecialAccessExpression
import de.cau.cs.kieler.kexpressions.ValueType
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.VectorValue
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsAccessVisibilityExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsDeclarationExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsOverloadingExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsTypeExtensions
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsValuedObjectExtensions
import de.cau.cs.kieler.kexpressions.keffects.AssignOperator
import de.cau.cs.kieler.kexpressions.keffects.Assignment
import de.cau.cs.kieler.kexpressions.keffects.Emission
import de.cau.cs.kieler.kexpressions.keffects.extensions.KEffectsExtensions
import de.cau.cs.kieler.kexpressions.kext.KExtPackage
import de.cau.cs.kieler.kexpressions.kext.extensions.BindingType
import de.cau.cs.kieler.kexpressions.kext.extensions.Replacements
import de.cau.cs.kieler.sccharts.Action
import de.cau.cs.kieler.sccharts.BaseStateReference
import de.cau.cs.kieler.sccharts.ControlflowRegion
import de.cau.cs.kieler.sccharts.DataflowRegion
import de.cau.cs.kieler.sccharts.DuringAction
import de.cau.cs.kieler.sccharts.PolicyRegion
import de.cau.cs.kieler.sccharts.PreemptionType
import de.cau.cs.kieler.sccharts.Region
import de.cau.cs.kieler.sccharts.SCCharts
import de.cau.cs.kieler.sccharts.SCChartsPackage
import de.cau.cs.kieler.sccharts.Scope
import de.cau.cs.kieler.sccharts.ScopeCall
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.extensions.SCChartsActionExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsCoreExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsFixExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsInheritanceExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsReferenceExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsScopeExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsStateExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsTransitionExtensions
import de.cau.cs.kieler.sccharts.processors.For
import de.cau.cs.kieler.sccharts.processors.MethodSignaling
import de.cau.cs.kieler.sccharts.text.SCTXResource
import de.cau.cs.kieler.scl.MethodImplementationDeclaration
import java.util.Map
import java.util.Set
import org.eclipse.elk.core.data.LayoutMetaDataService
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.AbstractDeclarativeValidator
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType

import static extension java.lang.String.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SCTXValidator extends AbstractSCTXValidator {

    @Inject extension PragmaExtensions
    @Inject extension SCChartsCoreExtensions
    @Inject extension SCChartsReferenceExtensions
    @Inject extension SCChartsActionExtensions
    @Inject extension SCChartsFixExtensions
    @Inject extension SCChartsTransitionExtensions
    @Inject extension SCChartsStateExtensions
    @Inject extension SCChartsInheritanceExtensions
    @Inject extension SCChartsScopeExtensions
    @Inject extension KExpressionsValuedObjectExtensions
    @Inject extension KExpressionsDeclarationExtensions
    @Inject extension KExpressionsAccessVisibilityExtensions
    @Inject extension KExpressionsOverloadingExtensions
    @Inject extension KEffectsExtensions
    @Inject extension AnnotationsExtensions
    @Inject extension OOClassAnnotations
    
    /** Service class for accessing layout options by name */
    private static final LayoutMetaDataService LAYOUT_OPTIONS_SERVICE = LayoutMetaDataService.getInstance();
    
    static val INFOS_PRAGMA = PragmaRegistry.register("infos", StringPragma, "off: Disables infos in editor.")

    static val String REGION_CANNOT_TERMINATE = "All or none concurrent regions should have final states."
    static val String REGION_NO_INITIAL_STATE = "Every region must have an initial state.";
    static val String REGION_TWO_MANY_INITIAL_STATES = "Every region must not have more than one initial state.";
    static val String REGION_NO_FINAL_STATE = "Every region should have a final state whenever its parent state has a termination transition.";
    static val String STATE_NOT_REACHABLE = "The state is not reachable.";
    static val String NO_REGION = "A state with a termination transition must have inner behaviour.";
    static val String DUPLICATE_REGION = "There are multiple regions with the same name.";
    static val String DUPLICATE_ROOTSTATE = "There are multiple root states with the same name.";
    
    static val String SIGNAL_EMISSION_IN_TRIGGER = "Valued emission cannot be used in triggers. Use val() to check the value of a valued signal.";
    static val String NON_SIGNAL_EMISSION = "Non-signals should not be used in an emission.";
    static val String NO_VALUED_INPUT_SIGNAL_EMISSION = "Valued input signals currently do not support emission (overwriting).";
    static val String NON_VARIABLE_ASSIGNMENT = "Non-variables cannot be used in an assignment.";
    static val String STATIC_VARIABLE_WITHOUT_INITIALIZATION = "Static variables should be initialized.";
    static val String MINMAX_COMBINE = "Min or max combine operators are currently not supported.";
    
    static val String STRONG_ABORT_WITH_LOW_PRIORITY = "Causality problem!\nStrong abort transitions must have a higher priority than weak abort or termination transitions.";
    static val String ABORT_WITHOUT_TRIGGER = "Abort transitions should have a trigger.";
    
    static val String MISSING_BINDING_FOR = "Missing binding for variable: ";

    static val String VALUEDOBJECT_TRANSITION_SCOPE_WRONG = "Variable or signal used out of its scope.\nDeclare it one hierarchy layer up!";
    
    static val String ASSIGNMENT_TO_CONST = "You cannot assign a value to a const object.";
    static val String CANNOT_BIND_ARRAYCELL_TO_ARRAY = "You cannot bind a single array cell to an array."
    static val String CANNOT_BIND_LITERAL_TO_OUTPUT = "You cannot bind a literal to an output object."
    static val String DUPLICATE_VARIABLE = "The variable is declared multiple times in this scope."
    static val String NON_IMMEDIATE_CONNECTOR = "Outgoing transitions of connector states should be marked as immediate."
    static val String NO_DEFAULT_TRANSITION = "Connector states should have an outgoing transition without trigger."
    static val String NO_OUTGOING_TRANSITION = "Connector states must have an outgoing transition."
    static val String NON_REACHABLE_TRANSITION = "The transition is not reachable."
    
    static val String IMMEDIATE_LOOP = "There is an immediate loop. The model is not SASC."
    
    static val String DEPRECATED_IMPORT = "The import pragma is no longer supported. Use import keyword."
    static val String BROKEN_IMPORT = "Broken Import: There is no SCCharts model with the given name."
    static val String BROKEN_FOLDER_IMPORT = "Broken Import: There are no SCCharts models in the given directory."

    static val String COUNT_DELAY_OF_0 = "A count delay of 0 is not allowed on a trigger."
    
    static val String LAYOUT_ANNOTATION_ID = "Invalid layout option id.\nThere is no layout option with the given id or the given suffix is not unique.\nSee https://www.eclipse.org/elk/reference/options.html for all available layout options."
    static val String LAYOUT_ANNOTATION_VALUE = "Invalid layout option value.\nThe given value can not be parsed into a valid value for the given layout option."
    static val String LAYOUT_ANNOTATION_FORMAT = "Layout annotations must have the format '@layout[id] value'"
    
    static val String REGION_ACTION_EXPERIMENTAL = "Actions in regions are highly experimental and may not produce the expected results."  
    
    static val String INHERITANCE_CYCLE = "Inconsistent inheritance hierarchy! Cycle including base state: "
    static val String INHERITANCE_VO_NAME_REUSE = "This variable name is already used in a base state."  
    static val String INHERITANCE_VO_NAME_CLASH = "There is a name clash between declared valued object in inheritance hierarchy. Valued object with name %s is declared multiple times (%s)."
    static val String INHERITANCE_REGION_NAME_CLASH = "There is a name clash between regions IDs in inheritance hierarchy. Region with name %s is declared multiple times (%s)."  

    static val String NO_ASSIGNMENTS_TO_REF = "Assignments to referenced SCCharts are not supported. Except with dataflow semantics (i.e. in a dataflow region)."  

    static val String REGION_OVERRIDE_ANONYMOUS = "Cannot override anonymous region." 
    static val String REGION_OVERRIDE_SUPERFLOUSE = "The is no region to override."  
    static val String REGION_OVERRIDE_MISSING = "There is an inherited region with the same name, you may use the override keyword."
    
    static val String NO_METHOD_REFERENCE = "Methods must be used with call syntax using parenthesis."
    static val String NO_STATE_ACCESS_OUTSIDE_METHOD = "State access expressions are only permissible in methods bodies."
    static val String AMBIGOUS_STATE_ACCESS = "This state access is ambiguous as there are multiple anonymous regions with states with this ID. Use region IDs access the state via RegionID.StateID."

    static val String PRIMITIVE_REF = "Declarations with a primitive type must refer to a primitive generic type."


    @Check
    override checkReferenceAssignment(Assignment asm) {
        super.checkReferenceAssignment(asm)
        val decl = asm.reference?.valuedObject?.eContainer
        if (decl instanceof ReferenceDeclaration) {
            if (asm.reference.subReference === null && decl.reference instanceof de.cau.cs.kieler.sccharts.State && !(asm.eContainer instanceof DataflowRegion)) {
                error(NO_ASSIGNMENTS_TO_REF, asm.reference, null, -1)
            }
        }
    }

    /**
     * Checks for inconsistencies/conflicts in inheritance hierarchy.
     */
    @Check
    def void checkInheritanceHierarchy(de.cau.cs.kieler.sccharts.State state) {
        if (!state.baseStateReferences.nullOrEmpty) {
            for (cycle : state.hierarchyCycles.entries) {
                error(INHERITANCE_CYCLE + cycle.key.name, state, SCChartsPackage.eINSTANCE.state_BaseStateReferences, cycle.value)
            }
        }
    }

    /**
     * Checks for name clashed between inherited states.
     */
    @Check
    def void checkInheritedVONameClash(de.cau.cs.kieler.sccharts.State state) {
        if (!state.baseStateReferences.nullOrEmpty) {
            val voNames = HashMultimap.<String, BaseStateReference>create
            for (base : state.allInheritedStateReferencesHierachically) {
                base.target.declarations.excludeMethods.filter[!isPrivate].map[valuedObjects].flatten.forEach[voNames.put(name, base)]
            }
            val voClashes = voNames.keySet.filter[voNames.get(it).size > 1].toSet
            if (!voClashes.empty) {
                val indirectClashes = state.baseStateReferences.indexed.toMap([key], [value.target !== null ? value.target.allVisibleInheritedDeclarations.excludeMethods.map[valuedObjects].flatten.map[name].toSet : emptySet])
                for (clash : voClashes) {
                    val stateRefs = voNames.get(clash)
                    val marked = newHashSet
                    for (ref : stateRefs) {
                        if (state.baseStateReferences.contains(ref)) {
                            if (!marked.contains(ref)) {
                                marked += ref
                                error(INHERITANCE_VO_NAME_CLASH.format(clash, stateRefs.map[target.name].join(", ")), ref, SCChartsPackage.eINSTANCE.state_BaseStateReferences, state.baseStateReferences.toList.indexOf(ref))
                            }
                        } else { // indirect
                            for (match : indirectClashes.entrySet.filter[value.contains(clash)]) {
                                val markState = state.baseStateReferences.get(match.key)
                                if (markState !== null && !marked.contains(markState)) {
                                    marked += markState
                                    error(INHERITANCE_VO_NAME_CLASH.format(clash, stateRefs.map[target.name].join(", ")), state, SCChartsPackage.eINSTANCE.state_BaseStateReferences, match.key)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Checks for name clashed between inherited states.
     */
    @Check
    def void checkInheritedRegionNameClash(de.cau.cs.kieler.sccharts.State state) {
        if (!state.baseStateReferences.nullOrEmpty) {
            val names = HashMultimap.<String, de.cau.cs.kieler.sccharts.State>create
            for (region : state.allVisibleInheritedRegions) {
                if (!region.name.nullOrEmpty) {
                    names.put(region.name, region.parentState)
                }
            }
            val clashes = names.keySet.filter[names.get(it).size > 1].toSet
            if (!clashes.empty) {
                val indirectClashes = state.baseStates.indexed.toMap([key], [value !== null ? value.allVisibleInheritedRegions.map[name].toSet : emptySet])
                for (clash : clashes) {
                    val states = names.get(clash)
                    val marked = newHashSet
                    for (s : states) {
                        if (state.baseStates.contains(s)) {
                            if (!marked.contains(s)) {
                                marked += s
                                error(INHERITANCE_REGION_NAME_CLASH.format(clash, states.map[name].join(", ")), state, SCChartsPackage.eINSTANCE.state_BaseStateReferences, state.baseStates.toList.indexOf(s))
                            }
                        } else { // indirect
                            for (match : indirectClashes.entrySet.filter[value.contains(clash)]) {
                                val markState = state.baseStates.get(match.key)
                                if (markState !== null && !marked.contains(markState)) {
                                    marked += markState
                                    error(INHERITANCE_REGION_NAME_CLASH.format(clash, states.map[name].join(", ")), state, SCChartsPackage.eINSTANCE.state_BaseStateReferences, match.key)
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Checks for reusing vo names of vo names in inherited states.
     */
    @Check
    def void checkInheritedVONameReuse(de.cau.cs.kieler.sccharts.State state) {
        if (!state.baseStateReferences.nullOrEmpty) {
            val voNames = state.allVisibleInheritedDeclarations.excludeMethods.map[valuedObjects].flatten.map[name].toSet
            for (decl : state.declarations.excludeMethods) {
                for (vo : decl.valuedObjects) {
                    if (voNames.contains(vo.name)) {
                        error(INHERITANCE_VO_NAME_REUSE, vo, null)
                    }
                }
            }
        }
    }
    
    /**
     * Checks if given layout annotation uses an existing unique layout option id (suffix).
     */
    @Check
    def void checkRegionOverride(Region region) {
        if (region.override) {
            if (region.name.nullOrEmpty) {
                error(REGION_OVERRIDE_ANONYMOUS, region, SCChartsPackage.eINSTANCE.region_Override)
            } else {
                val inheritedRegions = region.parentState.getAllVisibleInheritedRegions(false)
                if (!inheritedRegions.exists[region.name.equals(name)]) {
                    error(REGION_OVERRIDE_SUPERFLOUSE, region, SCChartsPackage.eINSTANCE.region_Override)
                }
            }
        } else if (!region.parentState.baseStateReferences.nullOrEmpty && !region.name.nullOrEmpty) {
            val inheritedRegions = region.parentState.getAllVisibleInheritedRegions(true)
            if (inheritedRegions.exists[region.name.equals(name)]) {
                error(REGION_OVERRIDE_MISSING, region, AnnotationsPackage.eINSTANCE.namedObject_Name, -1)
            }
        }
    }
    
    @Check
    def void checkMethods(de.cau.cs.kieler.sccharts.State state) {
        val methodInfos = state.getMethodInheritanceInfos
        val inherited = state.baseStateReferences.indexed.toMap([key], [
            value?.target !== null ?
                Iterables.concat(value.target.declarations, value.target.allInheritedDeclarations).filter(MethodDeclaration).toSet
                : emptySet
        ])
        for (info : methodInfos.filter[!errors.empty]) {
            if (info.inherited) {
                val source = inherited.entrySet.findFirst[value.contains(info.decl)]?.key?:-1
                if (source >= 0) {
                    error(info.errors.join("\n"), state, SCChartsPackage.eINSTANCE.state_BaseStateReferences, source)
                }
            } else {
                error(info.errors.join("\n"), info.decl, null)
            }
        }
    }
    
    @Check
    def void checkMethodCall(ValuedObjectReference vor) {
        val decl = vor.valuedObject?.declaration
        if (decl instanceof MethodDeclaration) {
            var parentRef = vor.topmostReference
            if (!vor.isSubReference) {
                // If method is used directly and not with an specific object
                // and is used as trigger in an transition, no parenthesis are fine,
                // because it is a method observer or policy regions in general.
                var EObject container = parentRef
                while(container !== null) {
                    val nextContainer = container.eContainer
                    if (nextContainer instanceof Transition) {
                        if (nextContainer.trigger == container) {
                            return
                        }
                    } else if (nextContainer instanceof PolicyRegion) {
                        return
                    }
                    container = nextContainer
                }
            }
            if (parentRef instanceof Call) {
                var errorMsg = decl.getMethodSignatureError(parentRef, false)
                if (errorMsg !== null) {
                    error(errorMsg, vor, null)
                }
            } else {
                error(NO_METHOD_REFERENCE, vor, null)
            }
        }
    }
    
    @Check
    def void checkStateAccess(SpecialAccessExpression acc) {
        if (MethodSignaling.ACCESS_KEYWORD.equals(acc.access)) {
            var EObject container = acc
            while(container !== null) {
                if (container instanceof MethodImplementationDeclaration) {
                    // Check ambiguity
                    val scope = acc.nextScope
                    if (scope instanceof de.cau.cs.kieler.sccharts.State) {
                        // Only if no explicit region is specified
                        if (acc.container === null && acc.target !== null) {
                            if (scope.regions.filter(ControlflowRegion).filter[name.nullOrEmpty].map[states].flatten.filter[
                                !it.name.nullOrEmpty && it.name.equals(acc.target.name)
                            ].size > 1) {
                                // If there are multiple states with the target's name
                                error(AMBIGOUS_STATE_ACCESS, acc, KExpressionsPackage.eINSTANCE.specialAccessExpression_Target)
                            }
                        }
                    }
                    return
                }
                container = container.eContainer
            }
            error(NO_STATE_ACCESS_OUTSIDE_METHOD, acc, null)
        }
    }
    
    /**
     * OO Class annotations
     */
    @Check
    def void checkOOClassAnnotationInSCChart(de.cau.cs.kieler.sccharts.State state) {
        if (state.isRootState) {
            validateOOClassAnnotationInSCChart(state, getMessageAcceptor())
        }
    }
    /**
     * OO Class annotations
     */
    @Check
    def void checkOOClassAnnotationInReference(ReferenceDeclaration decl) {
        if (decl.reference !== null) {
            validateOOClassAnnotationInReference(decl, getMessageAcceptor())
        }
    }
    
    /**
     * Checks if given layout annotation uses an existing unique layout option id (suffix).
     */
    @Check
    def void checkRegionActions(Action action) {
        if (action.eContainer instanceof ControlflowRegion && (action.eContainer as ControlflowRegion).states.exists[final]) {
            warning(REGION_ACTION_EXPERIMENTAL, action, null);
        }
    }
    
    @Check
    def void checkBaseStateBindings(BaseStateReference ref) {
        val state = ref.eContainer as de.cau.cs.kieler.sccharts.State
        if (!state.rootState) {
            val bindings = ref.createBindings(new Replacements)
            var errorMessages = newArrayList
            for (binding : bindings) {
                if (binding.errors > 0) {
                    errorMessages += binding.errorMessages
                }
            }
            
            if (!errorMessages.empty) {
                error("The binding of inherited variables is erroneous!\n" + errorMessages.join("\n"),
                    state, SCChartsPackage.eINSTANCE.state_BaseStateReferences,
                    state.baseStateReferences.indexOf(ref) );
            }
        }
    }

    /**
     * Checks if given layout annotation uses an existing unique layout option id (suffix).
     */
    @Check
    def void checkLayoutAnnotation(Annotation anno) {
        if ("layout".equals(anno.name)) { // FIXME magic string
            if (anno instanceof TypedStringAnnotation) {
                val data = LAYOUT_OPTIONS_SERVICE.getOptionDataBySuffix(anno.type ?: "")
                if (data === null) {
                    warning(LAYOUT_ANNOTATION_ID, anno, null);
                } else {
                    if (data.parseValue(anno.values?.head ?: "".toLowerCase) === null) {
                        warning(LAYOUT_ANNOTATION_VALUE, anno, null);
                    }
                }
            } else {
                warning(LAYOUT_ANNOTATION_FORMAT, anno, null);
            }
        }
    }


    @Check
    def void checkImportPragma(StringPragma pragma) {
        if (SCTXResource.DEPRECATED_PRAGMA_IMPORT.equals(pragma.name)) {
            error(DEPRECATED_IMPORT, pragma, null)
        }
    }
    
    @Check
    def void checkImports(SCCharts scc) {
        if (!scc.imports.nullOrEmpty && scc.eResource !== null) {
            val res = scc.eResource as SCTXResource
            for (var i = 0; i < scc.imports.size; i++) {
                val import = scc.imports.get(i)
                if (res.directImports.get(import).empty) {
                    if (import.endsWith("*")) {
                        warning(BROKEN_FOLDER_IMPORT, scc, SCChartsPackage.eINSTANCE.SCCharts_Imports, i);
                    } else {
                        warning(BROKEN_IMPORT, scc, SCChartsPackage.eINSTANCE.SCCharts_Imports, i);
                    }
                }
            }
        }
    }
    
    /**
     * Check that there are no immediate loops between states in a region.
     * 
     * @param region The region 
     */
    // NORMAL Check is executed on save/build and request only
    @Check(NORMAL)
    public def void checkNoImmediateLoops(ControlflowRegion region) {
        // Perform depth first search on states,
        // where edges are the immediate transitions to find potentially immediate loops.
        val states = region.states
        // Map to remember which states have been visited already
        val Map<de.cau.cs.kieler.sccharts.State, Integer> visited = newHashMap
        for(state : states) {
            val hasLoop = findImmediateLoop(state, visited)
            if(hasLoop) {
                // Loop detected, so add warning marker on all involved states
                val Set<de.cau.cs.kieler.sccharts.State> statesWithLoop = newHashSet
                for(entry : visited.entrySet) {
                    if(entry.value == 1) {
                        statesWithLoop.add(entry.key)
                    }
                }
                val message = IMMEDIATE_LOOP + "\nInvolved states: " + statesWithLoop.map[it.name]
                for(s : statesWithLoop) {
                    // Highlight immediate transitions that lead to states, which are part of the loop.
                    // This is more helpful than highlighting the complete state.
                    for(t : s.outgoingTransitions) {
                        if(t.isImplicitlyImmediate && statesWithLoop.contains(t.targetState)) {
                            warning(message, t, null)
                        }
                    }
                }
                return;
            }
        }
    }
    
    /**
     * Helper method to find immediate loops.
     * 
     * @param state The state that is checked for loops
     * @param visited Data structure with the information whether states have been visited before.
     * @return true if a loop was detected. In this case the involved states will have a visited value of 1 in the map.
     */
    private def boolean findImmediateLoop(de.cau.cs.kieler.sccharts.State state, Map<de.cau.cs.kieler.sccharts.State, Integer> visited) {
        val visitedCode = visited.getOrDefault(state, 0)
        if(visitedCode == 2) {
            // Finished before without cycle
            return false    
        } else if(visitedCode == 1) {
            // Found cycle
            return true
        }
        // Now visited
        visited.put(state, 1)
        // Find loops in outgoing immediate transitions.
        for(t : state.outgoingTransitions) {
            // Ignore termination transitions because they could have non-immediate inner behaviour.
            val isTerminationTransition = (t.preemption == PreemptionType.TERMINATION)
            if(!isTerminationTransition && t.isImplicitlyImmediate) {
                val target = t.targetState
                // It is not checked whether or not a superstate has a delay.
                // A appropriate check should be implemented in the future. 
                if(findImmediateLoop(target, visited)) {
                    return true
                }
            }
        }
        // Now finished without cycle
        visited.put(state, 2)
        return false
    }
    
    /**
     * Discourage emissions of non-signals
     *
     * @param state the state
     */
    @Check
    def void checkNoBooleanEmissions(Emission emission) {
        if (emission.getValuedObject() !== null && emission.getValuedObject().eContainer() !== null && emission.getValuedObject().eContainer() instanceof Declaration) {
            val declaration = emission.getValuedObject().declaration
            if (declaration instanceof VariableDeclaration && !(declaration as VariableDeclaration).signal) {
                warning(NON_SIGNAL_EMISSION, emission, null, -1);
            }
        } 
    }
    
    /**
     * Discourage emissions of valued input signals
     */
    @Check
    def void checkValuedInputSignalEmissions(Emission emission) {
        if (emission.valuedObject !== null && emission.valuedObject.variableDeclaration !== null) {
            val decl = emission.valuedObject.variableDeclaration
            if (decl.signal && decl.input && decl.type !== ValueType.PURE) {
                warning(NO_VALUED_INPUT_SIGNAL_EMISSION, null, -1);
            }
        }
    }
    
    /**
     * ReferenceCalls in triggers allow some kind of emission in trigger that must be discouraged. 
     */
    @Check
    def void checkNoBooleanEmissions(ReferenceCall call) {
        if (call.valuedObject !== null && call.valuedObject.isSignal) {
            var EObject obj = call
            var container = call.eContainer
            while (container !== null && !(container instanceof Transition)) {
                if (container instanceof Scope) {
                    container = null
                } else {
                    obj = container
                    container = obj.eContainer
                }
            }
            if (container instanceof Transition) {
                if (container.trigger === obj) {
                    error(SIGNAL_EMISSION_IN_TRIGGER, call, null, -1);
                }
            }         
        }
    }
    
    /**
     * Region names must be unique
     *
     * @param state the State
     */
    @Check
    def void checkDuplicateRegionNames(de.cau.cs.kieler.sccharts.State state) {
        val names = <String> newHashSet
        for(r : state.regions) {
            val name = r.name
            if(!name.isNullOrEmpty) {
                if(names.contains(name)) {
                    warning(DUPLICATE_REGION+" '"+name+"'", r, AnnotationsPackage.eINSTANCE.namedObject_Name, -1)
                } else {
                    names.add(name)
                }    
            }
        }
    }
    
    /**
     * Root state names must be unique
     *
     */
    @Check
    def void checkDuplicateRootStateNames(SCCharts scc) {
        val names = <String> newHashSet
        for(r : scc.rootStates) {
            val name = r.name
            if(!name.isNullOrEmpty) {
                if(names.contains(name)) {
                    warning(DUPLICATE_ROOTSTATE+" '"+name+"'", r, AnnotationsPackage.eINSTANCE.namedObject_Name, -1)
                } else {
                    names.add(name)
                }    
            }
        }
    }
    
    // -------------------------------------------------------------------------    

    /**
     * Forbid assignments of non-variables
     *
     * @param state the state
     */
    @Check
    def void checkNoBooleanEmissions(Assignment assignment) {
        if (assignment.getValuedObject() !== null && assignment.getValuedObject().eContainer() !== null && assignment.getValuedObject().eContainer() instanceof Declaration) {
            val declaration = assignment.getValuedObject().declaration
            if (declaration instanceof VariableDeclaration && (declaration as VariableDeclaration).signal) {
                error(NON_VARIABLE_ASSIGNMENT, assignment, null, -1);
            }
        } 
    }

    // -------------------------------------------------------------------------

    /**
     * A state should be reachable from an initial state.
     *
     * @param state the state
     */
    @Check
    def void checkReachableStates(de.cau.cs.kieler.sccharts.State state) {
        if (!state.isStateReachable) {
           warning(STATE_NOT_REACHABLE, state, null, -1);
        }
    }
        
    /**
     * Check that there are no transitions that are not reachable, i.e.,
     * no transitions after a transition without guard.
     * 
     * @param state The state 
     */
    @Check
    public def void checkTransitionsAreReachable(de.cau.cs.kieler.sccharts.State state) {
        var boolean delayedTransitionWithoutTrigger = false
        var boolean immediateTransitionWithoutTrigger = false
        for(trans : state.outgoingTransitions) {
            if(trans.isImplicitlyImmediate) { 
                // An immediate transition may follow after a delayed transition without trigger, and still be reachable.
                if(immediateTransitionWithoutTrigger) {
                    warning(NON_REACHABLE_TRANSITION, trans, null)
                }
                if(!immediateTransitionWithoutTrigger && trans.trigger === null) {
                    // A termination transition does not count, because the inner behavior defines a trigger
                    if(!trans.isTermination) {
                        immediateTransitionWithoutTrigger = true    
                    }
                }
            } else {
                // An delayed transition after a delayed transition without trigger is not reachable.
                // Neither is a delayed transition after an immediate transition without trigger.
                if(delayedTransitionWithoutTrigger || immediateTransitionWithoutTrigger) {
                    warning(NON_REACHABLE_TRANSITION, trans, null)
                }
                if(!delayedTransitionWithoutTrigger && trans.trigger === null) {
                    delayedTransitionWithoutTrigger = true
                }
            }
        }
    }

    /**
     * Check that connector states have only immediate transitions and have a default transition.
     * 
     * @param state The state 
     */
    @Check
    public def void checkConnectorTransitions(de.cau.cs.kieler.sccharts.State state) {
        if(state.connector) {
            var Transition lastTransition
            var boolean transitionWithoutTrigger = false
            for(trans : state.outgoingTransitions) {
                if(!trans.isImmediate) {
                    warning(NON_IMMEDIATE_CONNECTOR, trans, null)
                }
                if(trans.trigger === null) {
                    transitionWithoutTrigger = true
                }
                lastTransition = trans
            }
            if(!transitionWithoutTrigger) {
                warning(NO_DEFAULT_TRANSITION, lastTransition, null)
            }
            if(lastTransition === null) {
                error(NO_OUTGOING_TRANSITION, state, null)
            }
        }
    }

    /**
     * Check that names of variables are unique within a scope.
     * 
     * @param scope The scope 
     */
    @Check
    public def void checkDuplicateVariable(Scope scope) {
        val Set<String> variableNames = newHashSet()
        for(decl : scope.declarations.excludeMethods) { 
            for(valuedObject : decl.valuedObjects) {
                val name = valuedObject.name
                if(variableNames.contains(name)) {
                    warning(DUPLICATE_VARIABLE, valuedObject, null)
                } else {
                    variableNames.add(name)
                }
            }
        }
    }

    /**
     * Check if max or min is used which is currently not supported
     *
     * @param valuedObject the valuedObject
     */
    @Check
    public def void checkMinMaxUsedCombinationFunction(ValuedObject valuedObject) {
        // Check if actually a valued signal
        if(valuedObject.isSignal && !valuedObject.isPureSignal) {
            // Check if there is a combine operator
            if(valuedObject.combineOperator !== null) {
                if (valuedObject.combineOperator.equals(CombineOperator.MIN) || valuedObject.combineOperator.equals(CombineOperator.MAX))
                warning(MINMAX_COMBINE, valuedObject, null)
            }
        }
    } 
    
    /**
     * Check if there is exactly ONE initial state per region.
     *
     * @param region the region
     */
    @Check
    public def void checkInitialState(ControlflowRegion region) {
        // Do not consider the root region == SCChart
        if (region.getParentState() !== null) {
            // check if parent state has declared any REAL region not only a
            // dummy region for entry/during/exit actions or suspends
            val parentState = region.getParentState
            var int foundInitial = 0;
            if ((parentState.actions.size() > 0) && (parentState.getRegions().size() == 1)
                    && parentState.getRegions().filter(typeof(ControlflowRegion)).head.getStates().size() == 0
                    && (parentState.getRegions().head.name === null
                        || parentState.getRegions().head.name.equals(""))) {
                foundInitial = 1;
            }
            if (region.reference !== null) {
                foundInitial = 1
            }
            for (de.cau.cs.kieler.sccharts.State state : region.getStates()) {
                if (state.isInitial()) {
                    foundInitial = foundInitial + 1;
                }
            }
            if (foundInitial == 0) {
                error(REGION_NO_INITIAL_STATE, region, null, -1);
            } else if (foundInitial > 1) {
                error(REGION_TWO_MANY_INITIAL_STATES, region, null, -1);
            }
        }
    }
    
    /**
     * A final state only makes sense if all regions can terminate.
     * Thus if there is one final state, the other regions should also have final states.
     * 
     * @param state the state
     */
    @Check
    public def void checkAllHaveFinalStates(ControlflowRegion region) {
        val finalStates = region.states.filter[it.isFinal]
        if(!finalStates.isNullOrEmpty) {
            for(r : region.parentState.regions.filter(ControlflowRegion)) {
                // Only check other regions
                if(r !== region) {
                    val otherHasFinalState = r.states.exists[it.isFinal]
                    // Warn if this region cannot terminate
                    if(!otherHasFinalState) {
                        for(finalState : finalStates) {
                            warning(REGION_CANNOT_TERMINATE, finalState, AnnotationsPackage.eINSTANCE.namedObject_Name);
                        }
                    }
                }
            }
        }
    }
    
    /**
     * A state with a termination transition should have final states in all its
     * inner regions. 
     * A simple state with a termination transition must have inner behaviour or no termination transition at all.
     * 
     * @param state the state
     */
    @Check
    public def void checkFinalStates(de.cau.cs.kieler.sccharts.State state) {
        // Check if state has termination transition
        val terminationTransitions = state.outgoingTransitions.filter[ isTermination ]
        val foundTermination = !terminationTransitions.empty
        if (foundTermination) {
            // Assert inner behaviour
            val regions = state.regions.filter(ControlflowRegion)
            val dataflowRegions = state.regions.filter(DataflowRegion)
            if(regions.isEmpty && state.reference === null && dataflowRegions.isEmpty) {
                val trans = terminationTransitions.get(0)
                error(NO_REGION, trans, null, -1);
            }

            // Now test for every region
            if (state.actions.nullOrEmpty) {
                for (region : regions) {
                    val foundFinal = !region.states.filter[ isFinal ].empty
                    if (!foundFinal) {
                        warning(REGION_NO_FINAL_STATE, region, AnnotationsPackage.eINSTANCE.namedObject_Name, -1);
                    }
                }
            }
        }
    }
    
    /**
     * Checks that no superfluous count delays are used.
     */
    @Check
    public def void checkCountDelayGreaterThan1(Transition transition) {
        if(transition.triggerDelay == 0) {
            error(COUNT_DELAY_OF_0, transition.trigger, null)
        }
    }
    
    /**
     * Checks if the given state has any strong abort transitions with lower priority than non-strong-abort transitions-
     */
    @Check
    public def void checkLowPriorityStrongAbort(de.cau.cs.kieler.sccharts.State state) {
        var onlyStrongAbortsBefore = true;
        // Checking priority by order
        for (transition : state.outgoingTransitions) {
            if (onlyStrongAbortsBefore && !transition.isStrongAbort) {
                onlyStrongAbortsBefore = false;
            } else if (!onlyStrongAbortsBefore && transition.isStrongAbort) {
                error(STRONG_ABORT_WITH_LOW_PRIORITY, transition, null, -1);
            }
        }
    } 

    /**
     * Checks if the given state has abort transitions without trigger and adds a warning.
     * In most cases an abort without trigger is meant to be a termination transition.
     */
    @Check
    public def void checkAbortHasTrigger(de.cau.cs.kieler.sccharts.State state) {
        if(state.isHierarchical) {
            for (transition : state.outgoingTransitions) {
                if ((transition.isStrongAbort || transition.isWeakAbort)
                    && transition.trigger === null) {
                    warning(ABORT_WITHOUT_TRIGGER, transition, null, -1);
                }
            }
        }
    } 
    
    /**
     * Checks that static variables are initialized.
     * If it is not initialized the static modifier is useless from a modeling perspective.   
     */
    @Check
    public def void checkStaticVariableIsInitialized(ValuedObject valuedObject) {
        if(valuedObject.isStatic && valuedObject.initialValue === null) {
            warning(STATIC_VARIABLE_WITHOUT_INITIALIZATION, valuedObject, null)
        }
    } 
    
    /**
     * Checks scope of valued objects of transition triggers are correct.
     */
    @Check
    public def void checkScopeOfOutgoingTransitionVarRefs(ValuedObject testValuedObject) {
        val stateOrRegion = testValuedObject.eContainer.eContainer
        var de.cau.cs.kieler.sccharts.State state
        if (stateOrRegion instanceof AbstractDeclarativeValidator.State) {
            state = (stateOrRegion as de.cau.cs.kieler.sccharts.State)
        } else if (stateOrRegion instanceof ControlflowRegion) {
            val region = (stateOrRegion as ControlflowRegion)
            state = region.parentState
        } else {
            return
        }
        
        for (transition : state.outgoingTransitions) {
            val valuedObjectRefs = transition.eAllContents.filter(typeof(ValuedObjectReference))
            if (valuedObjectRefs.filter[valuedObject == testValuedObject].size > 0) {
                error(VALUEDOBJECT_TRANSITION_SCOPE_WRONG, testValuedObject, null, -1);
            }
        }
    }
    
    /**
     *
     * @param state the state
     */
    @Check
    def void checkAssignmentToConst(Assignment assignment) {
        if (assignment.getValuedObject() !== null) {
            val declaration =  assignment.getValuedObject.variableDeclaration
            if (declaration !== null && declaration.isConst()) {
                error(ASSIGNMENT_TO_CONST, assignment, null, -1);
            }
        }
    }
    
    @Check
    def void checkScopeCall(ScopeCall scopeCall) {
        if (scopeCall.eContainer instanceof Scope) {
            if (scopeCall.^super) {
                if (!scopeCall.parameters.empty) {
                    error("A reference to a super scope must not have parameters!", scopeCall, KExpressionsPackage.eINSTANCE.call_Parameters);
                }
                if (!scopeCall.genericParameters.empty) {
                    error("A reference to a super scope must not have generic parameters!", scopeCall, SCChartsPackage.eINSTANCE.scopeCall_GenericParameters);
                }
                return // No binding -> no checks
            }
            val bindings = scopeCall.eContainer.asScope.createBindings
            var errorMessages = newArrayList
            var implicitMessage = ""
            for (binding : bindings) {
                if (binding.errors > 0) {
                    errorMessages += binding.errorMessages
                }
                if (binding.type == BindingType.IMPLICIT) {
                    implicitMessage += binding.targetValuedObject.name + ", "
                    implicitMessage.replaceFirst(", $", "")
                }
            }
            
            if (!errorMessages.empty) {
                error("The referencing binding is erroneous!\n" + errorMessages.join("\n"),
                    scopeCall, 
                    SCChartsPackage.eINSTANCE.scopeCall_Target, 
                    "The referencing binding is erroneous!\n" + errorMessages.join("\n"));
            } else if (implicitMessage != "" && scopeCall.eContainer instanceof de.cau.cs.kieler.sccharts.State) {
                warning("Valued Objects are bound implicitly!\n" + implicitMessage,
                    scopeCall, 
                    SCChartsPackage.eINSTANCE.scopeCall_Target, 
                    "Valued Objects are bound implicitly!\n" + implicitMessage);
            }
        }
    }
    
    @Check
    def void checkReferencingStateFinalState(de.cau.cs.kieler.sccharts.State state) {
        if (!state.isReferencing) return;
        if (state.terminationTransitions.empty) return;
        
        val scope = state.reference.resolveReferencedScope
            
        if (scope !== null && !scope.asState.mayTerminate) {
            warning("The referenced SCChart does not terminate, but you are using a termination to proceed.",
                state.reference,
                SCChartsPackage.eINSTANCE.scopeCall_Target);
        }            
    }

    @Check
    def void checkPrimitiveReferenceDeclaration(ReferenceDeclaration decl) {
        if (decl.simple && decl.reference !== null) {
            val vo = decl.reference
            if (vo instanceof ValuedObject) {
                val generic = vo.declaration
                if (generic instanceof GenericParameterDeclaration) {
                    if (!(generic.valueType === ValueType.PRIMITIVE 
                        || KExpressionsTypeExtensions.PRIMITIVES.contains(generic.valueType))) {
                        error(PRIMITIVE_REF, decl, KExpressionsPackage.eINSTANCE.referenceDeclaration_Reference, -1)
                    }
                } else {
                    error(PRIMITIVE_REF, decl, KExpressionsPackage.eINSTANCE.referenceDeclaration_Reference, -1) 
                }
            } else {
                error(PRIMITIVE_REF, decl, null) 
            }
        }
    }
    
    @Check
    def void checkReferenceDeclarationBindings(ReferenceDeclaration decl) {
        if (decl.reference instanceof Scope) {
            for (vo : decl.valuedObjects) {
                if (vo.initialValue !== null) {
                    error("Valued objects of referenced SCCharts cannot be initialized manually.", vo.initialValue, null, -1)
                }
            }
        }
        
        if (decl.hasAnnotation("noBindingCheck")) {
            return
        }
        
        if (decl.input) {
            if (!decl.parameters.empty) {
                error("An input reference must not have parameters!", decl, KExpressionsPackage.eINSTANCE.referenceDeclaration_Parameters);
            }
            if (!decl.genericParameters.empty) {
                error("An input reference must not have generic parameters!", decl, KExpressionsPackage.eINSTANCE.referenceDeclaration_GenericParameters);
            }
            for (vo : decl.valuedObjects) {
                if (!vo.parameters.empty) {
                    error("An input reference must not have parameters!", vo, KExpressionsPackage.eINSTANCE.valuedObject_Parameters);
                }
                if (!vo.genericParameters.empty) {
                    error("An input reference must not have generic parameters!", vo, KExpressionsPackage.eINSTANCE.valuedObject_GenericParameters);
                }
            }
            return // No binding -> no checks
        }
        
        val parent = decl.nextScope
        val dfVOs = newHashSet
        if (parent instanceof de.cau.cs.kieler.sccharts.State) {
            for (vo : decl.valuedObjects) {
                if (parent.regions.filter(DataflowRegion).exists[eAllContents.filter(ValuedObjectReference).exists[valuedObject === vo]]) {
                    dfVOs += vo // Do not check those instanciated by dataflow regions
                }
            }
        } else if (parent instanceof DataflowRegion) {
            for (vo : decl.valuedObjects) {
                if (parent.eAllContents.filter(ValuedObjectReference).exists[valuedObject === vo]) {
                    dfVOs += vo // Do not check those instanciated by dataflow regions
                }
            }
        }
        
        if (dfVOs.size === decl.valuedObjects.size) {
            return
        } else if (!dfVOs.empty) {
            warning("This reference declaration contains some valued objects that are used in dataflow regions and some not. This might cause problems since reference valued objects not used in dataflow will be instaciated as class instances.",
                parent, KExtPackage.eINSTANCE.declarationScope_Declarations, parent.declarations.indexOf(decl))
        }
        
        if (!dfVOs.empty || (decl.valuedObjects.size > 1 && decl.valuedObjects.exists[!parameters.empty || !genericParameters.empty])) {
            // Check each VO
            for (vo : decl.valuedObjects.filter[!dfVOs.contains(it)]) {
                val bindings = vo.createBindings(new Replacements)
                var errorMessages = newArrayList
                for (binding : bindings) {
                    if (binding.errors > 0) {
                        errorMessages += binding.errorMessages
                    }
                }
                
                if (!errorMessages.empty) {
                    error("The referencing binding is erroneous!\n" + errorMessages.join("\n"),
                        decl, 
                        KExpressionsPackage.eINSTANCE.declaration_ValuedObjects,
                        decl.valuedObjects.indexOf(vo));
                }
            }
        } else {
            // One check for all
            val bindings = decl.valuedObjects?.head?.createBindings(new Replacements)
            var errorMessages = newArrayList
            for (binding : bindings) {
                if (binding.errors > 0) {
                    errorMessages += binding.errorMessages
                }
            }
            
            if (!errorMessages.empty) {
                error("The referencing binding is erroneous!\n" + errorMessages.join("\n"),
                    decl, 
                    KExpressionsPackage.eINSTANCE.referenceDeclaration_Reference);
            }
        }
    }
    
    @Check
    def void checkActionTriggerEffectsWithLabel(Action action) {
        if (!action.label.nullOrEmpty) {
            if (action.trigger !== null) {
                if (infosEnabled(action))
                    info("The trigger of this action is hidden by the label.", 
                        action, 
                        SCChartsPackage.eINSTANCE.action_Trigger)
            }
            if (action.effects !== null && action.effects.size > 0) {
                if (infosEnabled(action))
                    info("The effects of this action are hidden by the label.", 
                        action, 
                        SCChartsPackage.eINSTANCE.action_Effects)
            }
        }
    }
    
    @Check
    def void checkCountDelayOnDuringAction(DuringAction action) {
        if (action.triggerDelay > 1) {
            warning("Count Delays on During Actions are not supported yet. The valued will be ignored by the transformation.",
                action, SCChartsPackage.eINSTANCE.action_TriggerDelay);
        }
    }
    
    @Check
    def void checkForRegion(ControlflowRegion region) {
        if (region.forStart !== null && region.forStart instanceof ValuedObjectReference) {
            val forRange = For.getForRegionRange(region)
            if (forRange.value == -1) {
                error("The range of the counter variable of the for region is not determinable. The array cardinalities of you array must be an int or a const int.",
                    region, SCChartsPackage.eINSTANCE.state_Regions
                )
            }
        }
    }
    
    @Check(CheckType.NORMAL)
    def void checkDataflowVectorAssignment(DataflowRegion dataflowRegion) {
        for(equation : dataflowRegion.equations) {
            val reference = equation.reference
            if (reference instanceof ValuedObjectReference) {
                if (reference.valuedObject.declaration instanceof ReferenceDeclaration) {
                    if (reference.subReference === null && !(equation.expression instanceof VectorValue)) {
                        error("You are assigning a scalar value to a reference. You should specify the input variable of the reference or use a vector value instead of a scalar.",
                            equation, null)
                    }
                }
            }
        }
    }
    
    @Check(CheckType.NORMAL)
    def void checkCorrectExternalReferenceObjects(ValuedObjectReference valuedObjectReference) {
        val valuedObject = valuedObjectReference.valuedObject
        if (valuedObject?.isExternalReference) {
            if (!(valuedObjectReference instanceof ReferenceCall)) {
                warning("You are using an external reference without call syntax. If you want to generate a call, you must add parentheses.", 
                    valuedObjectReference, null)
            }
        }
    }
    
    @Check(CheckType.NORMAL) 
    def void checkFloatingPointTriggerComparison(Action action) {
        if (action.trigger !== null) {
            val trigger = action.trigger
            if (trigger instanceof ValuedObjectReference) {
                if (trigger.valuedObject.isFloat) {
                    error("Float tests must have a comparison operator!", 
                        action.trigger, null)
                }
            }
        }
    }

    @Check(CheckType.NORMAL) 
    def void checkOldStyleRelativeWriteSyntax(Action action) {
        for (assignment : action.effects.filter(Assignment).filter[ reference !== null && operator == AssignOperator.ASSIGN ]) {
            val readVOs = assignment.expression.eAllContents.filter(ValuedObjectReference).
                filter[ it.eContainer instanceof OperatorExpression && 
                    (it.eContainer as OperatorExpression).subExpressions.size > 1
                ].map[valuedObject].toSet
            if (readVOs.contains(assignment.reference.valuedObject)) {
                warning("This assignment looks like old relative write SC syntax and is considered deprecated.\n" + 
                    "If you want to create a relative write in new syntax, please use an infix assignment operator.", assignment, null
                )
            }
        }
    }


    @Check
    def void checkCountDelayBeforeSubExpressionWarning(Action action) {
        if (action.triggerDelay > 1) {
            if (action.trigger instanceof OperatorExpression) {
                if ((action.trigger as OperatorExpression).hasLeftUnarySubExpression) {
                    warning("A count delay was recognized in front of an unary operation.\n" + 
                        "If this is not intended, use parentheses to surround your expression.",
                        action, null)
                }
            }
        }
    } 
    
    private def boolean hasLeftUnarySubExpression(OperatorExpression operatorExpression) {
        val firstExpression = operatorExpression.subExpressions.head
        if (firstExpression instanceof OperatorExpression) {
            if (firstExpression.operator == OperatorType.SUB && firstExpression.subExpressions.size == 1) {
                return true
            } else {
                return firstExpression.hasLeftUnarySubExpression
            }
        } else {
            return false
        }
    }

        
    // ENFORCER SPECIFIC
    
    public static val DIRECTOR = "director"
    public static val ENFORCER = "Enforcer"
    
    public static val CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR = 
        "Violation states require enforcer director" 
        
    @Check
    def void checkViolationState(de.cau.cs.kieler.sccharts.State state) {
        if (state.violation) {
            val scc = state.getSCCharts
            if (!scc.getStringPragmas(DIRECTOR).last.values.head.equals(ENFORCER)) {
                error(CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR, state, 
                    SCChartsPackage.eINSTANCE.state_Violation, CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR
                )
            }
        }
    }
    
    
    private def boolean infosEnabled(EObject eObject) {
        val scc = eObject.getSCCharts
        val infoPragma = scc.getStringPragmas(INFOS_PRAGMA).head
        if (infoPragma !== null && infoPragma.values.size > 0 && infoPragma.values.head.equals("off")) {
            return false
        }
        return true
    }
    
    
}
