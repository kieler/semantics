/*
 * generated by Xtext
 */
package de.cau.cs.kieler.sccharts.text.validation

import com.google.inject.Inject
import de.cau.cs.kieler.annotations.extensions.AnnotationsExtensions
import de.cau.cs.kieler.kexpressions.CombineOperator
import de.cau.cs.kieler.kexpressions.Declaration
import de.cau.cs.kieler.kexpressions.ValuedObject
import de.cau.cs.kieler.kexpressions.ValuedObjectReference
import de.cau.cs.kieler.kexpressions.VariableDeclaration
import de.cau.cs.kieler.kexpressions.extensions.KExpressionsValuedObjectExtensions
import de.cau.cs.kieler.kexpressions.keffects.Assignment
import de.cau.cs.kieler.kexpressions.keffects.Emission
import de.cau.cs.kieler.sccharts.ControlflowRegion
import de.cau.cs.kieler.sccharts.SCChartsPackage
import de.cau.cs.kieler.sccharts.Scope
import de.cau.cs.kieler.sccharts.ScopeCall
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.extensions.BindingType
import de.cau.cs.kieler.sccharts.extensions.SCChartsActionExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsControlflowRegionExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsCoreExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsFixExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsReferenceExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsScopeExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsStateExtensions
import de.cau.cs.kieler.sccharts.extensions.SCChartsTransitionExtensions
import java.util.Map
import java.util.Set
import org.eclipse.xtext.validation.AbstractDeclarativeValidator
import org.eclipse.xtext.validation.Check
import de.cau.cs.kieler.sccharts.Action
import org.eclipse.emf.ecore.EObject
import de.cau.cs.kieler.annotations.registry.PragmaRegistry
import de.cau.cs.kieler.annotations.StringPragma
import de.cau.cs.kieler.sccharts.processors.transformators.For

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SCTXValidator extends AbstractSCTXValidator {

    @Inject extension AnnotationsExtensions
    @Inject extension SCChartsCoreExtensions
    @Inject extension SCChartsScopeExtensions
    @Inject extension SCChartsReferenceExtensions
    @Inject extension SCChartsActionExtensions
    @Inject extension SCChartsControlflowRegionExtensions
    @Inject extension SCChartsFixExtensions
    @Inject extension SCChartsTransitionExtensions
    @Inject extension SCChartsStateExtensions
    @Inject extension KExpressionsValuedObjectExtensions
    
    static val INFOS_PRAGMA = PragmaRegistry.register("infos", StringPragma, "off: Disables infos in editor.")
        
    static val String REGION_NO_INITIAL_STATE = "Every region must have an initial state";
    static val String REGION_TWO_MANY_INITIAL_STATES = "Every region must not have more than one initial state";
    static val String REGION_NO_FINAL_STATE = "Every region should have a final state whenever its parent state has a termination transition";
    static val String STATE_NOT_REACHABLE = "The state is not reachable";
    static val String NO_REGION = "A state with a termination transition must have inner behaviour";
    
    static val String NON_SIGNAL_EMISSION = "Non-signals sould be used in an emission";
    static val String NON_VARIABLE_ASSIGNMENT = "Non-variables cannot be used in an assignment";
    static val String STATIC_VARIABLE_WITHOUT_INITIALIZATION = "Static variables should be initialized";
    //TODO (KISEMA-1071) Remove this message when there is a transformation that handles valued signals without combine operator.
    static val String VALUED_SIGNAL_NEED_COMBINE = "Valued signals must have a combine function";
    static val String MINMAX_COMBINE = "Min or max combine operators are currently not supported";
    static val String NOCOMBINE = "A valued signal should have a combine function, otherwise any emits cannot be scheduled.";
    
    static val String STRONG_ABORT_WITH_LOW_PRIORITY = "Causality problem! Strong abort transitions must have a higher priority than weak abort or termination transitions.";
    static val String ABORT_WITHOUT_TRIGGER = "Abort transitions should have a trigger";
    
    static val String MISSING_BINDING_FOR = "Missing binding for variable: ";

    static val String VALUEDOBJECT_TRANSITION_SCOPE_WRONG = "Variable or signal used out of its scope. Declare it one hierarchy layer up!";
    
    static val String ASSIGNMENT_TO_CONST = "You cannot assign a value to a const object.";
    static val String CANNOT_BIND_ARRAYCELL_TO_ARRAY = "You cannot bind a single array cell to an array."
    static val String CANNOT_BIND_LITERAL_TO_OUTPUT = "You cannot bind a literal to an output object."
    static val String DUPLICATE_VARIABLE = "The variable is declared multiple times in this scope."
    static val String NON_IMMEDIATE_CONNECTOR = "Outgoing transitions of connector states should be marked as immediate."
    static val String NO_DEFAULT_TRANSITION = "Connector states should have an outgoing transition without trigger."
    static val String NO_OUTGOING_TRANSITION = "Connector states must have an outgoing transition."
    static val String NON_REACHABLE_TRANSITION = "The transition is not reachable."
    
    static val String IMMEDIATE_LOOP = "There is an immediate loop. The model is not SASC."

    /**
     * Check that there are no immediate loops between states in a region.
     * 
     * @param region The region 
     */
    // Normal validation occurs when the xtext build is triggered. 
    @Check(NORMAL)
    public def void checkNoImmediateLoops(ControlflowRegion region) {
        // Perform depth first search on states,
        // where edges are the immediate transitions to find potentially immediate loops.
        val states = region.states
        // Map to remember which states have been visited already
        val Map<de.cau.cs.kieler.sccharts.State, Integer> visited = newHashMap
        for(state : states) {
            val hasLoop = findImmediateLoop(state, visited)
            if(hasLoop) {
                // Loop detected, so add warning marker on all involved states
                val Set<de.cau.cs.kieler.sccharts.State> statesWithLoop = newHashSet
                for(entry : visited.entrySet) {
                    if(entry.value == 1) {
                        statesWithLoop.add(entry.key)
                    }
                }
                val message = IMMEDIATE_LOOP + "\nInvolved states: " + statesWithLoop.map[it.name]
                for(s : statesWithLoop) {
                    // Highlight immediate transitions that lead to states, which are part of the loop.
                    // This is more helpful than highlighting the complete state.
                    for(t : s.outgoingTransitions) {
                        if(t.isImplicitlyImmediate && statesWithLoop.contains(t.targetState)) {
                            warning(message, t, null)
                        }
                    }
                }
                return;
            }
        }
    }
    
    /**
     * Helper method to find immediate loops.
     * 
     * @param state The state that is checked for loops
     * @param visited Data structure with the information whether states have been visited before.
     * @return true if a loop was detected. In this case the involved states will have a visited value of 1 in the map.
     */
    private def boolean findImmediateLoop(de.cau.cs.kieler.sccharts.State state, Map<de.cau.cs.kieler.sccharts.State, Integer> visited) {
        val visitedCode = visited.getOrDefault(state, 0)
        if(visitedCode == 2) {
            // Finished before without cycle
            return false    
        } else if(visitedCode == 1) {
            // Found cycle
            return true
        }
        // Now visited
        visited.put(state, 1)
        // Find loops in outgoing immediate transitions.
        for(t : state.outgoingTransitions) {
            if(t.isImplicitlyImmediate) {
                val target = t.targetState
                if(findImmediateLoop(target, visited)) {
                    return true
                }
            }
        }
        // Now finished without cycle
        visited.put(state, 2)
        return false
    }
    
    /**
     * Discourage emissions of non-signals
     *
     * @param state the state
     */
    @Check
    def void checkNoBooleanEmissions(Emission emission) {
        if (emission.getValuedObject() != null && emission.getValuedObject().eContainer() != null && emission.getValuedObject().eContainer() instanceof Declaration) {
            val declaration = emission.getValuedObject().declaration
            if (declaration instanceof VariableDeclaration && !(declaration as VariableDeclaration).signal) {
                warning(NON_SIGNAL_EMISSION, emission, null, -1);
            }
        } 
    }

    // -------------------------------------------------------------------------    

    /**
     * Forbid assignments of non-variables
     *
     * @param state the state
     */
    @Check
    def void checkNoBooleanEmissions(Assignment assignment) {
        if (assignment.getValuedObject() != null && assignment.getValuedObject().eContainer() != null && assignment.getValuedObject().eContainer() instanceof Declaration) {
            val declaration = assignment.getValuedObject().declaration
            if (declaration instanceof VariableDeclaration && (declaration as VariableDeclaration).signal) {
                error(NON_VARIABLE_ASSIGNMENT, assignment, null, -1);
            }
        } 
    }

    // -------------------------------------------------------------------------

    /**
     * A state should be reachable from an initial state.
     *
     * @param state the state
     */
    @Check
    def void checkReachableStates(de.cau.cs.kieler.sccharts.State state) {
        if (!state.isStateReachable) {
           warning(STATE_NOT_REACHABLE, state, null, -1);
        }
    }
        
    /**
     * Check that there are no transitions that are not reachable, i.e.,
     * no transitions after a transition without guard.
     * 
     * @param state The state 
     */
    @Check
    public def void checkTransitionsAreReachable(de.cau.cs.kieler.sccharts.State state) {
        var boolean delayedTransitionWithoutTrigger = false
        var boolean immediateTransitionWithoutTrigger = false
        for(trans : state.outgoingTransitions) {
            if(trans.isImplicitlyImmediate) { 
                // An immediate transition may follow after a delayed transition without trigger, and still be reachable.
                if(immediateTransitionWithoutTrigger) {
                    warning(NON_REACHABLE_TRANSITION, trans, null)
                }
                if(!immediateTransitionWithoutTrigger && trans.trigger == null) {
                    immediateTransitionWithoutTrigger = true
                }
            } else {
                // An delayed transition after a delayed transition without trigger is not reachable.
                // Neither is a delayed transition after an immediate transition without trigger.
                if(delayedTransitionWithoutTrigger || immediateTransitionWithoutTrigger) {
                    warning(NON_REACHABLE_TRANSITION, trans, null)
                }
                if(!delayedTransitionWithoutTrigger && trans.trigger == null) {
                    delayedTransitionWithoutTrigger = true
                }
            }
        }
    }

    /**
     * Check that connector states have only immediate transitions and have a default transition.
     * 
     * @param state The state 
     */
    @Check
    public def void checkConnectorTransitions(de.cau.cs.kieler.sccharts.State state) {
        if(state.connector) {
            var Transition lastTransition
            var boolean transitionWithoutTrigger = false
            for(trans : state.outgoingTransitions) {
                if(!trans.isImmediate) {
                    warning(NON_IMMEDIATE_CONNECTOR, trans, null)
                }
                if(trans.trigger == null) {
                    transitionWithoutTrigger = true
                }
                lastTransition = trans
            }
            if(!transitionWithoutTrigger) {
                warning(NO_DEFAULT_TRANSITION, lastTransition, null)
            }
            if(lastTransition == null) {
                error(NO_OUTGOING_TRANSITION, state, null)
            }
        }
    }

    /**
     * Check that names of variables are unique within a scope.
     * 
     * @param scope The scope 
     */
    @Check
    public def void checkDuplicateVariable(Scope scope) {
        val Set<String> variableNames = newHashSet()
        for(decl : scope.declarations) { 
            for(valuedObject : decl.valuedObjects) {
                val name = valuedObject.name
                if(variableNames.contains(name)) {
                    warning(DUPLICATE_VARIABLE, valuedObject, null)
                } else {
                    variableNames.add(name)
                }
            }
        }
    }

    /**
     * Check if valued signal has a combine functions
     *
     * @param valuedObject the valuedObject
     */
    @Check
    public def void checkCombineFunction(ValuedObject valuedObject) {
        // Check if actually a valued signal
        if(valuedObject.isSignal && !valuedObject.isPureSignal) {
            // Check if there is a combine operator
            if(valuedObject.combineOperator == null) {
                warning(NOCOMBINE, valuedObject, null)
            }
        }
    } 


    /**
     * Check if max or min is used which is currently not supported
     *
     * @param valuedObject the valuedObject
     */
    @Check
    public def void checkMinMaxUsedCombinationFunction(ValuedObject valuedObject) {
        // Check if actually a valued signal
        if(valuedObject.isSignal && !valuedObject.isPureSignal) {
            // Check if there is a combine operator
            if(valuedObject.combineOperator != null) {
                if (valuedObject.combineOperator.equals(CombineOperator.MIN) || valuedObject.combineOperator.equals(CombineOperator.MAX))
                warning(MINMAX_COMBINE, valuedObject, null)
            }
        }
    } 
    
    /**
     * Check if there is exactly ONE initial state per region.
     *
     * @param region the region
     */
    @Check
    public def void checkInitialState(ControlflowRegion region) {
        // Do not consider the root region == SCChart
        if (region.getParentState() != null) {
            // check if parent state has declared any REAL region not only a
            // dummy region for entry/during/exit actions or suspends
            val parentState = region.getParentState
            var int foundInitial = 0;
            if ((parentState.actions.size() > 0) && (parentState.getRegions().size() == 1)
                    && parentState.getRegions().filter(typeof(ControlflowRegion)).head.getStates().size() == 0
                    && (parentState.getRegions().head.name == null
                        || parentState.getRegions().head.name.equals(""))) {
                foundInitial = 1;
            }
            for (de.cau.cs.kieler.sccharts.State state : region.getStates()) {
                if (state.isInitial()) {
                    foundInitial = foundInitial + 1;
                }
            }
            if (foundInitial == 0) {
                error(REGION_NO_INITIAL_STATE, region, null, -1);
            } else if (foundInitial > 1) {
                error(REGION_TWO_MANY_INITIAL_STATES, region, null, -1);
            }
        }
    }
    
    /**
     * A state with a termination transition should have final states in all its
     * inner regions. 
     * A simple state with a termination transition must have inner behaviour or no termination transition at all.
     * 
     * @param state the state
     */
    @Check
    public def void checkFinalStates(de.cau.cs.kieler.sccharts.State state) {
        // Check if state has termination transition
        val foundTermination = !state.outgoingTransitions.filter[ isTermination ].empty
        if (foundTermination) {
            // Assert inner behaviour
            val regions = state.regions.filter(ControlflowRegion)
            if(regions.isEmpty && state.reference == null) {
                error(NO_REGION, state, null, -1);
            }

            // Now test for every region
            if (state.actions.nullOrEmpty) {
                for (region : regions) {
                    val foundFinal = !region.states.filter[ isFinal ].empty
                    if (!foundFinal) {
                        warning(REGION_NO_FINAL_STATE, region, null, -1);
                    }
                }
            }
        }
    }
    
    /**
     * Checks if the given state has any strong abort transitions with lower priority than non-strong-abort transitions-
     */
    @Check
    public def void checkLowPriorityStrongAbort(de.cau.cs.kieler.sccharts.State state) {
        var onlyStrongAbortsBefore = true;
        // Checking priority by order
        for (transition : state.outgoingTransitions) {
            if (onlyStrongAbortsBefore && !transition.isStrongAbort) {
                onlyStrongAbortsBefore = false;
            } else if (!onlyStrongAbortsBefore && transition.isStrongAbort) {
                error(STRONG_ABORT_WITH_LOW_PRIORITY, transition, null, -1);
            }
        }
    } 

    /**
     * Checks if the given state has abort transitions without trigger and adds a warning.
     * In most cases an abort without trigger is meant to be a termination transition.
     */
    @Check
    public def void checkAbortHasTrigger(de.cau.cs.kieler.sccharts.State state) {
        if(state.isHierarchical) {
            for (transition : state.outgoingTransitions) {
                if ((transition.isStrongAbort || transition.isWeakAbort)
                    && transition.trigger == null) {
                    warning(ABORT_WITHOUT_TRIGGER, transition, null, -1);
                }
            }
        }
    } 
    
    /**
     * Checks if the given valued signal has a combination function.
     * This check can be removed if there is a transformation
     * that handles valued signals without combination function (see KISEMA-1071).   
     */
    // TODO: (KISEMA-1071) Remove this check when there is a transformation that handles valued signals without combination function.
    @Check
    public def void checkValuedSignalHasCombinationFunction(ValuedObject valuedObject) {
        // Check if actually a valued signal
        if(valuedObject.isSignal && !valuedObject.isPureSignal) {
            // Check if there is a combine operator
            if(valuedObject.combineOperator == null || valuedObject.combineOperator.equals(CombineOperator.NONE)) {
                warning(VALUED_SIGNAL_NEED_COMBINE, valuedObject, null)
            }
        }
    } 
    
    /**
     * Checks that static variables are initialized.
     * If it is not initialized the static modifier is useless from a modeling perspective.   
     */
    @Check
    public def void checkStaticVariableIsInitialized(ValuedObject valuedObject) {
        if(valuedObject.isStatic && valuedObject.initialValue == null) {
            warning(STATIC_VARIABLE_WITHOUT_INITIALIZATION, valuedObject, null)
        }
    } 
    
    /**
     * Checks scope of valued objects of transition triggers are correct.
     */
    @Check
    public def void checkScopeOfOutgoingTransitionVarRefs(ValuedObject testValuedObject) {
        val stateOrRegion = testValuedObject.eContainer.eContainer
        var de.cau.cs.kieler.sccharts.State state
        if (stateOrRegion instanceof AbstractDeclarativeValidator.State) {
            state = (stateOrRegion as de.cau.cs.kieler.sccharts.State)
        } else if (stateOrRegion instanceof ControlflowRegion) {
            val region = (stateOrRegion as ControlflowRegion)
            state = region.parentState
        } else {
            return
        }
        
        for (transition : state.outgoingTransitions) {
            val valuedObjectRefs = transition.eAllContents.filter(typeof(ValuedObjectReference))
            if (valuedObjectRefs.filter[valuedObject == testValuedObject].size > 0) {
                error(VALUEDOBJECT_TRANSITION_SCOPE_WRONG, testValuedObject, null, -1);
            }
        }
    }
    
    /**
     *
     * @param state the state
     */
    @Check
    def void checkAssignmentToConst(Assignment assignment) {
        if (assignment.getValuedObject() != null) {
            val declaration =  assignment.getValuedObject.variableDeclaration
            if (declaration != null && declaration.isConst()) {
                error(ASSIGNMENT_TO_CONST, assignment, null, -1);
            }
        }
    }    
    
    @Check
    def void checkScopeCall(ScopeCall scopeCall) {
        if (scopeCall.eContainer instanceof Scope) {
            val bindings = scopeCall.eContainer.asScope.createBindings
            var errorMessage = ""
            var implicitMessage = ""
            for (binding : bindings) {
                if (binding.errors > 0) {
                    errorMessage = binding.errorMessages.join("\n")
                }
                if (binding.type == BindingType.IMPLICIT) {
                    implicitMessage += binding.targetValuedObject.name + ", "
                    implicitMessage.replaceFirst(", $", "")
                }
            }
            
            if (errorMessage != "") {
                error("The referencing binding is erroneous!\n" + errorMessage,
                    scopeCall, 
                    SCChartsPackage.eINSTANCE.scopeCall_Scope, 
                    "The referencing binding is erroneous!\n" + errorMessage);
            } else if (implicitMessage != "") {
                warning("Valued Objects are bound implicitly!\n" + implicitMessage,
                    scopeCall, 
                    SCChartsPackage.eINSTANCE.scopeCall_Scope, 
                    "Valued Objects are bound implicitly!\n" + implicitMessage);
            }
        }
    }
    
    @Check
    def void checkActionTriggerEffectsWithLabel(Action action) {
        if (!action.label.nullOrEmpty) {
            if (action.trigger != null) {
                if (infosEnabled(action))
                    info("The trigger of this action is hidden by the label.", 
                        action, 
                        SCChartsPackage.eINSTANCE.action_Trigger)
            }
            if (action.effects != null && action.effects.size > 0) {
                if (infosEnabled(action))
                    info("The effects of this action are hidden by the label.", 
                        action, 
                        SCChartsPackage.eINSTANCE.action_Effects)
            }
        }
    }
    
    @Check
    def void checkForRegion(ControlflowRegion region) {
        if (region.forStart != null && region.forStart instanceof ValuedObjectReference) {
            val forRange = For.getForRegionRange(region)
            if (forRange.second == -1) {
                error("The range of the counter variable of the for region is not determinable. The array cardinalities of you array must be an int or a const int.",
                    region, SCChartsPackage.eINSTANCE.state_Regions
                )
            }
        }
    }
    
    // ENFORCER SPECIFIC
    
    public static val DIRECTOR = "director"
    public static val ENFORCER = "Enforcer"
    
    public static val CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR = 
        "Violation states require enforcer director" 
        
    @Check
    def void checkViolationState(de.cau.cs.kieler.sccharts.State state) {
        if (state.violation) {
            val scc = state.getSCCharts
            if (!scc.getStringPragmas(DIRECTOR).last.values.head.equals(ENFORCER)) {
                error(CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR, state, 
                    SCChartsPackage.eINSTANCE.state_Violation, CHECK_VIOLATION_STATES_REQUIRE_ENFORCER_DIRECTOR
                )
            }
        }
    }
    
    
    private def boolean infosEnabled(EObject eObject) {
        val scc = eObject.getSCCharts
        val infoPragma = scc.getStringPragmas(INFOS_PRAGMA).head
        if (infoPragma != null && infoPragma.values.size > 0 && infoPragma.values.head.equals("off")) {
            return false
        }
        return true
    }
}
