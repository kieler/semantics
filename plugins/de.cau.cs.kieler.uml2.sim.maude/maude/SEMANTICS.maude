mod SEMANTICS is 
  including COMPOUNDTRANSITIONSSYNTAX .
  including COMPOUNDTRANSITIONS .
  including VERTSSYNTAX .
  including VERTS .
  including SEMANTICSSYNTAX .
  including SMGETTER .
  including STATE-DEFAULT .
  including DEEP-DEFAULT .
  including SHALLOW-DEFAULT .
  including HISTORY-CONF .
  including STATE-ACTION .
  including PRIORITY .
  including STATEMACHINE . 
  including eclipseInterface .

	var mastate : MState .	
	var mstate : MState .

    vars src tgt src2 tgt2 : Verts . 
    vars e e2 : Event .
    vars g g2 : Guard .
    vars a af aj a2 af2 aj2 action : Actions .
    vars A AF AJ A2 AF2 AJ2 actions : Actions .
    vars lreg lreg2 : Vert .
	


    vars  ENA : EntryActions .
    vars  EXA : ExitActions .

    vars sm : StateMachine .
    vars HC : HistoryConfs .
    vars hc : HistoryConf .
    vars C2 leaveStates enterStates : Verts . *** Konfiguration
    vars fe : Event . *** event selected for this rtc step
    vars E E2 : EventSet .
    vars ES ES2 : EventSet .
    vars C C' V V2 S : Verts .
    vars NeT : NeCompoundtransitions .    
    vars T T1 T2 F : Compoundtransitions .
    vars t t1 t2 : Compoundtransition .
    vars sT sT1 sT2 sF : BasicTransitions .
    vars st st1 st2 : BasicTransition .
    vars S2 : Verts .
    vars s : ModState .
    vars s2 s3 ds1 ds2 : ModState .
    vars V_vert V_vert2 v : Vert .
    vars R : Verts .
    vars r r2 r3 : Region .
    vars c : CompositeID .
    vars shn : HistShallowID .
    vars dhn : HistDeepID .
    vars D : Defaults .
    vars d : Default .
    vars SH : ShallowDefaults .
    vars sh : ShallowDefault .
    vars DH : DeepDefaults .
    vars dh : DeepDefault .
    vars str : String .
    vars MN : Sets .


	rl [noevents] : maState (stableC<STATEC>  V  <HISTC>  HC  <ENDCONF>) (ev: "noevent") => 
	maState (doneC<STATEC> V <HISTC> HC  <ENDCONF>) empty .
	
	crl [selectEventFSetESINT] : maState (stableC<STATEC> V <HISTC> HC  <ENDCONF>) (e2, ES) => 
	maState (eventSelC<STATEC> V <HISTC> HC <EVENT> e2  <ENDCONF>) (ES, e2) if (e2 =/= empty) and (e2 =/= (ev: "noevent")) and not((enabled V e2) == empty) [print "selected " e2] .
	
***(
	crl [discardFSetESINT] : maState (eventSelC<STATEC> V <HISTC> HC <EVENT> e2  <ENDCONF>) (ES) => 
		maState (doneC<STATEC> V <HISTC> HC  <ENDCONF>) (ES) if 
		(enabled V e2) == empty [print "discarded " e2]  .
    )***
    rl [doneExecTrans] : maState 
    (unstableC<STATEC> V <HISTC> HC <TRANSITIONS> empty <ACTIONS> A  <ENDCONF>)
    ES =>
     maState (doneC<STATEC> V <HISTC> (succHC V HC)  <ENDCONF>) ES [print "done executing all transitions "] .
	
	crl [computeFSetESINT] : maState (eventSelC<STATEC> V <HISTC> HC <EVENT> e2  <ENDCONF>) (ES) => 
		maState (fireC<STATEC> V <HISTC> HC <TRANSSETS> 
			(fireableSets 
				(remLowPrio 
					(enabled 
						V 
						e2
					)
				))  <ENDCONF> 
		) (ES) if 
		(enabled V e2) =/= empty 
		*** [print "firesets for " e2] 
		.
	
	rl [finishedRTCESINT] : maState (doneC<STATEC> V <HISTC> HC  <ENDCONF>) ES => 
		maState (stableC<STATEC> V <HISTC> HC  <ENDCONF>) ES .
	
	rl [fireFSetESINT] : maState (fireC<STATEC> V <HISTC> HC <TRANSSETS>(mm(NeT), MN)  <ENDCONF>) ES => 
		maState (unstableC<STATEC> V <HISTC> HC <TRANSITIONS> NeT <ACTIONS> noac  <ENDCONF>) ES 
		[print "choosen " NeT " not considered " MN] 
		.
    
    rl [fireTrans] : maState (unstableC<STATEC> V <HISTC> HC <TRANSITIONS> (t, T) <ACTIONS> A  <ENDCONF>) ES =>
       maState (leaveC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> (inTrans t) <OUTGOINGBASICTR> (outTrans t) <LEAVESTATES> (leave V t) <ACTIONS> A <ENDCONF>) ES 
       *** . 
       [print "fire CTrans " t] .
    
    rl [fireTrans] : maState (unstableC<STATEC> V <HISTC> HC <TRANSITIONS> t <ACTIONS> A <ENDCONF>) ES =>
       maState (leaveC<STATEC> V <HISTC> HC <TRANSITIONS> empty <NEXTTR> t <INCOMINGBASICTR> (inTrans t) <OUTGOINGBASICTR> (outTrans t) <LEAVESTATES> (leave V t) <ACTIONS> A <ENDCONF>) ES 
       *** .
       [print "fire CTrans " t] .
    
    crl [leaveState] : maState 
    (leaveC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> sT <OUTGOINGBASICTR> sT1 <LEAVESTATES> (v, leaveStates) <ACTIONS> A <ENDCONF>)
    ES =>
     maState 
    (leaveC<STATEC> (V \ v) <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> sT <OUTGOINGBASICTR> sT1 <LEAVESTATES> leaveStates <ACTIONS> A <ENDCONF>)
     ES 
     if (((intersection (leaveStates, (getSubVerts v))) == empty) and not(typeRegion v)) [print "leaving " v] .
    
    crl [leaveState] : maState 
     (leaveC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> sT <OUTGOINGBASICTR> sT1 <LEAVESTATES> (v, leaveStates) <ACTIONS> A <ENDCONF>)
    ES =>
     maState 
     (leaveC<STATEC> (V \ v) <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> sT <OUTGOINGBASICTR> sT1 <LEAVESTATES> leaveStates <ACTIONS> A <ENDCONF>)
     ES 
     if ((intersection (leaveStates, (getSubVerts v)) == empty) and (typeRegion v)) [print "leaving " v] .
    *** add the effect of the transition to the actions, valuations
    
    rl [execBTransincomingPstate] : maState 
    (execTransC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> (st, sT) <OUTGOINGBASICTR> sT1 <ACTIONS> A <ENDCONF>)
    ES => maState 
    (execTransC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> sT <OUTGOINGBASICTR> sT1 <ACTIONS> A <ENDCONF>)
    ES .
    
    crl [execBTrans2] : maState 
    (execTransC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> empty <OUTGOINGBASICTR> (st, sT1) <ACTIONS> A <ENDCONF>)    
    ES => maState 
    (execTransC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> empty <OUTGOINGBASICTR> sT1 <ACTIONS> A <ENDCONF>)        
    ES if not(isChoice t) .
    
    rl [statesLeft] : maState (leaveC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> sT <OUTGOINGBASICTR> sT1 <LEAVESTATES> empty <ACTIONS> A <ENDCONF>) ES => 
    maState 
    (execTransC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> sT <OUTGOINGBASICTR> sT1 <ACTIONS> A <ENDCONF>)
    ES [print "states left for " t] .

    crl [execBTrans2] : maState 
    (execTransC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> empty <OUTGOINGBASICTR> sT1 <ACTIONS> A <ENDCONF>)
    ES => maState 
    (execChoiceOut<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> empty <OUTGOINGBASICTR> sT1 <ACTIONS> A <ENDCONF>)
     ES if (isChoice t) .
    
    rl [enterStatesForNonChoiceTrans] : maState 
    (execTransC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> empty <OUTGOINGBASICTR> empty <ACTIONS> A <ENDCONF>)
    ES => 
     maState
	(enterC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <ENTERSTATES> (enterH HC t) <ACTIONS> A <ENDCONF>)
	ES .

    rl [enterStatesForChoiceTrans] : maState 
    (execChoiceOut<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <INCOMINGBASICTR> empty <OUTGOINGBASICTR> sT1 <ACTIONS> A <ENDCONF>)
     ES => 
     maState
     (enterC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <ENTERSTATES> (enterH HC (chooseChoice t V)) <ACTIONS> A <ENDCONF>)
     ES .


    crl [enterState] : maState 
    (enterC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <ENTERSTATES> (v, enterStates) <ACTIONS> A <ENDCONF>)
     ES => 
     maState 
   (enterC<STATEC> (V, v) <HISTC> HC <TRANSITIONS> T <NEXTTR> t <ENTERSTATES> enterStates <ACTIONS> A <ENDCONF>)
      ES 
     if (((intersection (enterStates, (start v))) == empty) and not(typeRegion v)) [print "entering state " v V] .

    crl [enterState] : maState 
    (enterC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <ENTERSTATES> (v, enterStates) <ACTIONS> A <ENDCONF>)    
    ES =>
     maState 
     (enterC<STATEC> (V, v) <HISTC> HC <TRANSITIONS> T <NEXTTR> t <ENTERSTATES> enterStates <ACTIONS> A <ENDCONF>)
     ES 
     if ((intersection (enterStates, (start v)) == empty) and (typeRegion v))  [print "entering region " v V] .

    rl [doneExecTrans] : maState 
    (enterC<STATEC> V <HISTC> HC <TRANSITIONS> T <NEXTTR> t <ENTERSTATES> empty <ACTIONS> A <ENDCONF>)
    ES =>
     maState 
     (unstableC<STATEC> V <HISTC> HC <TRANSITIONS> T <ACTIONS> A <ENDCONF>)
     ES [print "done executing " t] .
   
     
endm
***( 

endm  
)*** 		
  
