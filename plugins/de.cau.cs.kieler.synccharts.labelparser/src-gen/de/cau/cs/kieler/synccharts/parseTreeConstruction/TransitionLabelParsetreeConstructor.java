/*
* generated by Xtext
*/
package de.cau.cs.kieler.synccharts.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.synccharts.services.TransitionLabelGrammarAccess;

import com.google.inject.Inject;

public class TransitionLabelParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private TransitionLabelGrammarAccess grammarAccess;
		
	public TransitionLabelGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Group(this, this, 0, inst);
			case 1: return new Action_Group(this, this, 1, inst);
			case 2: return new Effect_Alternatives(this, this, 2, inst);
			case 3: return new Emission_Group(this, this, 3, inst);
			case 4: return new Assignment_Group(this, this, 4, inst);
			case 5: return new SignalReference_ReferenceAssignment(this, this, 5, inst);
			case 6: return new VariableReference_ReferenceAssignment(this, this, 6, inst);
			case 7: return new Signal_Group(this, this, 7, inst);
			case 8: return new Variable_Group(this, this, 8, inst);
			case 9: return new IntValue_ValueAssignment(this, this, 9, inst);
			case 10: return new FloatValue_ValueAssignment(this, this, 10, inst);
			case 11: return new BooleanValue_ValueAssignment(this, this, 11, inst);
			case 12: return new Value_Alternatives(this, this, 12, inst);
			case 13: return new HostCode_CodeAssignment(this, this, 13, inst);
			case 14: return new Operator_OperatorKindAssignment(this, this, 14, inst);
			case 15: return new ValOperation_Group(this, this, 15, inst);
			case 16: return new ValueExpression_Alternatives(this, this, 16, inst);
			case 17: return new CompareOperation_Group(this, this, 17, inst);
			case 18: return new NotOperation_Group(this, this, 18, inst);
			case 19: return new NotOrNormalExpression_Alternatives(this, this, 19, inst);
			case 20: return new AndOperation_Group(this, this, 20, inst);
			case 21: return new OrOperation_Group(this, this, 21, inst);
			case 22: return new BooleanExpression_Alternatives(this, this, 22, inst);
			case 23: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 23, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 *   (signals+=Signal|variables+=Variable)* (actions+=Action ";")*; 
 * 
 * // dummy rule to test the language in an editor
 *
 **/

// (signals+=Signal|variables+=Variable)* (actions+=Action ";")*
protected class Model_Group extends GroupToken {
	
	public Model_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Group_1(parent, this, 0, inst);
			case 1: return new Model_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// (signals+=Signal|variables+=Variable)*
protected class Model_Alternatives_0 extends AlternativesToken {

	public Model_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getModelAccess().getAlternatives_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_SignalsAssignment_0_0(parent, this, 0, inst);
			case 1: return new Model_VariablesAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class Model_SignalsAssignment_0_0 extends AssignmentToken  {
	
	public Model_SignalsAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getSignalsAssignment_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getSignalsSignalParserRuleCall_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// variables+=Variable
protected class Model_VariablesAssignment_0_1 extends AssignmentToken  {
	
	public Model_VariablesAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getVariablesAssignment_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variables",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variables");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getVariablesVariableParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Alternatives_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}


// (actions+=Action ";")*
protected class Model_Group_1 extends GroupToken {
	
	public Model_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_SemicolonKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// actions+=Action
protected class Model_ActionsAssignment_1_0 extends AssignmentToken  {
	
	public Model_ActionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getActionsAssignment_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("actions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("actions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getActionsActionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_Group_1(parent, next, actIndex, consumed);
			case 1: return new Model_Alternatives_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// ";"
protected class Model_SemicolonKeyword_1_1 extends KeywordToken  {
	
	public Model_SemicolonKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getSemicolonKeyword_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ActionsAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Model ****************/


/************ begin Rule Action ****************
 *
 * Action:
 *   trigger=PrimaryExpression? ("/" effects+=Effect*)?; 
 * 
 *   
 * 	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
 *
 **/

// trigger=PrimaryExpression? ("/" effects+=Effect*)? 
// 	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
protected class Action_Group extends GroupToken {
	
	public Action_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_Group_1(parent, this, 0, inst);
			case 1: return new Action_TriggerAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// trigger=PrimaryExpression?
protected class Action_TriggerAssignment_0 extends AssignmentToken  {
	
	public Action_TriggerAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getTriggerAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("trigger",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("trigger");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getTriggerPrimaryExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("/" effects+=Effect*)?
protected class Action_Group_1 extends GroupToken {
	
	public Action_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_EffectsAssignment_1_1(parent, this, 0, inst);
			case 1: return new Action_SolidusKeyword_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "/"
protected class Action_SolidusKeyword_1_0 extends KeywordToken  {
	
	public Action_SolidusKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getSolidusKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_TriggerAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// effects+=Effect*
protected class Action_EffectsAssignment_1_1 extends AssignmentToken  {
	
	public Action_EffectsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getEffectsAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("effects",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("effects");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getEffectsEffectParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Action_EffectsAssignment_1_1(parent, next, actIndex, consumed);
			case 1: return new Action_SolidusKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Action ****************/


/************ begin Rule Effect ****************
 *
 * Effect:
 *   Emission|Assignment|HostCode;  		
 * 
 *    
 * 	        
 * 		
 * //Expression :
 * //	TerminalExpression | ComplexExpression;
 * 
 * // TODO: Signal and Variable references both are evaluated by simple IDs
 * //TerminalExpression:
 * //    SignalOrVariableReference | HostCode | Value;
 * 
 * // TODO: add more complex expressions and not only simple operations without recursion
 * //UnbracedComplexExpression : 
 * //	((subExpressions+=TerminalExpression))? operator=Operator subExpressions+=Expression ;
 * 
 * //BracedComplexExpression : 
 * //	"(" UnbracedComplexExpression ")";
 * 
 * //ComplexExpression :
 * //	UnbracedComplexExpression | BracedComplexExpression;
 *
 **/

// Emission|Assignment|HostCode  		
// 
//    
// 	        
// 		
// //Expression :
// //	TerminalExpression | ComplexExpression;
// 
// // TODO: Signal and Variable references both are evaluated by simple IDs
// //TerminalExpression:
// //    SignalOrVariableReference | HostCode | Value;
// 
// // TODO: add more complex expressions and not only simple operations without recursion
// //UnbracedComplexExpression : 
// //	((subExpressions+=TerminalExpression))? operator=Operator subExpressions+=Expression ;
// 
// //BracedComplexExpression : 
// //	"(" UnbracedComplexExpression ")";
// 
// //ComplexExpression :
// //	UnbracedComplexExpression | BracedComplexExpression;
protected class Effect_Alternatives extends AlternativesToken {

	public Effect_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getEffectAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Effect_EmissionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Effect_AssignmentParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Effect_HostCodeParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEffectRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Emission
protected class Effect_EmissionParserRuleCall_0 extends RuleCallToken {
	
	public Effect_EmissionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getEmissionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Emission_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEmissionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Assignment
protected class Effect_AssignmentParserRuleCall_1 extends RuleCallToken {
	
	public Effect_AssignmentParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getAssignmentParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// HostCode
protected class Effect_HostCodeParserRuleCall_2 extends RuleCallToken {
	
	public Effect_HostCodeParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getEffectAccess().getHostCodeParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HostCode_CodeAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(HostCode_CodeAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getHostCodeRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Effect ****************/


/************ begin Rule Emission ****************
 *
 * Emission:
 *   signal=[Signal] ("(" newValue=PrimaryExpression ")")?; 
 * 		
 * //Expression :
 * //	TerminalExpression | ComplexExpression;
 * 
 * // TODO: Signal and Variable references both are evaluated by simple IDs
 * //TerminalExpression:
 * //    SignalOrVariableReference | HostCode | Value;
 * 
 * // TODO: add more complex expressions and not only simple operations without recursion
 * //UnbracedComplexExpression : 
 * //	((subExpressions+=TerminalExpression))? operator=Operator subExpressions+=Expression ;
 * 
 * //BracedComplexExpression : 
 * //	"(" UnbracedComplexExpression ")";
 * 
 * //ComplexExpression :
 * //	UnbracedComplexExpression | BracedComplexExpression;
 *
 **/

// signal=[Signal] ("(" newValue=PrimaryExpression ")")?
protected class Emission_Group extends GroupToken {
	
	public Emission_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_Group_1(parent, this, 0, inst);
			case 1: return new Emission_SignalAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEmissionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signal=[Signal]
protected class Emission_SignalAssignment_0 extends AssignmentToken  {
	
	public Emission_SignalAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getSignalAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getEmissionAccess().getSignalSignalCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("(" newValue=PrimaryExpression ")")?
protected class Emission_Group_1 extends GroupToken {
	
	public Emission_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEmissionAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Emission_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public Emission_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getLeftParenthesisKeyword_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_SignalAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// newValue=PrimaryExpression
protected class Emission_NewValueAssignment_1_1 extends AssignmentToken  {
	
	public Emission_NewValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEmissionAccess().getNewValueAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("newValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newValue");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEmissionAccess().getNewValuePrimaryExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Emission_LeftParenthesisKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Emission_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public Emission_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEmissionAccess().getRightParenthesisKeyword_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Emission_NewValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule Emission ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment:
 *   variable=[Variable] ":=" expression=PrimaryExpression;
 *
 **/

// variable=[Variable] ":=" expression=PrimaryExpression
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_ExpressionAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// variable=[Variable]
protected class Assignment_VariableAssignment_0 extends AssignmentToken  {
	
	public Assignment_VariableAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getVariableAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("variable",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("variable");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAssignmentAccess().getVariableVariableCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ":="
protected class Assignment_ColonEqualsSignKeyword_1 extends KeywordToken  {
	
	public Assignment_ColonEqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getColonEqualsSignKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_VariableAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expression=PrimaryExpression
protected class Assignment_ExpressionAssignment_2 extends AssignmentToken  {
	
	public Assignment_ExpressionAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getExpressionAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentAccess().getExpressionPrimaryExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_ColonEqualsSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Assignment ****************/


/************ begin Rule SignalReference ****************
 *
 * SignalReference:
 *   reference=[Signal];
 *
 **/

// reference=[Signal]
protected class SignalReference_ReferenceAssignment extends AssignmentToken  {
	
	public SignalReference_ReferenceAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalReferenceAccess().getReferenceAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reference",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reference");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceAccess().getReferenceSignalCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSignalReferenceAccess().getReferenceSignalCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule SignalReference ****************/


/************ begin Rule VariableReference ****************
 *
 * VariableReference:
 *   reference=[Variable];
 *
 **/

// reference=[Variable]
protected class VariableReference_ReferenceAssignment extends AssignmentToken  {
	
	public VariableReference_ReferenceAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableReferenceAccess().getReferenceAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("reference",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("reference");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableReferenceAccess().getReferenceVariableCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getVariableReferenceAccess().getReferenceVariableCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule VariableReference ****************/


/************ begin Rule Signal ****************
 *
 * Signal:
 *   "input" name=ID ";";
 *
 **/

// "input" name=ID ";"
protected class Signal_Group extends GroupToken {
	
	public Signal_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_SemicolonKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "input"
protected class Signal_InputKeyword_0 extends KeywordToken  {
	
	public Signal_InputKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getInputKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_1 extends AssignmentToken  {
	
	public Signal_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InputKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ";"
protected class Signal_SemicolonKeyword_2 extends KeywordToken  {
	
	public Signal_SemicolonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getSemicolonKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Signal ****************/


/************ begin Rule Variable ****************
 *
 * Variable:
 *   "var" name=ID ";";
 *
 **/

// "var" name=ID ";"
protected class Variable_Group extends GroupToken {
	
	public Variable_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_SemicolonKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "var"
protected class Variable_VarKeyword_0 extends KeywordToken  {
	
	public Variable_VarKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableAccess().getVarKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Variable_NameAssignment_1 extends AssignmentToken  {
	
	public Variable_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_VarKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ";"
protected class Variable_SemicolonKeyword_2 extends KeywordToken  {
	
	public Variable_SemicolonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableAccess().getSemicolonKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Variable ****************/


/************ begin Rule IntValue ****************
 *
 * IntValue:
 *   value=INT;
 *
 **/

// value=INT
protected class IntValue_ValueAssignment extends AssignmentToken  {
	
	public IntValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getIntValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntValue ****************/


/************ begin Rule FloatValue ****************
 *
 * FloatValue:
 *   value=Float;
 *
 **/

// value=Float
protected class FloatValue_ValueAssignment extends AssignmentToken  {
	
	public FloatValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getFloatValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFloatValueAccess().getValueFloatTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule FloatValue ****************/


/************ begin Rule BooleanValue ****************
 *
 * BooleanValue:
 *   value=Boolean;
 *
 **/

// value=Boolean
protected class BooleanValue_ValueAssignment extends AssignmentToken  {
	
	public BooleanValue_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanValueAccess().getValueAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBooleanValueAccess().getValueBooleanTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule BooleanValue ****************/


/************ begin Rule Value ****************
 *
 * Value:
 *   IntValue|FloatValue|BooleanValue; 
 * 
 * 	        
 * 
 * // make sure the Float rule does not shadow the built-in INT rule
 *
 **/

// IntValue|FloatValue|BooleanValue 
// 
// 	        
// 
// // make sure the Float rule does not shadow the built-in INT rule
protected class Value_Alternatives extends AlternativesToken {

	public Value_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Value_IntValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Value_FloatValueParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Value_BooleanValueParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// IntValue
protected class Value_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public Value_IntValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getIntValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class Value_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public Value_FloatValueParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getFloatValueParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FloatValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanValue
protected class Value_BooleanValueParserRuleCall_2 extends RuleCallToken {
	
	public Value_BooleanValueParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueAccess().getBooleanValueParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Value ****************/


/************ begin Rule HostCode ****************
 *
 * HostCode:
 *   code=STRING; 
 * 
 * 
 * 	//"'"code=STRING"'";
 * 	 //("(" type=ID ")")?
 *
 **/

// code=STRING 
// 	//"'"code=STRING"'";
// 	 //("(" type=ID ")")?
protected class HostCode_CodeAssignment extends AssignmentToken  {
	
	public HostCode_CodeAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getHostCodeAccess().getCodeAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getHostCodeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("code",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("code");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getHostCodeAccess().getCodeSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule HostCode ****************/


/************ begin Rule Operator ****************
 *
 * Operator:
 *   operatorKind=OperatorKind;
 *
 **/

// operatorKind=OperatorKind
protected class Operator_OperatorKindAssignment extends AssignmentToken  {
	
	public Operator_OperatorKindAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOperatorAccess().getOperatorKindAssignment();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOperatorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operatorKind",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operatorKind");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getOperatorAccess().getOperatorKindOperatorKindEnumRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Operator ****************/


/************ begin Rule ValOperation ****************
 *
 * ValOperation returns Expression:
 *   operator=ValOperator subExpressions+=SignalReference;
 *
 **/

// operator=ValOperator subExpressions+=SignalReference
protected class ValOperation_Group extends GroupToken {
	
	public ValOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getValOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValOperation_SubExpressionsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operator=ValOperator
protected class ValOperation_OperatorAssignment_0 extends AssignmentToken  {
	
	public ValOperation_OperatorAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getOperatorAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getValOperationAccess().getOperatorValOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=SignalReference
protected class ValOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public ValOperation_SubExpressionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getValOperationAccess().getSubExpressionsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalReference_ReferenceAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getValOperationAccess().getSubExpressionsSignalReferenceParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ValOperation_OperatorAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ValOperation ****************/


/************ begin Rule ValueExpression ****************
 *
 * ValueExpression returns Expression:
 *   IntValue|FloatValue|ValOperation|VariableReference;
 *
 **/

// IntValue|FloatValue|ValOperation|VariableReference
protected class ValueExpression_Alternatives extends AlternativesToken {

	public ValueExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_IntValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ValueExpression_FloatValueParserRuleCall_1(parent, this, 1, inst);
			case 2: return new ValueExpression_ValOperationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new ValueExpression_VariableReferenceParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// IntValue
protected class ValueExpression_IntValueParserRuleCall_0 extends RuleCallToken {
	
	public ValueExpression_IntValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getIntValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FloatValue
protected class ValueExpression_FloatValueParserRuleCall_1 extends RuleCallToken {
	
	public ValueExpression_FloatValueParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getFloatValueParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FloatValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FloatValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFloatValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ValOperation
protected class ValueExpression_ValOperationParserRuleCall_2 extends RuleCallToken {
	
	public ValueExpression_ValOperationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getValOperationParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// VariableReference
protected class ValueExpression_VariableReferenceParserRuleCall_3 extends RuleCallToken {
	
	public ValueExpression_VariableReferenceParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getValueExpressionAccess().getVariableReferenceParserRuleCall_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableReference_ReferenceAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableReference_ReferenceAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ValueExpression ****************/


/************ begin Rule CompareOperation ****************
 *
 * CompareOperation returns Expression:
 *   ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator
 *   subExpressions+=ValueExpression);
 *
 **/

// ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator
// subExpressions+=ValueExpression)
protected class CompareOperation_Group extends GroupToken {
	
	public CompareOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompareOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ValueExpression
protected class CompareOperation_ValueExpressionParserRuleCall_0 extends RuleCallToken {
	
	public CompareOperation_ValueExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getValueExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValueExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// {Operation.subExpressions+=current} operator=CompareOperator subExpressions+=
// ValueExpression
protected class CompareOperation_Group_1 extends GroupToken {
	
	public CompareOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class CompareOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public CompareOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_ValueExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCompareOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator=CompareOperator
protected class CompareOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public CompareOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getCompareOperationAccess().getOperatorCompareOperatorEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=ValueExpression
protected class CompareOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public CompareOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getCompareOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValueExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getValueExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompareOperationAccess().getSubExpressionsValueExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompareOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CompareOperation ****************/


/************ begin Rule NotOperation ****************
 *
 * NotOperation returns Operations:
 *   operators=NotOperator subExpressions+=BooleanExpression;
 *
 **/

// operators=NotOperator subExpressions+=BooleanExpression
protected class NotOperation_Group extends GroupToken {
	
	public NotOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_SubExpressionsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// operators=NotOperator
protected class NotOperation_OperatorsAssignment_0 extends AssignmentToken  {
	
	public NotOperation_OperatorsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getOperatorsAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operators",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operators");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getNotOperationAccess().getOperatorsNotOperatorEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=BooleanExpression
protected class NotOperation_SubExpressionsAssignment_1 extends AssignmentToken  {
	
	public NotOperation_SubExpressionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getNotOperationAccess().getSubExpressionsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNotOperationAccess().getSubExpressionsBooleanExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NotOperation_OperatorsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NotOperation ****************/


/************ begin Rule NotOrNormalExpression ****************
 *
 * NotOrNormalExpression returns Expression:
 *   NotOperation|BooleanExpression;
 *
 **/

// NotOperation|BooleanExpression
protected class NotOrNormalExpression_Alternatives extends AlternativesToken {

	public NotOrNormalExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_NotOperationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new NotOrNormalExpression_BooleanExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOperation
protected class NotOrNormalExpression_NotOperationParserRuleCall_0 extends RuleCallToken {
	
	public NotOrNormalExpression_NotOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getNotOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanExpression
protected class NotOrNormalExpression_BooleanExpressionParserRuleCall_1 extends RuleCallToken {
	
	public NotOrNormalExpression_BooleanExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNotOrNormalExpressionAccess().getBooleanExpressionParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NotOrNormalExpression ****************/


/************ begin Rule AndOperation ****************
 *
 * AndOperation returns Expression:
 *   NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd
 *   subExpression+=NotOrNormalExpression)*;
 *
 **/

// NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd
// subExpression+=NotOrNormalExpression)*
protected class AndOperation_Group extends GroupToken {
	
	public AndOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NotOrNormalExpression
protected class AndOperation_NotOrNormalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndOperation_NotOrNormalExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getNotOrNormalExpressionParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NotOrNormalExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=
// NotOrNormalExpression)*
protected class AndOperation_Group_1 extends GroupToken {
	
	public AndOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_SubExpressionAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpression+=current}
protected class AndOperation_OperationSubExpressionAction_1_0 extends ActionToken  {

	public AndOperation_OperationSubExpressionAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperationSubExpressionAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group_1(parent, this, 0, inst);
			case 1: return new AndOperation_NotOrNormalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndOperationAccess().getOperationSubExpressionAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpression", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpression")) return null;
		return getDescr((EObject) val);
	}
}

// operator=OperatorAnd
protected class AndOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AndOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_OperationSubExpressionAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getAndOperationAccess().getOperatorOperatorAndEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpression+=NotOrNormalExpression
protected class AndOperation_SubExpressionAssignment_1_2 extends AssignmentToken  {
	
	public AndOperation_SubExpressionAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAndOperationAccess().getSubExpressionAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NotOrNormalExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNotOrNormalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndOperationAccess().getSubExpressionNotOrNormalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndOperation ****************/


/************ begin Rule OrOperation ****************
 *
 * OrOperation returns Expression:
 *   AndOperation ({Operation.subExpressions+=current} operator=OperatorOr
 *   subExpressions+=AndOperation)*; 
 * 
 *     
 * 	      
 * 
 * // TODO: get rid of parentheses
 *
 **/

// AndOperation ({Operation.subExpressions+=current} operator=OperatorOr
// subExpressions+=AndOperation)*
protected class OrOperation_Group extends GroupToken {
	
	public OrOperation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndOperation
protected class OrOperation_AndOperationParserRuleCall_0 extends RuleCallToken {
	
	public OrOperation_AndOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getAndOperationParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=
// AndOperation)*
protected class OrOperation_Group_1 extends GroupToken {
	
	public OrOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getGroup_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_SubExpressionsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Operation.subExpressions+=current}
protected class OrOperation_OperationSubExpressionsAction_1_0 extends ActionToken  {

	public OrOperation_OperationSubExpressionsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group_1(parent, this, 0, inst);
			case 1: return new OrOperation_AndOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrOperationAccess().getOperationSubExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("subExpressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("subExpressions")) return null;
		return getDescr((EObject) val);
	}
}

// operator=OperatorOr
protected class OrOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OrOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_OperationSubExpressionsAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getOrOperationAccess().getOperatorOperatorOrEnumRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}

// subExpressions+=AndOperation
protected class OrOperation_SubExpressionsAssignment_1_2 extends AssignmentToken  {
	
	public OrOperation_SubExpressionsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOrOperationAccess().getSubExpressionsAssignment_1_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subExpressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subExpressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrOperationAccess().getSubExpressionsAndOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrOperation ****************/


/************ begin Rule BooleanExpression ****************
 *
 * BooleanExpression returns Expression:
 *   BooleanValue|SignalReference|CompareOperation|"(" OrOperation ")"; 
 * 
 * // TODO: get rid of parentheses
 *
 **/

// BooleanValue|SignalReference|CompareOperation|"(" OrOperation ")" 
// 
// // TODO: get rid of parentheses
protected class BooleanExpression_Alternatives extends AlternativesToken {

	public BooleanExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getAlternatives();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_BooleanValueParserRuleCall_0(parent, this, 0, inst);
			case 1: return new BooleanExpression_SignalReferenceParserRuleCall_1(parent, this, 1, inst);
			case 2: return new BooleanExpression_CompareOperationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new BooleanExpression_Group_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BooleanValue
protected class BooleanExpression_BooleanValueParserRuleCall_0 extends RuleCallToken {
	
	public BooleanExpression_BooleanValueParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getBooleanValueParserRuleCall_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanValue_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanValue_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanValueRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SignalReference
protected class BooleanExpression_SignalReferenceParserRuleCall_1 extends RuleCallToken {
	
	public BooleanExpression_SignalReferenceParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getSignalReferenceParserRuleCall_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SignalReference_ReferenceAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SignalReference_ReferenceAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSignalReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CompareOperation
protected class BooleanExpression_CompareOperationParserRuleCall_2 extends RuleCallToken {
	
	public BooleanExpression_CompareOperationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getCompareOperationParserRuleCall_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompareOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CompareOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCompareOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "(" OrOperation ")"
protected class BooleanExpression_Group_3 extends GroupToken {
	
	public BooleanExpression_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_RightParenthesisKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class BooleanExpression_LeftParenthesisKeyword_3_0 extends KeywordToken  {
	
	public BooleanExpression_LeftParenthesisKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getLeftParenthesisKeyword_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// OrOperation
protected class BooleanExpression_OrOperationParserRuleCall_3_1 extends RuleCallToken {
	
	public BooleanExpression_OrOperationParserRuleCall_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getOrOperationParserRuleCall_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrOperation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrOperation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_LeftParenthesisKeyword_3_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class BooleanExpression_RightParenthesisKeyword_3_2 extends KeywordToken  {
	
	public BooleanExpression_RightParenthesisKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanExpressionAccess().getRightParenthesisKeyword_3_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_OrOperationParserRuleCall_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule BooleanExpression ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression returns Expression:
 *   BooleanExpression; 
 * 
 *     
 * 	//ValueExpression | BooleanExpression;
 *
 **/

// BooleanExpression 
// 	//ValueExpression | BooleanExpression;
protected class PrimaryExpression_BooleanExpressionParserRuleCall extends RuleCallToken {
	
	public PrimaryExpression_BooleanExpressionParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBooleanExpressionParserRuleCall();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule PrimaryExpression ****************/

}
