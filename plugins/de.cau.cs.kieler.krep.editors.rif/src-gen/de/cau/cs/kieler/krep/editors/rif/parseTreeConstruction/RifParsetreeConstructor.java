/*
* generated by Xtext
*/
package de.cau.cs.kieler.krep.editors.rif.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.krep.editors.rif.services.RifGrammarAccess;

import com.google.inject.Inject;

public class RifParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private RifGrammarAccess grammarAccess;
	
	@Override	
	public RifGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trace_Group(this, this, 0, inst);
			case 1: return new Decl_Group(this, this, 1, inst);
			case 2: return new Tick_Group(this, this, 2, inst);
			case 3: return new Data_Alternatives(this, this, 3, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Trace ****************
 *
 * Trace:
 *   "#@inputs" inputs+=decl* "@#" "#@outputs" outputs+=decl* "@#" "#@locals" local+=decl*
 *   "@#" tick+=Tick+;
 *
 **/

// "#@inputs" inputs+=decl* "@#" "#@outputs" outputs+=decl* "@#" "#@locals" local+=decl*
// "@#" tick+=Tick+
protected class Trace_Group extends GroupToken {
	
	public Trace_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTraceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trace_TickAssignment_9(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTraceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "#@inputs"
protected class Trace_InputsKeyword_0 extends KeywordToken  {
	
	public Trace_InputsKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTraceAccess().getInputsKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// inputs+=decl*
protected class Trace_InputsAssignment_1 extends AssignmentToken  {
	
	public Trace_InputsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTraceAccess().getInputsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("inputs",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("inputs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTraceAccess().getInputsDeclParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Trace_InputsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new Trace_InputsKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "@#"
protected class Trace_CommercialAtNumberSignKeyword_2 extends KeywordToken  {
	
	public Trace_CommercialAtNumberSignKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTraceAccess().getCommercialAtNumberSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trace_InputsAssignment_1(parent, this, 0, inst);
			case 1: return new Trace_InputsKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "#@outputs"
protected class Trace_OutputsKeyword_3 extends KeywordToken  {
	
	public Trace_OutputsKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTraceAccess().getOutputsKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trace_CommercialAtNumberSignKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// outputs+=decl*
protected class Trace_OutputsAssignment_4 extends AssignmentToken  {
	
	public Trace_OutputsAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTraceAccess().getOutputsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("outputs",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("outputs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTraceAccess().getOutputsDeclParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Trace_OutputsAssignment_4(parent, next, actIndex, consumed);
			case 1: return new Trace_OutputsKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "@#"
protected class Trace_CommercialAtNumberSignKeyword_5 extends KeywordToken  {
	
	public Trace_CommercialAtNumberSignKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTraceAccess().getCommercialAtNumberSignKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trace_OutputsAssignment_4(parent, this, 0, inst);
			case 1: return new Trace_OutputsKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "#@locals"
protected class Trace_LocalsKeyword_6 extends KeywordToken  {
	
	public Trace_LocalsKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTraceAccess().getLocalsKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trace_CommercialAtNumberSignKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// local+=decl*
protected class Trace_LocalAssignment_7 extends AssignmentToken  {
	
	public Trace_LocalAssignment_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTraceAccess().getLocalAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("local",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("local");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTraceAccess().getLocalDeclParserRuleCall_7_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Trace_LocalAssignment_7(parent, next, actIndex, consumed);
			case 1: return new Trace_LocalsKeyword_6(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "@#"
protected class Trace_CommercialAtNumberSignKeyword_8 extends KeywordToken  {
	
	public Trace_CommercialAtNumberSignKeyword_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTraceAccess().getCommercialAtNumberSignKeyword_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Trace_LocalAssignment_7(parent, this, 0, inst);
			case 1: return new Trace_LocalsKeyword_6(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// tick+=Tick+
protected class Trace_TickAssignment_9 extends AssignmentToken  {
	
	public Trace_TickAssignment_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTraceAccess().getTickAssignment_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tick_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("tick",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tick");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTickRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTraceAccess().getTickTickParserRuleCall_9_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Trace_TickAssignment_9(parent, next, actIndex, consumed);
			case 1: return new Trace_CommercialAtNumberSignKeyword_8(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Trace ****************/


/************ begin Rule decl ****************
 *
 * decl:
 *   "\"" name=ID "\":" type=Type;
 *
 **/

// "\"" name=ID "\":" type=Type
protected class Decl_Group extends GroupToken {
	
	public Decl_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_TypeAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "\""
protected class Decl_QuotationMarkKeyword_0 extends KeywordToken  {
	
	public Decl_QuotationMarkKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDeclAccess().getQuotationMarkKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Decl_NameAssignment_1 extends AssignmentToken  {
	
	public Decl_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_QuotationMarkKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDeclAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "\":"
protected class Decl_QuotationMarkColonKeyword_2 extends KeywordToken  {
	
	public Decl_QuotationMarkColonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getDeclAccess().getQuotationMarkColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=Type
protected class Decl_TypeAssignment_3 extends AssignmentToken  {
	
	public Decl_TypeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclAccess().getTypeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_QuotationMarkColonKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getDeclAccess().getTypeTypeParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule decl ****************/



/************ begin Rule Tick ****************
 *
 * Tick:
 *   {Tick} "#step" nr=INT input+=Data* "#outs" output+=Data* "#locs" local+=Data*;
 *
 **/

// {Tick} "#step" nr=INT input+=Data* "#outs" output+=Data* "#locs" local+=Data*
protected class Tick_Group extends GroupToken {
	
	public Tick_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTickAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tick_LocalAssignment_7(parent, this, 0, inst);
			case 1: return new Tick_LocsKeyword_6(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTickRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Tick}
protected class Tick_TickAction_0 extends ActionToken  {

	public Tick_TickAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTickAccess().getTickAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getTickAccess().getTickAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "#step"
protected class Tick_StepKeyword_1 extends KeywordToken  {
	
	public Tick_StepKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTickAccess().getStepKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tick_TickAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// nr=INT
protected class Tick_NrAssignment_2 extends AssignmentToken  {
	
	public Tick_NrAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTickAccess().getNrAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tick_StepKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("nr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nr");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTickAccess().getNrINTTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// input+=Data*
protected class Tick_InputAssignment_3 extends AssignmentToken  {
	
	public Tick_InputAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTickAccess().getInputAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Data_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("input",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("input");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDataRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTickAccess().getInputDataParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Tick_InputAssignment_3(parent, next, actIndex, consumed);
			case 1: return new Tick_NrAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "#outs"
protected class Tick_OutsKeyword_4 extends KeywordToken  {
	
	public Tick_OutsKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTickAccess().getOutsKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tick_InputAssignment_3(parent, this, 0, inst);
			case 1: return new Tick_NrAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// output+=Data*
protected class Tick_OutputAssignment_5 extends AssignmentToken  {
	
	public Tick_OutputAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTickAccess().getOutputAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Data_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("output",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("output");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDataRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTickAccess().getOutputDataParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Tick_OutputAssignment_5(parent, next, actIndex, consumed);
			case 1: return new Tick_OutsKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "#locs"
protected class Tick_LocsKeyword_6 extends KeywordToken  {
	
	public Tick_LocsKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTickAccess().getLocsKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Tick_OutputAssignment_5(parent, this, 0, inst);
			case 1: return new Tick_OutsKeyword_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// local+=Data*
protected class Tick_LocalAssignment_7 extends AssignmentToken  {
	
	public Tick_LocalAssignment_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTickAccess().getLocalAssignment_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Data_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("local",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("local");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDataRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTickAccess().getLocalDataParserRuleCall_7_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Tick_LocalAssignment_7(parent, next, actIndex, consumed);
			case 1: return new Tick_LocsKeyword_6(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Tick ****************/


/************ begin Rule Data ****************
 *
 * Data:
 *   intVal=INT|true?="T"|false?="F";
 *
 **/

// intVal=INT|true?="T"|false?="F"
protected class Data_Alternatives extends AlternativesToken {

	public Data_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDataAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Data_IntValAssignment_0(parent, this, 0, inst);
			case 1: return new Data_TrueAssignment_1(parent, this, 1, inst);
			case 2: return new Data_FalseAssignment_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDataRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// intVal=INT
protected class Data_IntValAssignment_0 extends AssignmentToken  {
	
	public Data_IntValAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataAccess().getIntValAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("intVal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("intVal");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDataAccess().getIntValINTTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// true?="T"
protected class Data_TrueAssignment_1 extends AssignmentToken  {
	
	public Data_TrueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataAccess().getTrueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("true",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("true");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getDataAccess().getTrueTKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// false?="F"
protected class Data_FalseAssignment_2 extends AssignmentToken  {
	
	public Data_FalseAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataAccess().getFalseAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("false",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("false");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getDataAccess().getFalseFKeyword_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Data ****************/

}
