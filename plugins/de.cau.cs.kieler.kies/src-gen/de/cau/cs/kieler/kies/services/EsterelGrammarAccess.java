/*
* generated by Xtext
*/

package de.cau.cs.kieler.kies.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import de.cau.cs.kieler.core.kexpressions.services.KExpressionsGrammarAccess;
import de.cau.cs.kieler.core.annotations.text.services.AnnotationsGrammarAccess;

@Singleton
public class EsterelGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Program");
		private final Assignment cModulesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cModulesModuleParserRuleCall_0 = (RuleCall)cModulesAssignment.eContents().get(0);
		
		////	root rule. an esterel file can contain multiple modules
		//Program hidden(Esterel_SL_Comment, Esterel_ML_Comment, WS):
		//	modules+=Module*;
		public ParserRule getRule() { return rule; }

		//modules+=Module*
		public Assignment getModulesAssignment() { return cModulesAssignment; }

		//Module
		public RuleCall getModulesModuleParserRuleCall_0() { return cModulesModuleParserRuleCall_0; }
	}

	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cInterfaceAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInterfaceModuleInterfaceParserRuleCall_3_0 = (RuleCall)cInterfaceAssignment_3.eContents().get(0);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyModuleBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		private final Assignment cEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cEndEndModuleParserRuleCall_5_0 = (RuleCall)cEndAssignment_5.eContents().get(0);
		
		//// a module consists of an interface and a body
		//// !-(module)
		//Module:
		//	"module" name=ID ":" interface=ModuleInterface? body=ModuleBody end=EndModule;
		public ParserRule getRule() { return rule; }

		//"module" name=ID ":" interface=ModuleInterface? body=ModuleBody end=EndModule
		public Group getGroup() { return cGroup; }

		//"module"
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//interface=ModuleInterface?
		public Assignment getInterfaceAssignment_3() { return cInterfaceAssignment_3; }

		//ModuleInterface
		public RuleCall getInterfaceModuleInterfaceParserRuleCall_3_0() { return cInterfaceModuleInterfaceParserRuleCall_3_0; }

		//body=ModuleBody
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//ModuleBody
		public RuleCall getBodyModuleBodyParserRuleCall_4_0() { return cBodyModuleBodyParserRuleCall_4_0; }

		//end=EndModule
		public Assignment getEndAssignment_5() { return cEndAssignment_5; }

		//EndModule
		public RuleCall getEndEndModuleParserRuleCall_5_0() { return cEndEndModuleParserRuleCall_5_0; }
	}

	public class EndModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EndModule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cEndKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cModuleKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		////deprecated
		//EndModule:
		//	"end" "module" | ".";
		public ParserRule getRule() { return rule; }

		//"end" "module" | "."
		public Alternatives getAlternatives() { return cAlternatives; }

		//"end" "module"
		public Group getGroup_0() { return cGroup_0; }

		//"end"
		public Keyword getEndKeyword_0_0() { return cEndKeyword_0_0; }

		//"module"
		public Keyword getModuleKeyword_0_1() { return cModuleKeyword_0_1; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
	}

	public class ModuleBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModuleBody");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//ModuleBody:
		//	statements+=Statement;
		public ParserRule getRule() { return rule; }

		//statements+=Statement
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}

	public class ModuleInterfaceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModuleInterface");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIntSignalDeclsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIntSignalDeclsInterfaceSignalDeclParserRuleCall_0_0 = (RuleCall)cIntSignalDeclsAssignment_0.eContents().get(0);
		private final Assignment cIntTypeDeclsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cIntTypeDeclsTypeDeclParserRuleCall_1_0 = (RuleCall)cIntTypeDeclsAssignment_1.eContents().get(0);
		private final Assignment cIntSensorDeclsAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cIntSensorDeclsSensorDeclParserRuleCall_2_0 = (RuleCall)cIntSensorDeclsAssignment_2.eContents().get(0);
		private final Assignment cIntConstantDeclsAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cIntConstantDeclsConstantDeclsParserRuleCall_3_0 = (RuleCall)cIntConstantDeclsAssignment_3.eContents().get(0);
		private final Assignment cIntRelationDeclsAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cIntRelationDeclsRelationDeclParserRuleCall_4_0 = (RuleCall)cIntRelationDeclsAssignment_4.eContents().get(0);
		private final Assignment cIntTaskDeclsAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cIntTaskDeclsTaskDeclParserRuleCall_5_0 = (RuleCall)cIntTaskDeclsAssignment_5.eContents().get(0);
		private final Assignment cIntFunctionDeclsAssignment_6 = (Assignment)cAlternatives.eContents().get(6);
		private final RuleCall cIntFunctionDeclsFunctionDeclParserRuleCall_6_0 = (RuleCall)cIntFunctionDeclsAssignment_6.eContents().get(0);
		private final Assignment cIntProcedureDeclsAssignment_7 = (Assignment)cAlternatives.eContents().get(7);
		private final RuleCall cIntProcedureDeclsProcedureDeclParserRuleCall_7_0 = (RuleCall)cIntProcedureDeclsAssignment_7.eContents().get(0);
		
		//// -!
		////            Interface Declarations
		//// ----------------------------------------------
		//ModuleInterface:
		//	(intSignalDecls+=InterfaceSignalDecl | intTypeDecls+=TypeDecl | intSensorDecls+=SensorDecl |
		//	intConstantDecls+=ConstantDecls | intRelationDecls+=RelationDecl | intTaskDecls+=TaskDecl |
		//	intFunctionDecls+=FunctionDecl | intProcedureDecls+=ProcedureDecl)+;
		public ParserRule getRule() { return rule; }

		//(intSignalDecls+=InterfaceSignalDecl | intTypeDecls+=TypeDecl | intSensorDecls+=SensorDecl |
		//intConstantDecls+=ConstantDecls | intRelationDecls+=RelationDecl | intTaskDecls+=TaskDecl |
		//intFunctionDecls+=FunctionDecl | intProcedureDecls+=ProcedureDecl)+
		public Alternatives getAlternatives() { return cAlternatives; }

		//intSignalDecls+=InterfaceSignalDecl
		public Assignment getIntSignalDeclsAssignment_0() { return cIntSignalDeclsAssignment_0; }

		//InterfaceSignalDecl
		public RuleCall getIntSignalDeclsInterfaceSignalDeclParserRuleCall_0_0() { return cIntSignalDeclsInterfaceSignalDeclParserRuleCall_0_0; }

		//intTypeDecls+=TypeDecl
		public Assignment getIntTypeDeclsAssignment_1() { return cIntTypeDeclsAssignment_1; }

		//TypeDecl
		public RuleCall getIntTypeDeclsTypeDeclParserRuleCall_1_0() { return cIntTypeDeclsTypeDeclParserRuleCall_1_0; }

		//intSensorDecls+=SensorDecl
		public Assignment getIntSensorDeclsAssignment_2() { return cIntSensorDeclsAssignment_2; }

		//SensorDecl
		public RuleCall getIntSensorDeclsSensorDeclParserRuleCall_2_0() { return cIntSensorDeclsSensorDeclParserRuleCall_2_0; }

		//intConstantDecls+=ConstantDecls
		public Assignment getIntConstantDeclsAssignment_3() { return cIntConstantDeclsAssignment_3; }

		//ConstantDecls
		public RuleCall getIntConstantDeclsConstantDeclsParserRuleCall_3_0() { return cIntConstantDeclsConstantDeclsParserRuleCall_3_0; }

		//intRelationDecls+=RelationDecl
		public Assignment getIntRelationDeclsAssignment_4() { return cIntRelationDeclsAssignment_4; }

		//RelationDecl
		public RuleCall getIntRelationDeclsRelationDeclParserRuleCall_4_0() { return cIntRelationDeclsRelationDeclParserRuleCall_4_0; }

		//intTaskDecls+=TaskDecl
		public Assignment getIntTaskDeclsAssignment_5() { return cIntTaskDeclsAssignment_5; }

		//TaskDecl
		public RuleCall getIntTaskDeclsTaskDeclParserRuleCall_5_0() { return cIntTaskDeclsTaskDeclParserRuleCall_5_0; }

		//intFunctionDecls+=FunctionDecl
		public Assignment getIntFunctionDeclsAssignment_6() { return cIntFunctionDeclsAssignment_6; }

		//FunctionDecl
		public RuleCall getIntFunctionDeclsFunctionDeclParserRuleCall_6_0() { return cIntFunctionDeclsFunctionDeclParserRuleCall_6_0; }

		//intProcedureDecls+=ProcedureDecl
		public Assignment getIntProcedureDeclsAssignment_7() { return cIntProcedureDeclsAssignment_7; }

		//ProcedureDecl
		public RuleCall getIntProcedureDeclsProcedureDeclParserRuleCall_7_0() { return cIntProcedureDeclsProcedureDeclParserRuleCall_7_0; }
	}

	public class ChannelDescriptionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ChannelDescription");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cColonKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTypeEsterelTypeIdentifierParserRuleCall_0_1_0 = (RuleCall)cTypeAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeEsterelTypeIdentifierParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cColonKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cTypeAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cTypeEsterelTypeIdentifierParserRuleCall_2_3_0 = (RuleCall)cTypeAssignment_2_3.eContents().get(0);
		
		//// overwrite to add the EsterelTypeIdentifier
		//ChannelDescription:
		//	":" type=EsterelTypeIdentifier | "(" type=EsterelTypeIdentifier ")" | ":=" expression=Expression ":"
		//	type=EsterelTypeIdentifier;
		public ParserRule getRule() { return rule; }

		//":" type=EsterelTypeIdentifier | "(" type=EsterelTypeIdentifier ")" | ":=" expression=Expression ":"
		//type=EsterelTypeIdentifier
		public Alternatives getAlternatives() { return cAlternatives; }

		//":" type=EsterelTypeIdentifier
		public Group getGroup_0() { return cGroup_0; }

		//":"
		public Keyword getColonKeyword_0_0() { return cColonKeyword_0_0; }

		//type=EsterelTypeIdentifier
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }

		//EsterelTypeIdentifier
		public RuleCall getTypeEsterelTypeIdentifierParserRuleCall_0_1_0() { return cTypeEsterelTypeIdentifierParserRuleCall_0_1_0; }

		//"(" type=EsterelTypeIdentifier ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//type=EsterelTypeIdentifier
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//EsterelTypeIdentifier
		public RuleCall getTypeEsterelTypeIdentifierParserRuleCall_1_1_0() { return cTypeEsterelTypeIdentifierParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//":=" expression=Expression ":" type=EsterelTypeIdentifier
		public Group getGroup_2() { return cGroup_2; }

		//":="
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }

		//":"
		public Keyword getColonKeyword_2_2() { return cColonKeyword_2_2; }

		//type=EsterelTypeIdentifier
		public Assignment getTypeAssignment_2_3() { return cTypeAssignment_2_3; }

		//EsterelTypeIdentifier
		public RuleCall getTypeEsterelTypeIdentifierParserRuleCall_2_3_0() { return cTypeEsterelTypeIdentifierParserRuleCall_2_3_0; }
	}

	public class EsterelTypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EsterelTypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_1_0 = (RuleCall)cTypeIDAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cEsterelTypeIdentifierAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCombineKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Alternatives cAlternatives_2_1_1 = (Alternatives)cGroup_2_1.eContents().get(1);
		private final Assignment cTypeAssignment_2_1_1_0 = (Assignment)cAlternatives_2_1_1.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_2_1_1_0_0 = (RuleCall)cTypeAssignment_2_1_1_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_2_1_1_1 = (Assignment)cAlternatives_2_1_1.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_2_1_1_1_0 = (RuleCall)cTypeIDAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cWithKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final Alternatives cAlternatives_2_1_3 = (Alternatives)cGroup_2_1.eContents().get(3);
		private final Assignment cFuncAssignment_2_1_3_0 = (Assignment)cAlternatives_2_1_3.eContents().get(0);
		private final CrossReference cFuncFunctionCrossReference_2_1_3_0_0 = (CrossReference)cFuncAssignment_2_1_3_0.eContents().get(0);
		private final RuleCall cFuncFunctionIDTerminalRuleCall_2_1_3_0_0_1 = (RuleCall)cFuncFunctionCrossReference_2_1_3_0_0.eContents().get(1);
		private final Assignment cOperatorAssignment_2_1_3_1 = (Assignment)cAlternatives_2_1_3.eContents().get(1);
		private final RuleCall cOperatorCombineOperatorEnumRuleCall_2_1_3_1_0 = (RuleCall)cOperatorAssignment_2_1_3_1.eContents().get(0);
		
		//// overwrite to allow function references for signal declarations
		//EsterelTypeIdentifier returns kexpressions::TypeIdentifier:
		//	type=ValueType | typeID=ID | {EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] |
		//	operator=CombineOperator));
		public ParserRule getRule() { return rule; }

		//type=ValueType | typeID=ID | {EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] |
		//operator=CombineOperator))
		public Alternatives getAlternatives() { return cAlternatives; }

		//type=ValueType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_0_0() { return cTypeValueTypeEnumRuleCall_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_1() { return cTypeIDAssignment_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_1_0() { return cTypeIDIDTerminalRuleCall_1_0; }

		//{EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] | operator=CombineOperator))
		public Group getGroup_2() { return cGroup_2; }

		//{EsterelTypeIdentifier}
		public Action getEsterelTypeIdentifierAction_2_0() { return cEsterelTypeIdentifierAction_2_0; }

		//"combine" (type=ValueType | typeID=ID) "with" (func=[Function] | operator=CombineOperator)
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"combine"
		public Keyword getCombineKeyword_2_1_0() { return cCombineKeyword_2_1_0; }

		//type=ValueType | typeID=ID
		public Alternatives getAlternatives_2_1_1() { return cAlternatives_2_1_1; }

		//type=ValueType
		public Assignment getTypeAssignment_2_1_1_0() { return cTypeAssignment_2_1_1_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_2_1_1_0_0() { return cTypeValueTypeEnumRuleCall_2_1_1_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_2_1_1_1() { return cTypeIDAssignment_2_1_1_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_2_1_1_1_0() { return cTypeIDIDTerminalRuleCall_2_1_1_1_0; }

		//"with"
		public Keyword getWithKeyword_2_1_2() { return cWithKeyword_2_1_2; }

		//func=[Function] | operator=CombineOperator
		public Alternatives getAlternatives_2_1_3() { return cAlternatives_2_1_3; }

		//func=[Function]
		public Assignment getFuncAssignment_2_1_3_0() { return cFuncAssignment_2_1_3_0; }

		//[Function]
		public CrossReference getFuncFunctionCrossReference_2_1_3_0_0() { return cFuncFunctionCrossReference_2_1_3_0_0; }

		//ID
		public RuleCall getFuncFunctionIDTerminalRuleCall_2_1_3_0_0_1() { return cFuncFunctionIDTerminalRuleCall_2_1_3_0_0_1; }

		//operator=CombineOperator
		public Assignment getOperatorAssignment_2_1_3_1() { return cOperatorAssignment_2_1_3_1; }

		//CombineOperator
		public RuleCall getOperatorCombineOperatorEnumRuleCall_2_1_3_1_0() { return cOperatorCombineOperatorEnumRuleCall_2_1_3_1_0; }
	}

	public class TypeIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeIdentifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_1_0 = (RuleCall)cTypeIDAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cCombineKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Assignment cTypeAssignment_2_1_0 = (Assignment)cAlternatives_2_1.eContents().get(0);
		private final RuleCall cTypeValueTypeEnumRuleCall_2_1_0_0 = (RuleCall)cTypeAssignment_2_1_0.eContents().get(0);
		private final Assignment cTypeIDAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cTypeIDIDTerminalRuleCall_2_1_1_0 = (RuleCall)cTypeIDAssignment_2_1_1.eContents().get(0);
		private final Keyword cWithKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cOperatorAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cOperatorCombineOperatorEnumRuleCall_2_3_0 = (RuleCall)cOperatorAssignment_2_3.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cEsterelTypeAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cEstTypeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cEstTypeTypeCrossReference_3_1_0 = (CrossReference)cEstTypeAssignment_3_1.eContents().get(0);
		private final RuleCall cEstTypeTypeIDTerminalRuleCall_3_1_0_1 = (RuleCall)cEstTypeTypeCrossReference_3_1_0.eContents().get(1);
		
		//// overwrite to allow type definitions in a specific module
		//TypeIdentifier:
		//	type=ValueType | typeID=ID | "combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator | {EsterelType}
		//	estType=[Type];
		public ParserRule getRule() { return rule; }

		//type=ValueType | typeID=ID | "combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator | {EsterelType}
		//estType=[Type]
		public Alternatives getAlternatives() { return cAlternatives; }

		//type=ValueType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_0_0() { return cTypeValueTypeEnumRuleCall_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_1() { return cTypeIDAssignment_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_1_0() { return cTypeIDIDTerminalRuleCall_1_0; }

		//"combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator
		public Group getGroup_2() { return cGroup_2; }

		//"combine"
		public Keyword getCombineKeyword_2_0() { return cCombineKeyword_2_0; }

		//type=ValueType | typeID=ID
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//type=ValueType
		public Assignment getTypeAssignment_2_1_0() { return cTypeAssignment_2_1_0; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_2_1_0_0() { return cTypeValueTypeEnumRuleCall_2_1_0_0; }

		//typeID=ID
		public Assignment getTypeIDAssignment_2_1_1() { return cTypeIDAssignment_2_1_1; }

		//ID
		public RuleCall getTypeIDIDTerminalRuleCall_2_1_1_0() { return cTypeIDIDTerminalRuleCall_2_1_1_0; }

		//"with"
		public Keyword getWithKeyword_2_2() { return cWithKeyword_2_2; }

		//operator=CombineOperator
		public Assignment getOperatorAssignment_2_3() { return cOperatorAssignment_2_3; }

		//CombineOperator
		public RuleCall getOperatorCombineOperatorEnumRuleCall_2_3_0() { return cOperatorCombineOperatorEnumRuleCall_2_3_0; }

		//{EsterelType} estType=[Type]
		public Group getGroup_3() { return cGroup_3; }

		//{EsterelType}
		public Action getEsterelTypeAction_3_0() { return cEsterelTypeAction_3_0; }

		//estType=[Type]
		public Assignment getEstTypeAssignment_3_1() { return cEstTypeAssignment_3_1; }

		//[Type]
		public CrossReference getEstTypeTypeCrossReference_3_1_0() { return cEstTypeTypeCrossReference_3_1_0; }

		//ID
		public RuleCall getEstTypeTypeIDTerminalRuleCall_3_1_0_1() { return cEstTypeTypeIDTerminalRuleCall_3_1_0_1; }
	}

	public class LocalSignalDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalSignalDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSignalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSignalListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignalListLocalSignalListParserRuleCall_1_0 = (RuleCall)cSignalListAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cOptEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cOptEndSignalKeyword_5_0 = (Keyword)cOptEndAssignment_5.eContents().get(0);
		
		//// ==> Local Signal Declaration
		//// !-(localsignal) -------------------------------------
		//LocalSignalDecl:
		//	"signal" signalList=LocalSignalList "in" statement=Statement "end" optEnd="signal"?;
		public ParserRule getRule() { return rule; }

		//"signal" signalList=LocalSignalList "in" statement=Statement "end" optEnd="signal"?
		public Group getGroup() { return cGroup; }

		//"signal"
		public Keyword getSignalKeyword_0() { return cSignalKeyword_0; }

		//signalList=LocalSignalList
		public Assignment getSignalListAssignment_1() { return cSignalListAssignment_1; }

		//LocalSignalList
		public RuleCall getSignalListLocalSignalListParserRuleCall_1_0() { return cSignalListLocalSignalListParserRuleCall_1_0; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }

		//optEnd="signal"?
		public Assignment getOptEndAssignment_5() { return cOptEndAssignment_5; }

		//"signal"
		public Keyword getOptEndSignalKeyword_5_0() { return cOptEndSignalKeyword_5_0; }
	}

	public class LocalSignalListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalSignalList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLocalSignalAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSignalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignalISignalParserRuleCall_1_0 = (RuleCall)cSignalAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSignalAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSignalISignalParserRuleCall_2_1_0 = (RuleCall)cSignalAssignment_2_1.eContents().get(0);
		
		//LocalSignalList:
		//	{LocalSignal} signal+=ISignal ("," signal+=ISignal)*;
		public ParserRule getRule() { return rule; }

		//{LocalSignal} signal+=ISignal ("," signal+=ISignal)*
		public Group getGroup() { return cGroup; }

		//{LocalSignal}
		public Action getLocalSignalAction_0() { return cLocalSignalAction_0; }

		//signal+=ISignal
		public Assignment getSignalAssignment_1() { return cSignalAssignment_1; }

		//ISignal
		public RuleCall getSignalISignalParserRuleCall_1_0() { return cSignalISignalParserRuleCall_1_0; }

		//("," signal+=ISignal)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//signal+=ISignal
		public Assignment getSignalAssignment_2_1() { return cSignalAssignment_2_1; }

		//ISignal
		public RuleCall getSignalISignalParserRuleCall_2_1_0() { return cSignalISignalParserRuleCall_2_1_0; }
	}

	public class SensorDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SensorDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSensorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSensorsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSensorsSensorWithTypeParserRuleCall_1_0 = (RuleCall)cSensorsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSensorsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSensorsSensorWithTypeParserRuleCall_2_1_0 = (RuleCall)cSensorsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// -!
		//// ==> Sensor
		//// -------------------------------------
		//SensorDecl:
		//	"sensor" sensors+=SensorWithType ("," sensors+=SensorWithType)* ";";
		public ParserRule getRule() { return rule; }

		//"sensor" sensors+=SensorWithType ("," sensors+=SensorWithType)* ";"
		public Group getGroup() { return cGroup; }

		//"sensor"
		public Keyword getSensorKeyword_0() { return cSensorKeyword_0; }

		//sensors+=SensorWithType
		public Assignment getSensorsAssignment_1() { return cSensorsAssignment_1; }

		//SensorWithType
		public RuleCall getSensorsSensorWithTypeParserRuleCall_1_0() { return cSensorsSensorWithTypeParserRuleCall_1_0; }

		//("," sensors+=SensorWithType)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//sensors+=SensorWithType
		public Assignment getSensorsAssignment_2_1() { return cSensorsAssignment_2_1; }

		//SensorWithType
		public RuleCall getSensorsSensorWithTypeParserRuleCall_2_1_0() { return cSensorsSensorWithTypeParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class SensorWithTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SensorWithType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cSensorAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cSensorSensorParserRuleCall_0_0_0 = (RuleCall)cSensorAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cColonKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cTypeAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_0_1_1_0 = (RuleCall)cTypeAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cSensorAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cSensorSensorParserRuleCall_1_0_0 = (RuleCall)cSensorAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTypeAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_1_2_0 = (RuleCall)cTypeAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//SensorWithType:
		//	sensor=Sensor (":" type=TypeIdentifier) | sensor=Sensor "(" type=TypeIdentifier ")";
		public ParserRule getRule() { return rule; }

		//sensor=Sensor (":" type=TypeIdentifier) | sensor=Sensor "(" type=TypeIdentifier ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//sensor=Sensor (":" type=TypeIdentifier)
		public Group getGroup_0() { return cGroup_0; }

		//sensor=Sensor
		public Assignment getSensorAssignment_0_0() { return cSensorAssignment_0_0; }

		//Sensor
		public RuleCall getSensorSensorParserRuleCall_0_0_0() { return cSensorSensorParserRuleCall_0_0_0; }

		//":" type=TypeIdentifier
		public Group getGroup_0_1() { return cGroup_0_1; }

		//":"
		public Keyword getColonKeyword_0_1_0() { return cColonKeyword_0_1_0; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_0_1_1() { return cTypeAssignment_0_1_1; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_0_1_1_0() { return cTypeTypeIdentifierParserRuleCall_0_1_1_0; }

		//sensor=Sensor "(" type=TypeIdentifier ")"
		public Group getGroup_1() { return cGroup_1; }

		//sensor=Sensor
		public Assignment getSensorAssignment_1_0() { return cSensorAssignment_1_0; }

		//Sensor
		public RuleCall getSensorSensorParserRuleCall_1_0_0() { return cSensorSensorParserRuleCall_1_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_1_2() { return cTypeAssignment_1_2; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_1_2_0() { return cTypeTypeIdentifierParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class SensorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sensor");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Sensor returns kexpressions::ISignal:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class RelationDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRelationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRelationKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRelationsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationsRelationTypeParserRuleCall_2_0 = (RuleCall)cRelationsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRelationsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRelationsRelationTypeParserRuleCall_3_1_0 = (RuleCall)cRelationsAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// ==> Relations
		//// -------------------------------------
		//RelationDecl:
		//	{Relation} "relation" relations+=RelationType ("," relations+=RelationType)* ";";
		public ParserRule getRule() { return rule; }

		//{Relation} "relation" relations+=RelationType ("," relations+=RelationType)* ";"
		public Group getGroup() { return cGroup; }

		//{Relation}
		public Action getRelationAction_0() { return cRelationAction_0; }

		//"relation"
		public Keyword getRelationKeyword_1() { return cRelationKeyword_1; }

		//relations+=RelationType
		public Assignment getRelationsAssignment_2() { return cRelationsAssignment_2; }

		//RelationType
		public RuleCall getRelationsRelationTypeParserRuleCall_2_0() { return cRelationsRelationTypeParserRuleCall_2_0; }

		//("," relations+=RelationType)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//relations+=RelationType
		public Assignment getRelationsAssignment_3_1() { return cRelationsAssignment_3_1; }

		//RelationType
		public RuleCall getRelationsRelationTypeParserRuleCall_3_1_0() { return cRelationsRelationTypeParserRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class RelationTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRelationImplicationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRelationIncompatibilityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//RelationType:
		//	RelationImplication | RelationIncompatibility;
		public ParserRule getRule() { return rule; }

		//RelationImplication | RelationIncompatibility
		public Alternatives getAlternatives() { return cAlternatives; }

		//RelationImplication
		public RuleCall getRelationImplicationParserRuleCall_0() { return cRelationImplicationParserRuleCall_0; }

		//RelationIncompatibility
		public RuleCall getRelationIncompatibilityParserRuleCall_1() { return cRelationIncompatibilityParserRuleCall_1; }
	}

	public class RelationImplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationImplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFirstAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFirstISignalCrossReference_0_0 = (CrossReference)cFirstAssignment_0.eContents().get(0);
		private final RuleCall cFirstISignalIDTerminalRuleCall_0_0_1 = (RuleCall)cFirstISignalCrossReference_0_0.eContents().get(1);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cTypeEqualsSignGreaterThanSignKeyword_1_0 = (Keyword)cTypeAssignment_1.eContents().get(0);
		private final Assignment cSecondAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cSecondISignalCrossReference_2_0 = (CrossReference)cSecondAssignment_2.eContents().get(0);
		private final RuleCall cSecondISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cSecondISignalCrossReference_2_0.eContents().get(1);
		
		//RelationImplication:
		//	first=[kexpressions::ISignal] type="=>" second=[kexpressions::ISignal];
		public ParserRule getRule() { return rule; }

		//first=[kexpressions::ISignal] type="=>" second=[kexpressions::ISignal]
		public Group getGroup() { return cGroup; }

		//first=[kexpressions::ISignal]
		public Assignment getFirstAssignment_0() { return cFirstAssignment_0; }

		//[kexpressions::ISignal]
		public CrossReference getFirstISignalCrossReference_0_0() { return cFirstISignalCrossReference_0_0; }

		//ID
		public RuleCall getFirstISignalIDTerminalRuleCall_0_0_1() { return cFirstISignalIDTerminalRuleCall_0_0_1; }

		//type="=>"
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//"=>"
		public Keyword getTypeEqualsSignGreaterThanSignKeyword_1_0() { return cTypeEqualsSignGreaterThanSignKeyword_1_0; }

		//second=[kexpressions::ISignal]
		public Assignment getSecondAssignment_2() { return cSecondAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getSecondISignalCrossReference_2_0() { return cSecondISignalCrossReference_2_0; }

		//ID
		public RuleCall getSecondISignalIDTerminalRuleCall_2_0_1() { return cSecondISignalIDTerminalRuleCall_2_0_1; }
	}

	public class RelationIncompatibilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationIncompatibility");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIncompAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cIncompISignalCrossReference_0_0 = (CrossReference)cIncompAssignment_0.eContents().get(0);
		private final RuleCall cIncompISignalIDTerminalRuleCall_0_0_1 = (RuleCall)cIncompISignalCrossReference_0_0.eContents().get(1);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cTypeNumberSignKeyword_1_0 = (Keyword)cTypeAssignment_1.eContents().get(0);
		private final Assignment cIncompAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cIncompISignalCrossReference_2_0 = (CrossReference)cIncompAssignment_2.eContents().get(0);
		private final RuleCall cIncompISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cIncompISignalCrossReference_2_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cNumberSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cIncompAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cIncompISignalCrossReference_3_1_0 = (CrossReference)cIncompAssignment_3_1.eContents().get(0);
		private final RuleCall cIncompISignalIDTerminalRuleCall_3_1_0_1 = (RuleCall)cIncompISignalCrossReference_3_1_0.eContents().get(1);
		
		//RelationIncompatibility:
		//	incomp+=[kexpressions::ISignal] type="#" incomp+=[kexpressions::ISignal] ("#" incomp+=[kexpressions::ISignal])*;
		public ParserRule getRule() { return rule; }

		//incomp+=[kexpressions::ISignal] type="#" incomp+=[kexpressions::ISignal] ("#" incomp+=[kexpressions::ISignal])*
		public Group getGroup() { return cGroup; }

		//incomp+=[kexpressions::ISignal]
		public Assignment getIncompAssignment_0() { return cIncompAssignment_0; }

		//[kexpressions::ISignal]
		public CrossReference getIncompISignalCrossReference_0_0() { return cIncompISignalCrossReference_0_0; }

		//ID
		public RuleCall getIncompISignalIDTerminalRuleCall_0_0_1() { return cIncompISignalIDTerminalRuleCall_0_0_1; }

		//type="#"
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//"#"
		public Keyword getTypeNumberSignKeyword_1_0() { return cTypeNumberSignKeyword_1_0; }

		//incomp+=[kexpressions::ISignal]
		public Assignment getIncompAssignment_2() { return cIncompAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getIncompISignalCrossReference_2_0() { return cIncompISignalCrossReference_2_0; }

		//ID
		public RuleCall getIncompISignalIDTerminalRuleCall_2_0_1() { return cIncompISignalIDTerminalRuleCall_2_0_1; }

		//("#" incomp+=[kexpressions::ISignal])*
		public Group getGroup_3() { return cGroup_3; }

		//"#"
		public Keyword getNumberSignKeyword_3_0() { return cNumberSignKeyword_3_0; }

		//incomp+=[kexpressions::ISignal]
		public Assignment getIncompAssignment_3_1() { return cIncompAssignment_3_1; }

		//[kexpressions::ISignal]
		public CrossReference getIncompISignalCrossReference_3_1_0() { return cIncompISignalCrossReference_3_1_0; }

		//ID
		public RuleCall getIncompISignalIDTerminalRuleCall_3_1_0_1() { return cIncompISignalIDTerminalRuleCall_3_1_0_1; }
	}

	public class TypeDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypesTypeParserRuleCall_1_0 = (RuleCall)cTypesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTypesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypesTypeParserRuleCall_2_1_0 = (RuleCall)cTypesAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Types
		//// -------------------------------------
		//TypeDecl:
		//	"type" types+=Type ("," types+=Type)* ";";
		public ParserRule getRule() { return rule; }

		//"type" types+=Type ("," types+=Type)* ";"
		public Group getGroup() { return cGroup; }

		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//types+=Type
		public Assignment getTypesAssignment_1() { return cTypesAssignment_1; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_1_0() { return cTypesTypeParserRuleCall_1_0; }

		//("," types+=Type)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//types+=Type
		public Assignment getTypesAssignment_2_1() { return cTypesAssignment_2_1; }

		//Type
		public RuleCall getTypesTypeParserRuleCall_2_1_0() { return cTypesTypeParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Type:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class ConstantDeclsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantDecls");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstantKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstantsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstantsOneTypeConstantDeclsParserRuleCall_1_0 = (RuleCall)cConstantsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cConstantsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cConstantsOneTypeConstantDeclsParserRuleCall_2_1_0 = (RuleCall)cConstantsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Constants
		//// -------------------------------------
		//ConstantDecls:
		//	"constant" constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* ";";
		public ParserRule getRule() { return rule; }

		//"constant" constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* ";"
		public Group getGroup() { return cGroup; }

		//"constant"
		public Keyword getConstantKeyword_0() { return cConstantKeyword_0; }

		//constants+=OneTypeConstantDecls
		public Assignment getConstantsAssignment_1() { return cConstantsAssignment_1; }

		//OneTypeConstantDecls
		public RuleCall getConstantsOneTypeConstantDeclsParserRuleCall_1_0() { return cConstantsOneTypeConstantDeclsParserRuleCall_1_0; }

		//("," constants+=OneTypeConstantDecls)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//constants+=OneTypeConstantDecls
		public Assignment getConstantsAssignment_2_1() { return cConstantsAssignment_2_1; }

		//OneTypeConstantDecls
		public RuleCall getConstantsOneTypeConstantDeclsParserRuleCall_2_1_0() { return cConstantsOneTypeConstantDeclsParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class OneTypeConstantDeclsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OneTypeConstantDecls");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantsConstantWithValueParserRuleCall_0_0 = (RuleCall)cConstantsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConstantsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConstantsConstantWithValueParserRuleCall_1_1_0 = (RuleCall)cConstantsAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//OneTypeConstantDecls:
		//	constants+=ConstantWithValue ("," constants+=ConstantWithValue)* ":" type=TypeIdentifier;
		public ParserRule getRule() { return rule; }

		//constants+=ConstantWithValue ("," constants+=ConstantWithValue)* ":" type=TypeIdentifier
		public Group getGroup() { return cGroup; }

		//constants+=ConstantWithValue
		public Assignment getConstantsAssignment_0() { return cConstantsAssignment_0; }

		//ConstantWithValue
		public RuleCall getConstantsConstantWithValueParserRuleCall_0_0() { return cConstantsConstantWithValueParserRuleCall_0_0; }

		//("," constants+=ConstantWithValue)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//constants+=ConstantWithValue
		public Assignment getConstantsAssignment_1_1() { return cConstantsAssignment_1_1; }

		//ConstantWithValue
		public RuleCall getConstantsConstantWithValueParserRuleCall_1_1_0() { return cConstantsConstantWithValueParserRuleCall_1_1_0; }

		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_3_0() { return cTypeTypeIdentifierParserRuleCall_3_0; }
	}

	public class ConstantWithValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantWithValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantConstantParserRuleCall_0_0 = (RuleCall)cConstantAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueConstantAtomParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//ConstantWithValue:
		//	constant=Constant ("=" value=ConstantAtom)?;
		public ParserRule getRule() { return rule; }

		//constant=Constant ("=" value=ConstantAtom)?
		public Group getGroup() { return cGroup; }

		//constant=Constant
		public Assignment getConstantAssignment_0() { return cConstantAssignment_0; }

		//Constant
		public RuleCall getConstantConstantParserRuleCall_0_0() { return cConstantConstantParserRuleCall_0_0; }

		//("=" value=ConstantAtom)?
		public Group getGroup_1() { return cGroup_1; }

		//"="
		public Keyword getEqualsSignKeyword_1_0() { return cEqualsSignKeyword_1_0; }

		//value=ConstantAtom
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//ConstantAtom
		public RuleCall getValueConstantAtomParserRuleCall_1_1_0() { return cValueConstantAtomParserRuleCall_1_1_0; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Constant returns kexpressions::ValuedObject:
		//	{Constant} name=ID;
		public ParserRule getRule() { return rule; }

		//{Constant} name=ID
		public Group getGroup() { return cGroup; }

		//{Constant}
		public Action getConstantAction_0() { return cConstantAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}

	public class ConstantAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantAtom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstantLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ConstantAtom:
		//	INT | ConstantLiteral;
		public ParserRule getRule() { return rule; }

		//INT | ConstantLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//ConstantLiteral
		public RuleCall getConstantLiteralParserRuleCall_1() { return cConstantLiteralParserRuleCall_1; }
	}

	public class ConstantLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFloatTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSTRINGTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ConstantLiteral:
		//	Float | Boolean | ID | STRING;
		public ParserRule getRule() { return rule; }

		//Float | Boolean | ID | STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//Float
		public RuleCall getFloatTerminalRuleCall_0() { return cFloatTerminalRuleCall_0; }

		//Boolean
		public RuleCall getBooleanTerminalRuleCall_1() { return cBooleanTerminalRuleCall_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_2() { return cIDTerminalRuleCall_2; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_3() { return cSTRINGTerminalRuleCall_3; }
	}

	public class FunctionDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFunctionsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_1_0 = (RuleCall)cFunctionsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cFunctionsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFunctionsFunctionParserRuleCall_2_1_0 = (RuleCall)cFunctionsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Functions
		//// -------------------------------------
		//FunctionDecl:
		//	"function" functions+=Function ("," functions+=Function)* ";";
		public ParserRule getRule() { return rule; }

		//"function" functions+=Function ("," functions+=Function)* ";"
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_1() { return cFunctionsAssignment_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_1_0() { return cFunctionsFunctionParserRuleCall_1_0; }

		//("," functions+=Function)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//functions+=Function
		public Assignment getFunctionsAssignment_2_1() { return cFunctionsAssignment_2_1; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_2_1_0() { return cFunctionsFunctionParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cIdListAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cIdListTypeIdentifierParserRuleCall_2_0_0 = (RuleCall)cIdListAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cIdListAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cIdListTypeIdentifierParserRuleCall_2_1_1_0 = (RuleCall)cIdListAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTypeTypeIdentifierParserRuleCall_5_0 = (RuleCall)cTypeAssignment_5.eContents().get(0);
		
		//Function:
		//	name=ID "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" ":" type=TypeIdentifier;
		public ParserRule getRule() { return rule; }

		//name=ID "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" ":" type=TypeIdentifier
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)?
		public Group getGroup_2() { return cGroup_2; }

		//idList+=TypeIdentifier
		public Assignment getIdListAssignment_2_0() { return cIdListAssignment_2_0; }

		//TypeIdentifier
		public RuleCall getIdListTypeIdentifierParserRuleCall_2_0_0() { return cIdListTypeIdentifierParserRuleCall_2_0_0; }

		//("," idList+=TypeIdentifier)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//idList+=TypeIdentifier
		public Assignment getIdListAssignment_2_1_1() { return cIdListAssignment_2_1_1; }

		//TypeIdentifier
		public RuleCall getIdListTypeIdentifierParserRuleCall_2_1_1_0() { return cIdListTypeIdentifierParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//":"
		public Keyword getColonKeyword_4() { return cColonKeyword_4; }

		//type=TypeIdentifier
		public Assignment getTypeAssignment_5() { return cTypeAssignment_5; }

		//TypeIdentifier
		public RuleCall getTypeTypeIdentifierParserRuleCall_5_0() { return cTypeTypeIdentifierParserRuleCall_5_0; }
	}

	public class ProcedureDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcedureDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cProcedureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProceduresAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cProceduresProcedureParserRuleCall_1_0 = (RuleCall)cProceduresAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cProceduresAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cProceduresProcedureParserRuleCall_2_1_0 = (RuleCall)cProceduresAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Procedures
		//ProcedureDecl:
		//	"procedure" procedures+=Procedure ("," procedures+=Procedure)* ";";
		public ParserRule getRule() { return rule; }

		//"procedure" procedures+=Procedure ("," procedures+=Procedure)* ";"
		public Group getGroup() { return cGroup; }

		//"procedure"
		public Keyword getProcedureKeyword_0() { return cProcedureKeyword_0; }

		//procedures+=Procedure
		public Assignment getProceduresAssignment_1() { return cProceduresAssignment_1; }

		//Procedure
		public RuleCall getProceduresProcedureParserRuleCall_1_0() { return cProceduresProcedureParserRuleCall_1_0; }

		//("," procedures+=Procedure)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//procedures+=Procedure
		public Assignment getProceduresAssignment_2_1() { return cProceduresAssignment_2_1; }

		//Procedure
		public RuleCall getProceduresProcedureParserRuleCall_2_1_0() { return cProceduresProcedureParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ProcedureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Procedure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cIdList1Assignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_0_0 = (RuleCall)cIdList1Assignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cIdList1Assignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_1_1_0 = (RuleCall)cIdList1Assignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cIdList2Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_0_0 = (RuleCall)cIdList2Assignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cIdList2Assignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_1_1_0 = (RuleCall)cIdList2Assignment_5_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Procedure:
		//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//	idList2+=TypeIdentifier)*)? ")";
		public ParserRule getRule() { return rule; }

		//name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//idList2+=TypeIdentifier)*)? ")"
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)?
		public Group getGroup_2() { return cGroup_2; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_0() { return cIdList1Assignment_2_0; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_0_0() { return cIdList1TypeIdentifierParserRuleCall_2_0_0; }

		//("," idList1+=TypeIdentifier)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_1_1() { return cIdList1Assignment_2_1_1; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_1_1_0() { return cIdList1TypeIdentifierParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//(idList2+=TypeIdentifier ("," idList2+=TypeIdentifier)*)?
		public Group getGroup_5() { return cGroup_5; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_0() { return cIdList2Assignment_5_0; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_0_0() { return cIdList2TypeIdentifierParserRuleCall_5_0_0; }

		//("," idList2+=TypeIdentifier)*
		public Group getGroup_5_1() { return cGroup_5_1; }

		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_1_1() { return cIdList2Assignment_5_1_1; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_1_1_0() { return cIdList2TypeIdentifierParserRuleCall_5_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class TaskDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TaskDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTaskKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTasksAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTasksTaskParserRuleCall_1_0 = (RuleCall)cTasksAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cTasksAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTasksTaskParserRuleCall_2_1_0 = (RuleCall)cTasksAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// ==> Tasks
		//TaskDecl:
		//	"task" tasks+=Task ("," tasks+=Task)* ";";
		public ParserRule getRule() { return rule; }

		//"task" tasks+=Task ("," tasks+=Task)* ";"
		public Group getGroup() { return cGroup; }

		//"task"
		public Keyword getTaskKeyword_0() { return cTaskKeyword_0; }

		//tasks+=Task
		public Assignment getTasksAssignment_1() { return cTasksAssignment_1; }

		//Task
		public RuleCall getTasksTaskParserRuleCall_1_0() { return cTasksTaskParserRuleCall_1_0; }

		//("," tasks+=Task)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//tasks+=Task
		public Assignment getTasksAssignment_2_1() { return cTasksAssignment_2_1; }

		//Task
		public RuleCall getTasksTaskParserRuleCall_2_1_0() { return cTasksTaskParserRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class TaskElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Task");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cIdList1Assignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_0_0 = (RuleCall)cIdList1Assignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cIdList1Assignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cIdList1TypeIdentifierParserRuleCall_2_1_1_0 = (RuleCall)cIdList1Assignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cIdList2Assignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_0_0 = (RuleCall)cIdList2Assignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cIdList2Assignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cIdList2TypeIdentifierParserRuleCall_5_1_1_0 = (RuleCall)cIdList2Assignment_5_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Task:
		//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//	idList2+=TypeIdentifier)*)? ")";
		public ParserRule getRule() { return rule; }

		//name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
		//idList2+=TypeIdentifier)*)? ")"
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)?
		public Group getGroup_2() { return cGroup_2; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_0() { return cIdList1Assignment_2_0; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_0_0() { return cIdList1TypeIdentifierParserRuleCall_2_0_0; }

		//("," idList1+=TypeIdentifier)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//idList1+=TypeIdentifier
		public Assignment getIdList1Assignment_2_1_1() { return cIdList1Assignment_2_1_1; }

		//TypeIdentifier
		public RuleCall getIdList1TypeIdentifierParserRuleCall_2_1_1_0() { return cIdList1TypeIdentifierParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//(idList2+=TypeIdentifier ("," idList2+=TypeIdentifier)*)?
		public Group getGroup_5() { return cGroup_5; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_0() { return cIdList2Assignment_5_0; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_0_0() { return cIdList2TypeIdentifierParserRuleCall_5_0_0; }

		//("," idList2+=TypeIdentifier)*
		public Group getGroup_5_1() { return cGroup_5_1; }

		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }

		//idList2+=TypeIdentifier
		public Assignment getIdList2Assignment_5_1_1() { return cIdList2Assignment_5_1_1; }

		//TypeIdentifier
		public RuleCall getIdList2TypeIdentifierParserRuleCall_5_1_1_0() { return cIdList2TypeIdentifierParserRuleCall_5_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class StatementContainerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatementContainer");
		private final Assignment cStatementAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0 = (RuleCall)cStatementAssignment.eContents().get(0);
		
		//StatementContainer:
		//	statement=Statement;
		public ParserRule getRule() { return rule; }

		//statement=Statement
		public Assignment getStatementAssignment() { return cStatementAssignment; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0() { return cStatementStatementParserRuleCall_0; }
	}

	public class StatementContainerInterfaceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatementContainerInterface");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLocalSignalDeclParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAbortParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAbortInstanceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cAbortCaseSingleParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cWeakAbortParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cWeakAbortInstanceParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cAwaitInstanceParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cDoParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cDoWatchingEndParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cEveryDoParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cThenPartParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cElsePartParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cLoopBodyParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cPresentCaseParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cRepeatParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cSuspendParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cTrapParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cTrapHandlerParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		private final RuleCall cLocalVariableParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cExecParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		private final RuleCall cExecCaseParserRuleCall_21 = (RuleCall)cAlternatives.eContents().get(21);
		
		//StatementContainerInterface returns StatementContainer:
		//	LocalSignalDecl | Block | Abort | AbortInstance | AbortCaseSingle | WeakAbort | WeakAbortInstance | AwaitInstance | Do
		//	| DoWatchingEnd | EveryDo | ThenPart | ElsePart | LoopBody | PresentCase | Repeat | Suspend | Trap | TrapHandler |
		//	LocalVariable | Exec | ExecCase;
		public ParserRule getRule() { return rule; }

		//LocalSignalDecl | Block | Abort | AbortInstance | AbortCaseSingle | WeakAbort | WeakAbortInstance | AwaitInstance | Do |
		//DoWatchingEnd | EveryDo | ThenPart | ElsePart | LoopBody | PresentCase | Repeat | Suspend | Trap | TrapHandler |
		//LocalVariable | Exec | ExecCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//LocalSignalDecl
		public RuleCall getLocalSignalDeclParserRuleCall_0() { return cLocalSignalDeclParserRuleCall_0; }

		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }

		//Abort
		public RuleCall getAbortParserRuleCall_2() { return cAbortParserRuleCall_2; }

		//AbortInstance
		public RuleCall getAbortInstanceParserRuleCall_3() { return cAbortInstanceParserRuleCall_3; }

		//AbortCaseSingle
		public RuleCall getAbortCaseSingleParserRuleCall_4() { return cAbortCaseSingleParserRuleCall_4; }

		//WeakAbort
		public RuleCall getWeakAbortParserRuleCall_5() { return cWeakAbortParserRuleCall_5; }

		//WeakAbortInstance
		public RuleCall getWeakAbortInstanceParserRuleCall_6() { return cWeakAbortInstanceParserRuleCall_6; }

		//AwaitInstance
		public RuleCall getAwaitInstanceParserRuleCall_7() { return cAwaitInstanceParserRuleCall_7; }

		//Do
		public RuleCall getDoParserRuleCall_8() { return cDoParserRuleCall_8; }

		//DoWatchingEnd
		public RuleCall getDoWatchingEndParserRuleCall_9() { return cDoWatchingEndParserRuleCall_9; }

		//EveryDo
		public RuleCall getEveryDoParserRuleCall_10() { return cEveryDoParserRuleCall_10; }

		//ThenPart
		public RuleCall getThenPartParserRuleCall_11() { return cThenPartParserRuleCall_11; }

		//ElsePart
		public RuleCall getElsePartParserRuleCall_12() { return cElsePartParserRuleCall_12; }

		//LoopBody
		public RuleCall getLoopBodyParserRuleCall_13() { return cLoopBodyParserRuleCall_13; }

		//PresentCase
		public RuleCall getPresentCaseParserRuleCall_14() { return cPresentCaseParserRuleCall_14; }

		//Repeat
		public RuleCall getRepeatParserRuleCall_15() { return cRepeatParserRuleCall_15; }

		//Suspend
		public RuleCall getSuspendParserRuleCall_16() { return cSuspendParserRuleCall_16; }

		//Trap
		public RuleCall getTrapParserRuleCall_17() { return cTrapParserRuleCall_17; }

		//TrapHandler
		public RuleCall getTrapHandlerParserRuleCall_18() { return cTrapHandlerParserRuleCall_18; }

		//LocalVariable
		public RuleCall getLocalVariableParserRuleCall_19() { return cLocalVariableParserRuleCall_19; }

		//Exec
		public RuleCall getExecParserRuleCall_20() { return cExecParserRuleCall_20; }

		//ExecCase
		public RuleCall getExecCaseParserRuleCall_21() { return cExecCaseParserRuleCall_21; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSequenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cParallelListAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cListAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cListSequenceParserRuleCall_1_2_0 = (RuleCall)cListAssignment_1_2.eContents().get(0);
		
		//// ==============================================
		//// ===            B.4 Statements              ===
		//// ==============================================
		//// !-(parallel)
		//Statement:
		//	Sequence ({Parallel.list+=current} "||" list+=Sequence)*;
		public ParserRule getRule() { return rule; }

		//Sequence ({Parallel.list+=current} "||" list+=Sequence)*
		public Group getGroup() { return cGroup; }

		//Sequence
		public RuleCall getSequenceParserRuleCall_0() { return cSequenceParserRuleCall_0; }

		//({Parallel.list+=current} "||" list+=Sequence)*
		public Group getGroup_1() { return cGroup_1; }

		//{Parallel.list+=current}
		public Action getParallelListAction_1_0() { return cParallelListAction_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//list+=Sequence
		public Assignment getListAssignment_1_2() { return cListAssignment_1_2; }

		//Sequence
		public RuleCall getListSequenceParserRuleCall_1_2_0() { return cListSequenceParserRuleCall_1_2_0; }
	}

	public class AtomicStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAbortParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAwaitParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBlockParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cProcCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDoParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cEmitParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cEveryDoParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cExitParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cExecParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cHaltParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cIfTestParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cLocalSignalDeclParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		private final RuleCall cLoopParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cNothingParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cPauseParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cPresentParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		private final RuleCall cRepeatParserRuleCall_17 = (RuleCall)cAlternatives.eContents().get(17);
		private final RuleCall cRunParserRuleCall_18 = (RuleCall)cAlternatives.eContents().get(18);
		private final RuleCall cSuspendParserRuleCall_19 = (RuleCall)cAlternatives.eContents().get(19);
		private final RuleCall cSustainParserRuleCall_20 = (RuleCall)cAlternatives.eContents().get(20);
		private final RuleCall cTrapParserRuleCall_21 = (RuleCall)cAlternatives.eContents().get(21);
		private final RuleCall cLocalVariableParserRuleCall_22 = (RuleCall)cAlternatives.eContents().get(22);
		private final RuleCall cWeakAbortParserRuleCall_23 = (RuleCall)cAlternatives.eContents().get(23);
		
		//// -!
		//AtomicStatement returns Statement:
		//	Abort | Assignment | Await | Block | ProcCall | Do | Emit | EveryDo | Exit | Exec | Halt | IfTest | LocalSignalDecl |
		//	Loop | Nothing | Pause | Present | Repeat | Run | Suspend | Sustain | Trap | LocalVariable | WeakAbort;
		public ParserRule getRule() { return rule; }

		//Abort | Assignment | Await | Block | ProcCall | Do | Emit | EveryDo | Exit | Exec | Halt | IfTest | LocalSignalDecl |
		//Loop | Nothing | Pause | Present | Repeat | Run | Suspend | Sustain | Trap | LocalVariable | WeakAbort
		public Alternatives getAlternatives() { return cAlternatives; }

		//Abort
		public RuleCall getAbortParserRuleCall_0() { return cAbortParserRuleCall_0; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_1() { return cAssignmentParserRuleCall_1; }

		//Await
		public RuleCall getAwaitParserRuleCall_2() { return cAwaitParserRuleCall_2; }

		//Block
		public RuleCall getBlockParserRuleCall_3() { return cBlockParserRuleCall_3; }

		//ProcCall
		public RuleCall getProcCallParserRuleCall_4() { return cProcCallParserRuleCall_4; }

		//Do
		public RuleCall getDoParserRuleCall_5() { return cDoParserRuleCall_5; }

		//Emit
		public RuleCall getEmitParserRuleCall_6() { return cEmitParserRuleCall_6; }

		//EveryDo
		public RuleCall getEveryDoParserRuleCall_7() { return cEveryDoParserRuleCall_7; }

		//Exit
		public RuleCall getExitParserRuleCall_8() { return cExitParserRuleCall_8; }

		//Exec
		public RuleCall getExecParserRuleCall_9() { return cExecParserRuleCall_9; }

		//Halt
		public RuleCall getHaltParserRuleCall_10() { return cHaltParserRuleCall_10; }

		//IfTest
		public RuleCall getIfTestParserRuleCall_11() { return cIfTestParserRuleCall_11; }

		//LocalSignalDecl
		public RuleCall getLocalSignalDeclParserRuleCall_12() { return cLocalSignalDeclParserRuleCall_12; }

		//Loop
		public RuleCall getLoopParserRuleCall_13() { return cLoopParserRuleCall_13; }

		//Nothing
		public RuleCall getNothingParserRuleCall_14() { return cNothingParserRuleCall_14; }

		//Pause
		public RuleCall getPauseParserRuleCall_15() { return cPauseParserRuleCall_15; }

		//Present
		public RuleCall getPresentParserRuleCall_16() { return cPresentParserRuleCall_16; }

		//Repeat
		public RuleCall getRepeatParserRuleCall_17() { return cRepeatParserRuleCall_17; }

		//Run
		public RuleCall getRunParserRuleCall_18() { return cRunParserRuleCall_18; }

		//Suspend
		public RuleCall getSuspendParserRuleCall_19() { return cSuspendParserRuleCall_19; }

		//Sustain
		public RuleCall getSustainParserRuleCall_20() { return cSustainParserRuleCall_20; }

		//Trap
		public RuleCall getTrapParserRuleCall_21() { return cTrapParserRuleCall_21; }

		//LocalVariable
		public RuleCall getLocalVariableParserRuleCall_22() { return cLocalVariableParserRuleCall_22; }

		//WeakAbort
		public RuleCall getWeakAbortParserRuleCall_23() { return cWeakAbortParserRuleCall_23; }
	}

	public class SequenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sequence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtomicStatementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSequenceListAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cListAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cListAtomicStatementParserRuleCall_1_2_0 = (RuleCall)cListAssignment_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// --> B.4.1 Control Flow Operators <--	
		//// !-(sequence)
		//Sequence returns Statement:
		//	AtomicStatement ({Sequence.list+=current} ";" list+=AtomicStatement)* ";"?;
		public ParserRule getRule() { return rule; }

		//AtomicStatement ({Sequence.list+=current} ";" list+=AtomicStatement)* ";"?
		public Group getGroup() { return cGroup; }

		//AtomicStatement
		public RuleCall getAtomicStatementParserRuleCall_0() { return cAtomicStatementParserRuleCall_0; }

		//({Sequence.list+=current} ";" list+=AtomicStatement)*
		public Group getGroup_1() { return cGroup_1; }

		//{Sequence.list+=current}
		public Action getSequenceListAction_1_0() { return cSequenceListAction_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }

		//list+=AtomicStatement
		public Assignment getListAssignment_1_2() { return cListAssignment_1_2; }

		//AtomicStatement
		public RuleCall getListAtomicStatementParserRuleCall_1_2_0() { return cListAtomicStatementParserRuleCall_1_2_0; }

		//";"?
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// -!
		//Block:
		//	"[" statement=Statement "]";
		public ParserRule getRule() { return rule; }

		//"[" statement=Statement "]"
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVarIVariableCrossReference_0_0 = (CrossReference)cVarAssignment_0.eContents().get(0);
		private final RuleCall cVarIVariableIDTerminalRuleCall_0_0_1 = (RuleCall)cVarIVariableCrossReference_0_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprExpressionParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//// Assignment
		//// !-(assign) -------------------------------------
		//Assignment:
		//	var=[kexpressions::IVariable] ":=" expr=Expression;
		public ParserRule getRule() { return rule; }

		//var=[kexpressions::IVariable] ":=" expr=Expression
		public Group getGroup() { return cGroup; }

		//var=[kexpressions::IVariable]
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }

		//[kexpressions::IVariable]
		public CrossReference getVarIVariableCrossReference_0_0() { return cVarIVariableCrossReference_0_0; }

		//ID
		public RuleCall getVarIVariableIDTerminalRuleCall_0_0_1() { return cVarIVariableIDTerminalRuleCall_0_0_1; }

		//":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }

		//expr=Expression
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_0() { return cExprExpressionParserRuleCall_2_0; }
	}

	public class AbortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Abort");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAbortKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cWhenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyAbortBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//// -!
		//// !-(abort) --> B.4.2 abort: Strong Preemption
		//// -------------------------------------
		//Abort:
		//	"abort" statement=Statement "when" body=AbortBody;
		public ParserRule getRule() { return rule; }

		//"abort" statement=Statement "when" body=AbortBody
		public Group getGroup() { return cGroup; }

		//"abort"
		public Keyword getAbortKeyword_0() { return cAbortKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"when"
		public Keyword getWhenKeyword_2() { return cWhenKeyword_2; }

		//body=AbortBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//AbortBody
		public RuleCall getBodyAbortBodyParserRuleCall_3_0() { return cBodyAbortBodyParserRuleCall_3_0; }
	}

	public class AbortBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbortBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAbortInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAbortCaseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbortBody:
		//	AbortInstance | AbortCase;
		public ParserRule getRule() { return rule; }

		//AbortInstance | AbortCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//AbortInstance
		public RuleCall getAbortInstanceParserRuleCall_0() { return cAbortInstanceParserRuleCall_0; }

		//AbortCase
		public RuleCall getAbortCaseParserRuleCall_1() { return cAbortCaseParserRuleCall_1; }
	}

	public class AbortInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbortInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDelayAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDelayDelayExprParserRuleCall_0_0 = (RuleCall)cDelayAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cDoKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_1_0 = (RuleCall)cStatementAssignment_1_1.eContents().get(0);
		private final Keyword cEndKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cOptEndAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final Keyword cOptEndAbortKeyword_1_3_0 = (Keyword)cOptEndAssignment_1_3.eContents().get(0);
		
		//AbortInstance:
		//	delay=DelayExpr ("do" statement=Statement "end" optEnd="abort"?)?;
		public ParserRule getRule() { return rule; }

		//delay=DelayExpr ("do" statement=Statement "end" optEnd="abort"?)?
		public Group getGroup() { return cGroup; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_0() { return cDelayAssignment_0; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_0_0() { return cDelayDelayExprParserRuleCall_0_0; }

		//("do" statement=Statement "end" optEnd="abort"?)?
		public Group getGroup_1() { return cGroup_1; }

		//"do"
		public Keyword getDoKeyword_1_0() { return cDoKeyword_1_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1_1() { return cStatementAssignment_1_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_1_0() { return cStatementStatementParserRuleCall_1_1_0; }

		//"end"
		public Keyword getEndKeyword_1_2() { return cEndKeyword_1_2; }

		//optEnd="abort"?
		public Assignment getOptEndAssignment_1_3() { return cOptEndAssignment_1_3; }

		//"abort"
		public Keyword getOptEndAbortKeyword_1_3_0() { return cOptEndAbortKeyword_1_3_0; }
	}

	public class AbortCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbortCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCasesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_0_0 = (RuleCall)cCasesAssignment_0.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOptEndAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cOptEndAbortKeyword_3_0 = (Keyword)cOptEndAssignment_3.eContents().get(0);
		
		//AbortCase:
		//	cases+=AbortCaseSingle cases+=AbortCaseSingle* "end" optEnd="abort"?;
		public ParserRule getRule() { return rule; }

		//cases+=AbortCaseSingle cases+=AbortCaseSingle* "end" optEnd="abort"?
		public Group getGroup() { return cGroup; }

		//cases+=AbortCaseSingle
		public Assignment getCasesAssignment_0() { return cCasesAssignment_0; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_0_0() { return cCasesAbortCaseSingleParserRuleCall_0_0; }

		//cases+=AbortCaseSingle*
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_1_0() { return cCasesAbortCaseSingleParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }

		//optEnd="abort"?
		public Assignment getOptEndAssignment_3() { return cOptEndAssignment_3; }

		//"abort"
		public Keyword getOptEndAbortKeyword_3_0() { return cOptEndAbortKeyword_3_0; }
	}

	public class AbortCaseSingleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbortCaseSingle");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cDoKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStatementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_2_1_0 = (RuleCall)cStatementAssignment_2_1.eContents().get(0);
		
		//AbortCaseSingle:
		//	"case" delay=DelayExpr ("do" statement=Statement)?;
		public ParserRule getRule() { return rule; }

		//"case" delay=DelayExpr ("do" statement=Statement)?
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//("do" statement=Statement)?
		public Group getGroup_2() { return cGroup_2; }

		//"do"
		public Keyword getDoKeyword_2_0() { return cDoKeyword_2_0; }

		//statement=Statement
		public Assignment getStatementAssignment_2_1() { return cStatementAssignment_2_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_1_0() { return cStatementStatementParserRuleCall_2_1_0; }
	}

	public class WeakAbortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WeakAbort");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWeakKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAbortKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Keyword cWhenKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyWeakAbortBodyParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		
		//// -!
		//// --> B.4.25 weak abort: Weak Preemption
		//// -------------------------------------
		//WeakAbort returns Abort:
		//	{WeakAbort} "weak" "abort" statement=Statement "when" body=WeakAbortBody;
		public ParserRule getRule() { return rule; }

		//{WeakAbort} "weak" "abort" statement=Statement "when" body=WeakAbortBody
		public Group getGroup() { return cGroup; }

		//{WeakAbort}
		public Action getWeakAbortAction_0() { return cWeakAbortAction_0; }

		//"weak"
		public Keyword getWeakKeyword_1() { return cWeakKeyword_1; }

		//"abort"
		public Keyword getAbortKeyword_2() { return cAbortKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//"when"
		public Keyword getWhenKeyword_4() { return cWhenKeyword_4; }

		//body=WeakAbortBody
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }

		//WeakAbortBody
		public RuleCall getBodyWeakAbortBodyParserRuleCall_5_0() { return cBodyWeakAbortBodyParserRuleCall_5_0; }
	}

	public class WeakAbortBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WeakAbortBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cWeakAbortInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWeakAbortCaseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//WeakAbortBody:
		//	WeakAbortInstance | WeakAbortCase;
		public ParserRule getRule() { return rule; }

		//WeakAbortInstance | WeakAbortCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//WeakAbortInstance
		public RuleCall getWeakAbortInstanceParserRuleCall_0() { return cWeakAbortInstanceParserRuleCall_0; }

		//WeakAbortCase
		public RuleCall getWeakAbortCaseParserRuleCall_1() { return cWeakAbortCaseParserRuleCall_1; }
	}

	public class WeakAbortEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WeakAbortEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortEndAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOptEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOptEndWeakAbortEndAltParserRuleCall_2_0 = (RuleCall)cOptEndAssignment_2.eContents().get(0);
		
		//WeakAbortEnd:
		//	{WeakAbortEnd} "end" optEnd=WeakAbortEndAlt?;
		public ParserRule getRule() { return rule; }

		//{WeakAbortEnd} "end" optEnd=WeakAbortEndAlt?
		public Group getGroup() { return cGroup; }

		//{WeakAbortEnd}
		public Action getWeakAbortEndAction_0() { return cWeakAbortEndAction_0; }

		//"end"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//optEnd=WeakAbortEndAlt?
		public Assignment getOptEndAssignment_2() { return cOptEndAssignment_2; }

		//WeakAbortEndAlt
		public RuleCall getOptEndWeakAbortEndAltParserRuleCall_2_0() { return cOptEndWeakAbortEndAltParserRuleCall_2_0; }
	}

	public class WeakAbortEndAltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WeakAbortEndAlt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEndAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cEndWeakKeyword_0_0 = (Keyword)cEndAssignment_0.eContents().get(0);
		private final Assignment cEndAAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cEndAAbortKeyword_1_0 = (Keyword)cEndAAssignment_1.eContents().get(0);
		
		//WeakAbortEndAlt:
		//	end="weak"? endA="abort";
		public ParserRule getRule() { return rule; }

		//end="weak"? endA="abort"
		public Group getGroup() { return cGroup; }

		//end="weak"?
		public Assignment getEndAssignment_0() { return cEndAssignment_0; }

		//"weak"
		public Keyword getEndWeakKeyword_0_0() { return cEndWeakKeyword_0_0; }

		//endA="abort"
		public Assignment getEndAAssignment_1() { return cEndAAssignment_1; }

		//"abort"
		public Keyword getEndAAbortKeyword_1_0() { return cEndAAbortKeyword_1_0; }
	}

	public class WeakAbortInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WeakAbortInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortInstanceAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cDoKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStatementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_2_1_0 = (RuleCall)cStatementAssignment_2_1.eContents().get(0);
		private final Assignment cEndAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cEndWeakAbortEndParserRuleCall_2_2_0 = (RuleCall)cEndAssignment_2_2.eContents().get(0);
		
		//WeakAbortInstance returns AbortInstance:
		//	{WeakAbortInstance} delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?;
		public ParserRule getRule() { return rule; }

		//{WeakAbortInstance} delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?
		public Group getGroup() { return cGroup; }

		//{WeakAbortInstance}
		public Action getWeakAbortInstanceAction_0() { return cWeakAbortInstanceAction_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//("do" statement=Statement end=WeakAbortEnd)?
		public Group getGroup_2() { return cGroup_2; }

		//"do"
		public Keyword getDoKeyword_2_0() { return cDoKeyword_2_0; }

		//statement=Statement
		public Assignment getStatementAssignment_2_1() { return cStatementAssignment_2_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_1_0() { return cStatementStatementParserRuleCall_2_1_0; }

		//end=WeakAbortEnd
		public Assignment getEndAssignment_2_2() { return cEndAssignment_2_2; }

		//WeakAbortEnd
		public RuleCall getEndWeakAbortEndParserRuleCall_2_2_0() { return cEndWeakAbortEndParserRuleCall_2_2_0; }
	}

	public class WeakAbortCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WeakAbortCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWeakAbortCaseAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		private final Assignment cCasesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_2_0 = (RuleCall)cCasesAssignment_2.eContents().get(0);
		private final Assignment cEndAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEndWeakAbortEndParserRuleCall_3_0 = (RuleCall)cEndAssignment_3.eContents().get(0);
		
		//WeakAbortCase returns AbortCase:
		//	{WeakAbortCase} cases+=AbortCaseSingle cases+=AbortCaseSingle* end=WeakAbortEnd;
		public ParserRule getRule() { return rule; }

		//{WeakAbortCase} cases+=AbortCaseSingle cases+=AbortCaseSingle* end=WeakAbortEnd
		public Group getGroup() { return cGroup; }

		//{WeakAbortCase}
		public Action getWeakAbortCaseAction_0() { return cWeakAbortCaseAction_0; }

		//cases+=AbortCaseSingle
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_1_0() { return cCasesAbortCaseSingleParserRuleCall_1_0; }

		//cases+=AbortCaseSingle*
		public Assignment getCasesAssignment_2() { return cCasesAssignment_2; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_2_0() { return cCasesAbortCaseSingleParserRuleCall_2_0; }

		//end=WeakAbortEnd
		public Assignment getEndAssignment_3() { return cEndAssignment_3; }

		//WeakAbortEnd
		public RuleCall getEndWeakAbortEndParserRuleCall_3_0() { return cEndWeakAbortEndParserRuleCall_3_0; }
	}

	public class AwaitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Await");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAwaitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyAwaitBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//// --> B.4.3 await: Strong Preemption
		//// !-(await) -------------------------------------
		//Await:
		//	"await" body=AwaitBody;
		public ParserRule getRule() { return rule; }

		//"await" body=AwaitBody
		public Group getGroup() { return cGroup; }

		//"await"
		public Keyword getAwaitKeyword_0() { return cAwaitKeyword_0; }

		//body=AwaitBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//AwaitBody
		public RuleCall getBodyAwaitBodyParserRuleCall_1_0() { return cBodyAwaitBodyParserRuleCall_1_0; }
	}

	public class AwaitBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AwaitBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAwaitInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAwaitCaseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AwaitBody:
		//	AwaitInstance | AwaitCase;
		public ParserRule getRule() { return rule; }

		//AwaitInstance | AwaitCase
		public Alternatives getAlternatives() { return cAlternatives; }

		//AwaitInstance
		public RuleCall getAwaitInstanceParserRuleCall_0() { return cAwaitInstanceParserRuleCall_0; }

		//AwaitCase
		public RuleCall getAwaitCaseParserRuleCall_1() { return cAwaitCaseParserRuleCall_1; }
	}

	public class AwaitInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AwaitInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDelayAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDelayDelayExprParserRuleCall_0_0 = (RuleCall)cDelayAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cDoKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_1_0 = (RuleCall)cStatementAssignment_1_1.eContents().get(0);
		private final Assignment cEndAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cEndAwaitEndParserRuleCall_1_2_0 = (RuleCall)cEndAssignment_1_2.eContents().get(0);
		
		//AwaitInstance:
		//	delay=DelayExpr ("do" statement=Statement end=AwaitEnd)?;
		public ParserRule getRule() { return rule; }

		//delay=DelayExpr ("do" statement=Statement end=AwaitEnd)?
		public Group getGroup() { return cGroup; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_0() { return cDelayAssignment_0; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_0_0() { return cDelayDelayExprParserRuleCall_0_0; }

		//("do" statement=Statement end=AwaitEnd)?
		public Group getGroup_1() { return cGroup_1; }

		//"do"
		public Keyword getDoKeyword_1_0() { return cDoKeyword_1_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1_1() { return cStatementAssignment_1_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_1_0() { return cStatementStatementParserRuleCall_1_1_0; }

		//end=AwaitEnd
		public Assignment getEndAssignment_1_2() { return cEndAssignment_1_2; }

		//AwaitEnd
		public RuleCall getEndAwaitEndParserRuleCall_1_2_0() { return cEndAwaitEndParserRuleCall_1_2_0; }
	}

	public class AwaitCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AwaitCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCasesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_0_0 = (RuleCall)cCasesAssignment_0.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesAbortCaseSingleParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndAwaitEndParserRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//AwaitCase:
		//	cases+=AbortCaseSingle cases+=AbortCaseSingle* end=AwaitEnd;
		public ParserRule getRule() { return rule; }

		//cases+=AbortCaseSingle cases+=AbortCaseSingle* end=AwaitEnd
		public Group getGroup() { return cGroup; }

		//cases+=AbortCaseSingle
		public Assignment getCasesAssignment_0() { return cCasesAssignment_0; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_0_0() { return cCasesAbortCaseSingleParserRuleCall_0_0; }

		//cases+=AbortCaseSingle*
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//AbortCaseSingle
		public RuleCall getCasesAbortCaseSingleParserRuleCall_1_0() { return cCasesAbortCaseSingleParserRuleCall_1_0; }

		//end=AwaitEnd
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }

		//AwaitEnd
		public RuleCall getEndAwaitEndParserRuleCall_2_0() { return cEndAwaitEndParserRuleCall_2_0; }
	}

	public class AwaitEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AwaitEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEndKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cAwaitKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//AwaitEnd:
		//	"end" "await"?;
		public ParserRule getRule() { return rule; }

		//"end" "await"?
		public Group getGroup() { return cGroup; }

		//"end"
		public Keyword getEndKeyword_0() { return cEndKeyword_0; }

		//"await"?
		public Keyword getAwaitKeyword_1() { return cAwaitKeyword_1; }
	}

	public class ProcCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCallKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cProcAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cProcProcedureCrossReference_1_0 = (CrossReference)cProcAssignment_1.eContents().get(0);
		private final RuleCall cProcProcedureIDTerminalRuleCall_1_0_1 = (RuleCall)cProcProcedureCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cVarListAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final CrossReference cVarListIVariableCrossReference_3_0_0 = (CrossReference)cVarListAssignment_3_0.eContents().get(0);
		private final RuleCall cVarListIVariableIDTerminalRuleCall_3_0_0_1 = (RuleCall)cVarListIVariableCrossReference_3_0_0.eContents().get(1);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cVarListAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final CrossReference cVarListIVariableCrossReference_3_1_1_0 = (CrossReference)cVarListAssignment_3_1_1.eContents().get(0);
		private final RuleCall cVarListIVariableIDTerminalRuleCall_3_1_1_0_1 = (RuleCall)cVarListIVariableCrossReference_3_1_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Assignment cKexpressionsAssignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final RuleCall cKexpressionsExpressionParserRuleCall_6_0_0 = (RuleCall)cKexpressionsAssignment_6_0.eContents().get(0);
		private final Group cGroup_6_1 = (Group)cGroup_6.eContents().get(1);
		private final Keyword cCommaKeyword_6_1_0 = (Keyword)cGroup_6_1.eContents().get(0);
		private final Assignment cKexpressionsAssignment_6_1_1 = (Assignment)cGroup_6_1.eContents().get(1);
		private final RuleCall cKexpressionsExpressionParserRuleCall_6_1_1_0 = (RuleCall)cKexpressionsAssignment_6_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// -!
		//// --> B.4.4 call: Procedure Call
		//// -------------------------------------
		//ProcCall:
		//	"call" proc=[Procedure] "(" (varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)? ")" "("
		//	(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
		public ParserRule getRule() { return rule; }

		//"call" proc=[Procedure] "(" (varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)? ")" "("
		//(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//"call"
		public Keyword getCallKeyword_0() { return cCallKeyword_0; }

		//proc=[Procedure]
		public Assignment getProcAssignment_1() { return cProcAssignment_1; }

		//[Procedure]
		public CrossReference getProcProcedureCrossReference_1_0() { return cProcProcedureCrossReference_1_0; }

		//ID
		public RuleCall getProcProcedureIDTerminalRuleCall_1_0_1() { return cProcProcedureIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)?
		public Group getGroup_3() { return cGroup_3; }

		//varList+=[kexpressions::IVariable]
		public Assignment getVarListAssignment_3_0() { return cVarListAssignment_3_0; }

		//[kexpressions::IVariable]
		public CrossReference getVarListIVariableCrossReference_3_0_0() { return cVarListIVariableCrossReference_3_0_0; }

		//ID
		public RuleCall getVarListIVariableIDTerminalRuleCall_3_0_0_1() { return cVarListIVariableIDTerminalRuleCall_3_0_0_1; }

		//("," varList+=[kexpressions::IVariable])*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//varList+=[kexpressions::IVariable]
		public Assignment getVarListAssignment_3_1_1() { return cVarListAssignment_3_1_1; }

		//[kexpressions::IVariable]
		public CrossReference getVarListIVariableCrossReference_3_1_1_0() { return cVarListIVariableCrossReference_3_1_1_0; }

		//ID
		public RuleCall getVarListIVariableIDTerminalRuleCall_3_1_1_0_1() { return cVarListIVariableIDTerminalRuleCall_3_1_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_5() { return cLeftParenthesisKeyword_5; }

		//(kexpressions+=Expression ("," kexpressions+=Expression)*)?
		public Group getGroup_6() { return cGroup_6; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_6_0() { return cKexpressionsAssignment_6_0; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_6_0_0() { return cKexpressionsExpressionParserRuleCall_6_0_0; }

		//("," kexpressions+=Expression)*
		public Group getGroup_6_1() { return cGroup_6_1; }

		//","
		public Keyword getCommaKeyword_6_1_0() { return cCommaKeyword_6_1_0; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_6_1_1() { return cKexpressionsAssignment_6_1_1; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_6_1_1_0() { return cKexpressionsExpressionParserRuleCall_6_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}

	public class DoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Do");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cEndAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cEndDoUptoParserRuleCall_2_0_0 = (RuleCall)cEndAssignment_2_0.eContents().get(0);
		private final Assignment cEndAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cEndDoWatchingParserRuleCall_2_1_0 = (RuleCall)cEndAssignment_2_1.eContents().get(0);
		
		//// --> B.4.5 do-upto: Conditional Iteration (deprecated)
		//// --> B.4.6 do-watching: Strong Preemption (deprecated)
		//// !-(doupto) -------------------------------------
		//Do:
		//	"do" statement=Statement (end=DoUpto | end=DoWatching);
		public ParserRule getRule() { return rule; }

		//"do" statement=Statement (end=DoUpto | end=DoWatching)
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//end=DoUpto | end=DoWatching
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//end=DoUpto
		public Assignment getEndAssignment_2_0() { return cEndAssignment_2_0; }

		//DoUpto
		public RuleCall getEndDoUptoParserRuleCall_2_0_0() { return cEndDoUptoParserRuleCall_2_0_0; }

		//end=DoWatching
		public Assignment getEndAssignment_2_1() { return cEndAssignment_2_1; }

		//DoWatching
		public RuleCall getEndDoWatchingParserRuleCall_2_1_0() { return cEndDoWatchingParserRuleCall_2_1_0; }
	}

	public class DoUptoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoUpto");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUptoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprDelayExprParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		
		//DoUpto:
		//	"upto" expr=DelayExpr;
		public ParserRule getRule() { return rule; }

		//"upto" expr=DelayExpr
		public Group getGroup() { return cGroup; }

		//"upto"
		public Keyword getUptoKeyword_0() { return cUptoKeyword_0; }

		//expr=DelayExpr
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//DelayExpr
		public RuleCall getExprDelayExprParserRuleCall_1_0() { return cExprDelayExprParserRuleCall_1_0; }
	}

	public class DoWatchingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWatching");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWatchingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndDoWatchingEndParserRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//DoWatching:
		//	"watching" delay=DelayExpr end=DoWatchingEnd?;
		public ParserRule getRule() { return rule; }

		//"watching" delay=DelayExpr end=DoWatchingEnd?
		public Group getGroup() { return cGroup; }

		//"watching"
		public Keyword getWatchingKeyword_0() { return cWatchingKeyword_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//end=DoWatchingEnd?
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }

		//DoWatchingEnd
		public RuleCall getEndDoWatchingEndParserRuleCall_2_0() { return cEndDoWatchingEndParserRuleCall_2_0; }
	}

	public class DoWatchingEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DoWatchingEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTimeoutKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOptEndAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cOptEndTimeoutKeyword_3_0 = (Keyword)cOptEndAssignment_3.eContents().get(0);
		
		//DoWatchingEnd:
		//	"timeout" statement=Statement "end" optEnd="timeout"?;
		public ParserRule getRule() { return rule; }

		//"timeout" statement=Statement "end" optEnd="timeout"?
		public Group getGroup() { return cGroup; }

		//"timeout"
		public Keyword getTimeoutKeyword_0() { return cTimeoutKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }

		//optEnd="timeout"?
		public Assignment getOptEndAssignment_3() { return cOptEndAssignment_3; }

		//"timeout"
		public Keyword getOptEndTimeoutKeyword_3_0() { return cOptEndTimeoutKeyword_3_0; }
	}

	public class EmitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Emit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEmitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSignalAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cSignalISignalCrossReference_1_0_0 = (CrossReference)cSignalAssignment_1_0.eContents().get(0);
		private final RuleCall cSignalISignalIDTerminalRuleCall_1_0_0_1 = (RuleCall)cSignalISignalCrossReference_1_0_0.eContents().get(1);
		private final Assignment cTickAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTickTickParserRuleCall_1_1_0 = (RuleCall)cTickAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExprAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_2_1_0 = (RuleCall)cExprAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// -!
		//// --> B.4.7 emit: Signal Emission <--
		//// !-(emit)2 -------------------------------------
		//Emit:
		//	"emit" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")")?;
		public ParserRule getRule() { return rule; }

		//"emit" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")")?
		public Group getGroup() { return cGroup; }

		//"emit"
		public Keyword getEmitKeyword_0() { return cEmitKeyword_0; }

		//signal=[kexpressions::ISignal] | tick=Tick
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//signal=[kexpressions::ISignal]
		public Assignment getSignalAssignment_1_0() { return cSignalAssignment_1_0; }

		//[kexpressions::ISignal]
		public CrossReference getSignalISignalCrossReference_1_0_0() { return cSignalISignalCrossReference_1_0_0; }

		//ID
		public RuleCall getSignalISignalIDTerminalRuleCall_1_0_0_1() { return cSignalISignalIDTerminalRuleCall_1_0_0_1; }

		//tick=Tick
		public Assignment getTickAssignment_1_1() { return cTickAssignment_1_1; }

		//Tick
		public RuleCall getTickTickParserRuleCall_1_1_0() { return cTickTickParserRuleCall_1_1_0; }

		//("(" expr=Expression ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//expr=Expression
		public Assignment getExprAssignment_2_1() { return cExprAssignment_2_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_2_1_0() { return cExprExpressionParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class EveryDoElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EveryDo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEveryKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cDelayAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_1_0 = (RuleCall)cDelayAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cOptEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cOptEndEveryKeyword_5_0 = (Keyword)cOptEndAssignment_5.eContents().get(0);
		
		//// -!
		//// --> B.4.8 every-do: Conditional Iteration
		//// !-(every)-------------------------------------
		//EveryDo:
		//	"every" delay=DelayExpr "do" statement=Statement "end" optEnd="every"?;
		public ParserRule getRule() { return rule; }

		//"every" delay=DelayExpr "do" statement=Statement "end" optEnd="every"?
		public Group getGroup() { return cGroup; }

		//"every"
		public Keyword getEveryKeyword_0() { return cEveryKeyword_0; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_1() { return cDelayAssignment_1; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_1_0() { return cDelayDelayExprParserRuleCall_1_0; }

		//"do"
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }

		//optEnd="every"?
		public Assignment getOptEndAssignment_5() { return cOptEndAssignment_5; }

		//"every"
		public Keyword getOptEndEveryKeyword_5_0() { return cOptEndEveryKeyword_5_0; }
	}

	public class ExitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Exit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTrapAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTrapTrapDeclCrossReference_1_0 = (CrossReference)cTrapAssignment_1.eContents().get(0);
		private final RuleCall cTrapTrapDeclIDTerminalRuleCall_1_0_1 = (RuleCall)cTrapTrapDeclCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// -!
		//// --> B.4.10 exit: Trap Exit
		//// !-(exit) -------------------------------------
		//Exit:
		//	"exit" trap=[TrapDecl] ("(" expression=Expression ")")?;
		public ParserRule getRule() { return rule; }

		//"exit" trap=[TrapDecl] ("(" expression=Expression ")")?
		public Group getGroup() { return cGroup; }

		//"exit"
		public Keyword getExitKeyword_0() { return cExitKeyword_0; }

		//trap=[TrapDecl]
		public Assignment getTrapAssignment_1() { return cTrapAssignment_1; }

		//[TrapDecl]
		public CrossReference getTrapTrapDeclCrossReference_1_0() { return cTrapTrapDeclCrossReference_1_0; }

		//ID
		public RuleCall getTrapTrapDeclIDTerminalRuleCall_1_0_1() { return cTrapTrapDeclIDTerminalRuleCall_1_0_1; }

		//("(" expression=Expression ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class HaltElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Halt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHaltAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cHaltKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// -!
		//// --> B.4.11 halt: Wait Forever
		//// !-(halt) -------------------------------------
		//Halt:
		//	{Halt} "halt";
		public ParserRule getRule() { return rule; }

		//{Halt} "halt"
		public Group getGroup() { return cGroup; }

		//{Halt}
		public Action getHaltAction_0() { return cHaltAction_0; }

		//"halt"
		public Keyword getHaltKeyword_1() { return cHaltKeyword_1; }
	}

	public class IfTestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfTest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Assignment cThenPartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cThenPartThenPartParserRuleCall_2_0 = (RuleCall)cThenPartAssignment_2.eContents().get(0);
		private final Assignment cElsifAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElsifElsIfParserRuleCall_3_0 = (RuleCall)cElsifAssignment_3.eContents().get(0);
		private final Assignment cElsePartAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElsePartElsePartParserRuleCall_4_0 = (RuleCall)cElsePartAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOptEndAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cOptEndIfKeyword_6_0 = (Keyword)cOptEndAssignment_6.eContents().get(0);
		
		//// -!
		//// --> B.4.12: if: Conditional for Data
		//// !-(if)-------------------------------------
		//IfTest:
		//	"if" expr=Expression thenPart=ThenPart? elsif+=ElsIf* elsePart=ElsePart? "end" optEnd="if"?;
		public ParserRule getRule() { return rule; }

		//"if" expr=Expression thenPart=ThenPart? elsif+=ElsIf* elsePart=ElsePart? "end" optEnd="if"?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//thenPart=ThenPart?
		public Assignment getThenPartAssignment_2() { return cThenPartAssignment_2; }

		//ThenPart
		public RuleCall getThenPartThenPartParserRuleCall_2_0() { return cThenPartThenPartParserRuleCall_2_0; }

		//elsif+=ElsIf*
		public Assignment getElsifAssignment_3() { return cElsifAssignment_3; }

		//ElsIf
		public RuleCall getElsifElsIfParserRuleCall_3_0() { return cElsifElsIfParserRuleCall_3_0; }

		//elsePart=ElsePart?
		public Assignment getElsePartAssignment_4() { return cElsePartAssignment_4; }

		//ElsePart
		public RuleCall getElsePartElsePartParserRuleCall_4_0() { return cElsePartElsePartParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//optEnd="if"?
		public Assignment getOptEndAssignment_6() { return cOptEndAssignment_6; }

		//"if"
		public Keyword getOptEndIfKeyword_6_0() { return cOptEndIfKeyword_6_0; }
	}

	public class ElsIfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElsIf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElsifKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Assignment cThenPartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cThenPartThenPartParserRuleCall_2_0 = (RuleCall)cThenPartAssignment_2.eContents().get(0);
		
		//ElsIf:
		//	"elsif" expr=Expression thenPart=ThenPart?;
		public ParserRule getRule() { return rule; }

		//"elsif" expr=Expression thenPart=ThenPart?
		public Group getGroup() { return cGroup; }

		//"elsif"
		public Keyword getElsifKeyword_0() { return cElsifKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//thenPart=ThenPart?
		public Assignment getThenPartAssignment_2() { return cThenPartAssignment_2; }

		//ThenPart
		public RuleCall getThenPartThenPartParserRuleCall_2_0() { return cThenPartThenPartParserRuleCall_2_0; }
	}

	public class ThenPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ThenPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cThenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		
		//ThenPart:
		//	"then" statement=Statement;
		public ParserRule getRule() { return rule; }

		//"then" statement=Statement
		public Group getGroup() { return cGroup; }

		//"then"
		public Keyword getThenKeyword_0() { return cThenKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }
	}

	public class ElsePartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ElsePart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		
		//ElsePart:
		//	"else" statement=Statement;
		public ParserRule getRule() { return rule; }

		//"else" statement=Statement
		public Group getGroup() { return cGroup; }

		//"else"
		public Keyword getElseKeyword_0() { return cElseKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }
	}

	public class LoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Loop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLoopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyLoopBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cEnd1Assignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cEnd1EndLoopParserRuleCall_2_0_0 = (RuleCall)cEnd1Assignment_2_0.eContents().get(0);
		private final Assignment cEndAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cEndLoopEachParserRuleCall_2_1_0 = (RuleCall)cEndAssignment_2_1.eContents().get(0);
		
		//// -!
		//// --> B.4.13 loop: Infinite Loop
		//// --> B.4.14 loop-each: Condition Iteration
		//// !-(loop)-------------------------------------
		//Loop:
		//	"loop" body=LoopBody (end1=EndLoop | end=LoopEach);
		public ParserRule getRule() { return rule; }

		//"loop" body=LoopBody (end1=EndLoop | end=LoopEach)
		public Group getGroup() { return cGroup; }

		//"loop"
		public Keyword getLoopKeyword_0() { return cLoopKeyword_0; }

		//body=LoopBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//LoopBody
		public RuleCall getBodyLoopBodyParserRuleCall_1_0() { return cBodyLoopBodyParserRuleCall_1_0; }

		//end1=EndLoop | end=LoopEach
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//end1=EndLoop
		public Assignment getEnd1Assignment_2_0() { return cEnd1Assignment_2_0; }

		//EndLoop
		public RuleCall getEnd1EndLoopParserRuleCall_2_0_0() { return cEnd1EndLoopParserRuleCall_2_0_0; }

		//end=LoopEach
		public Assignment getEndAssignment_2_1() { return cEndAssignment_2_1; }

		//LoopEach
		public RuleCall getEndLoopEachParserRuleCall_2_1_0() { return cEndLoopEachParserRuleCall_2_1_0; }
	}

	public class EndLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EndLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEndLoopAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndOptAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cEndOptLoopKeyword_2_0 = (Keyword)cEndOptAssignment_2.eContents().get(0);
		
		//EndLoop:
		//	{EndLoop} "end" endOpt="loop"?;
		public ParserRule getRule() { return rule; }

		//{EndLoop} "end" endOpt="loop"?
		public Group getGroup() { return cGroup; }

		//{EndLoop}
		public Action getEndLoopAction_0() { return cEndLoopAction_0; }

		//"end"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//endOpt="loop"?
		public Assignment getEndOptAssignment_2() { return cEndOptAssignment_2; }

		//"loop"
		public Keyword getEndOptLoopKeyword_2_0() { return cEndOptLoopKeyword_2_0; }
	}

	public class LoopEachElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LoopEach");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEachKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cLoopDelayParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//LoopEach:
		//	"each" LoopDelay;
		public ParserRule getRule() { return rule; }

		//"each" LoopDelay
		public Group getGroup() { return cGroup; }

		//"each"
		public Keyword getEachKeyword_0() { return cEachKeyword_0; }

		//LoopDelay
		public RuleCall getLoopDelayParserRuleCall_1() { return cLoopDelayParserRuleCall_1; }
	}

	public class LoopDelayElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LoopDelay");
		private final Assignment cDelayAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cDelayDelayExprParserRuleCall_0 = (RuleCall)cDelayAssignment.eContents().get(0);
		
		//LoopDelay:
		//	delay=DelayExpr;
		public ParserRule getRule() { return rule; }

		//delay=DelayExpr
		public Assignment getDelayAssignment() { return cDelayAssignment; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_0() { return cDelayDelayExprParserRuleCall_0; }
	}

	public class LoopBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LoopBody");
		private final Assignment cStatementAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0 = (RuleCall)cStatementAssignment.eContents().get(0);
		
		//LoopBody:
		//	statement=Statement;
		public ParserRule getRule() { return rule; }

		//statement=Statement
		public Assignment getStatementAssignment() { return cStatementAssignment; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0() { return cStatementStatementParserRuleCall_0; }
	}

	public class NothingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Nothing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNothingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cNothingAction_1 = (Action)cGroup.eContents().get(1);
		
		//// -!
		//// --> B.4.15 nothing: No Operation
		//// !-(nothing) -------------------------------------
		//Nothing:
		//	"nothing" {Nothing};
		public ParserRule getRule() { return rule; }

		//"nothing" {Nothing}
		public Group getGroup() { return cGroup; }

		//"nothing"
		public Keyword getNothingKeyword_0() { return cNothingKeyword_0; }

		//{Nothing}
		public Action getNothingAction_1() { return cNothingAction_1; }
	}

	public class PauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Pause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPauseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cPauseAction_1 = (Action)cGroup.eContents().get(1);
		
		//// -!
		//// --> B.4.16 pause: Unit Delay
		//// !-(pause) -------------------------------------
		//Pause:
		//	"pause" {Pause};
		public ParserRule getRule() { return rule; }

		//"pause" {Pause}
		public Group getGroup() { return cGroup; }

		//"pause"
		public Keyword getPauseKeyword_0() { return cPauseKeyword_0; }

		//{Pause}
		public Action getPauseAction_1() { return cPauseAction_1; }
	}

	public class PresentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Present");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPresentKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyPresentBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		private final Assignment cElsePartAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElsePartElsePartParserRuleCall_2_0 = (RuleCall)cElsePartAssignment_2.eContents().get(0);
		private final Keyword cEndKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOptEndAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cOptEndPresentKeyword_4_0 = (Keyword)cOptEndAssignment_4.eContents().get(0);
		
		//// -!
		//// --> B.4.17 present: Conditional for Signals
		//// !-(present) -------------------------------------
		//Present:
		//	"present" body=PresentBody elsePart=ElsePart? "end" optEnd="present"?;
		public ParserRule getRule() { return rule; }

		//"present" body=PresentBody elsePart=ElsePart? "end" optEnd="present"?
		public Group getGroup() { return cGroup; }

		//"present"
		public Keyword getPresentKeyword_0() { return cPresentKeyword_0; }

		//body=PresentBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }

		//PresentBody
		public RuleCall getBodyPresentBodyParserRuleCall_1_0() { return cBodyPresentBodyParserRuleCall_1_0; }

		//elsePart=ElsePart?
		public Assignment getElsePartAssignment_2() { return cElsePartAssignment_2; }

		//ElsePart
		public RuleCall getElsePartElsePartParserRuleCall_2_0() { return cElsePartElsePartParserRuleCall_2_0; }

		//"end"
		public Keyword getEndKeyword_3() { return cEndKeyword_3; }

		//optEnd="present"?
		public Assignment getOptEndAssignment_4() { return cOptEndAssignment_4; }

		//"present"
		public Keyword getOptEndPresentKeyword_4_0() { return cOptEndPresentKeyword_4_0; }
	}

	public class PresentBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PresentBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPresentEventBodyParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPresentCaseListParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PresentBody:
		//	PresentEventBody | PresentCaseList;
		public ParserRule getRule() { return rule; }

		//PresentEventBody | PresentCaseList
		public Alternatives getAlternatives() { return cAlternatives; }

		//PresentEventBody
		public RuleCall getPresentEventBodyParserRuleCall_0() { return cPresentEventBodyParserRuleCall_0; }

		//PresentCaseList
		public RuleCall getPresentCaseListParserRuleCall_1() { return cPresentCaseListParserRuleCall_1; }
	}

	public class PresentEventBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PresentEventBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEventAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEventPresentEventParserRuleCall_0_0 = (RuleCall)cEventAssignment_0.eContents().get(0);
		private final Assignment cThenPartAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cThenPartThenPartParserRuleCall_1_0 = (RuleCall)cThenPartAssignment_1.eContents().get(0);
		
		//PresentEventBody:
		//	event=PresentEvent thenPart=ThenPart?;
		public ParserRule getRule() { return rule; }

		//event=PresentEvent thenPart=ThenPart?
		public Group getGroup() { return cGroup; }

		//event=PresentEvent
		public Assignment getEventAssignment_0() { return cEventAssignment_0; }

		//PresentEvent
		public RuleCall getEventPresentEventParserRuleCall_0_0() { return cEventPresentEventParserRuleCall_0_0; }

		//thenPart=ThenPart?
		public Assignment getThenPartAssignment_1() { return cThenPartAssignment_1; }

		//ThenPart
		public RuleCall getThenPartThenPartParserRuleCall_1_0() { return cThenPartThenPartParserRuleCall_1_0; }
	}

	public class PresentCaseListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PresentCaseList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCasesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCasesPresentCaseParserRuleCall_0_0 = (RuleCall)cCasesAssignment_0.eContents().get(0);
		private final Assignment cCasesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCasesPresentCaseParserRuleCall_1_0 = (RuleCall)cCasesAssignment_1.eContents().get(0);
		
		//PresentCaseList:
		//	cases+=PresentCase cases+=PresentCase*;
		public ParserRule getRule() { return rule; }

		//cases+=PresentCase cases+=PresentCase*
		public Group getGroup() { return cGroup; }

		//cases+=PresentCase
		public Assignment getCasesAssignment_0() { return cCasesAssignment_0; }

		//PresentCase
		public RuleCall getCasesPresentCaseParserRuleCall_0_0() { return cCasesPresentCaseParserRuleCall_0_0; }

		//cases+=PresentCase*
		public Assignment getCasesAssignment_1() { return cCasesAssignment_1; }

		//PresentCase
		public RuleCall getCasesPresentCaseParserRuleCall_1_0() { return cCasesPresentCaseParserRuleCall_1_0; }
	}

	public class PresentCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PresentCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEventAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEventPresentEventParserRuleCall_1_0 = (RuleCall)cEventAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cDoKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStatementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_2_1_0 = (RuleCall)cStatementAssignment_2_1.eContents().get(0);
		
		//PresentCase:
		//	"case" event=PresentEvent ("do" statement=Statement)?;
		public ParserRule getRule() { return rule; }

		//"case" event=PresentEvent ("do" statement=Statement)?
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//event=PresentEvent
		public Assignment getEventAssignment_1() { return cEventAssignment_1; }

		//PresentEvent
		public RuleCall getEventPresentEventParserRuleCall_1_0() { return cEventPresentEventParserRuleCall_1_0; }

		//("do" statement=Statement)?
		public Group getGroup_2() { return cGroup_2; }

		//"do"
		public Keyword getDoKeyword_2_0() { return cDoKeyword_2_0; }

		//statement=Statement
		public Assignment getStatementAssignment_2_1() { return cStatementAssignment_2_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_1_0() { return cStatementStatementParserRuleCall_2_1_0; }
	}

	public class PresentEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PresentEvent");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionSignalExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cFBAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cFBLeftSquareBracketKeyword_1_0_0 = (Keyword)cFBAssignment_1_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionSignalExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionAssignment_1_1.eContents().get(0);
		private final Assignment cEBAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final Keyword cEBRightSquareBracketKeyword_1_2_0 = (Keyword)cEBAssignment_1_2.eContents().get(0);
		private final Assignment cTickAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cTickTickParserRuleCall_2_0 = (RuleCall)cTickAssignment_2.eContents().get(0);
		
		//PresentEvent:
		//	expression=SignalExpression | fB="[" expression=SignalExpression eB="]" | tick=Tick;
		public ParserRule getRule() { return rule; }

		//expression=SignalExpression | fB="[" expression=SignalExpression eB="]" | tick=Tick
		public Alternatives getAlternatives() { return cAlternatives; }

		//expression=SignalExpression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }

		//SignalExpression
		public RuleCall getExpressionSignalExpressionParserRuleCall_0_0() { return cExpressionSignalExpressionParserRuleCall_0_0; }

		//fB="[" expression=SignalExpression eB="]"
		public Group getGroup_1() { return cGroup_1; }

		//fB="["
		public Assignment getFBAssignment_1_0() { return cFBAssignment_1_0; }

		//"["
		public Keyword getFBLeftSquareBracketKeyword_1_0_0() { return cFBLeftSquareBracketKeyword_1_0_0; }

		//expression=SignalExpression
		public Assignment getExpressionAssignment_1_1() { return cExpressionAssignment_1_1; }

		//SignalExpression
		public RuleCall getExpressionSignalExpressionParserRuleCall_1_1_0() { return cExpressionSignalExpressionParserRuleCall_1_1_0; }

		//eB="]"
		public Assignment getEBAssignment_1_2() { return cEBAssignment_1_2; }

		//"]"
		public Keyword getEBRightSquareBracketKeyword_1_2_0() { return cEBRightSquareBracketKeyword_1_2_0; }

		//tick=Tick
		public Assignment getTickAssignment_2() { return cTickAssignment_2; }

		//Tick
		public RuleCall getTickTickParserRuleCall_2_0() { return cTickTickParserRuleCall_2_0; }
	}

	public class RepeatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Repeat");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPositiveAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cPositivePositiveKeyword_0_0 = (Keyword)cPositiveAssignment_0.eContents().get(0);
		private final Keyword cRepeatKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cTimesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOptEndAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cOptEndRepeatKeyword_6_0 = (Keyword)cOptEndAssignment_6.eContents().get(0);
		
		//// -!
		//// --> B.4.18 repeat: Iterate a Fixed Number of Times
		//// -------------------------------------
		//Repeat:
		//	positive?="positive"? "repeat" expression=Expression "times" statement=Statement "end" optEnd="repeat"?;
		public ParserRule getRule() { return rule; }

		//positive?="positive"? "repeat" expression=Expression "times" statement=Statement "end" optEnd="repeat"?
		public Group getGroup() { return cGroup; }

		//positive?="positive"?
		public Assignment getPositiveAssignment_0() { return cPositiveAssignment_0; }

		//"positive"
		public Keyword getPositivePositiveKeyword_0_0() { return cPositivePositiveKeyword_0_0; }

		//"repeat"
		public Keyword getRepeatKeyword_1() { return cRepeatKeyword_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }

		//"times"
		public Keyword getTimesKeyword_3() { return cTimesKeyword_3; }

		//statement=Statement
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_4_0() { return cStatementStatementParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//optEnd="repeat"?
		public Assignment getOptEndAssignment_6() { return cOptEndAssignment_6; }

		//"repeat"
		public Keyword getOptEndRepeatKeyword_6_0() { return cOptEndRepeatKeyword_6_0; }
	}

	public class RunElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Run");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cRunKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cModuleAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cModuleModuleRenamingParserRuleCall_0_1_0 = (RuleCall)cModuleAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cListAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cListRenamingListParserRuleCall_0_2_1_0 = (RuleCall)cListAssignment_0_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_2_2 = (Keyword)cGroup_0_2.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cCopymoduleKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cModuleAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cModuleModuleRenamingParserRuleCall_1_1_0 = (RuleCall)cModuleAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cListAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cListRenamingListParserRuleCall_1_2_1_0 = (RuleCall)cListAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2_2 = (Keyword)cGroup_1_2.eContents().get(2);
		
		//// --> B.4.19 run: Module Instantiation
		//// -------------------------------------
		////deprecated
		//Run:
		//	"run" module=ModuleRenaming ("[" list=RenamingList "]")? | "copymodule" module=ModuleRenaming ("[" list=RenamingList
		//	"]")?;
		public ParserRule getRule() { return rule; }

		//"run" module=ModuleRenaming ("[" list=RenamingList "]")? | "copymodule" module=ModuleRenaming ("[" list=RenamingList
		//"]")?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"run" module=ModuleRenaming ("[" list=RenamingList "]")?
		public Group getGroup_0() { return cGroup_0; }

		//"run"
		public Keyword getRunKeyword_0_0() { return cRunKeyword_0_0; }

		//module=ModuleRenaming
		public Assignment getModuleAssignment_0_1() { return cModuleAssignment_0_1; }

		//ModuleRenaming
		public RuleCall getModuleModuleRenamingParserRuleCall_0_1_0() { return cModuleModuleRenamingParserRuleCall_0_1_0; }

		//("[" list=RenamingList "]")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0_2_0() { return cLeftSquareBracketKeyword_0_2_0; }

		//list=RenamingList
		public Assignment getListAssignment_0_2_1() { return cListAssignment_0_2_1; }

		//RenamingList
		public RuleCall getListRenamingListParserRuleCall_0_2_1_0() { return cListRenamingListParserRuleCall_0_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_0_2_2() { return cRightSquareBracketKeyword_0_2_2; }

		//"copymodule" module=ModuleRenaming ("[" list=RenamingList "]")?
		public Group getGroup_1() { return cGroup_1; }

		//"copymodule"
		public Keyword getCopymoduleKeyword_1_0() { return cCopymoduleKeyword_1_0; }

		//module=ModuleRenaming
		public Assignment getModuleAssignment_1_1() { return cModuleAssignment_1_1; }

		//ModuleRenaming
		public RuleCall getModuleModuleRenamingParserRuleCall_1_1_0() { return cModuleModuleRenamingParserRuleCall_1_1_0; }

		//("[" list=RenamingList "]")?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_2_0() { return cLeftSquareBracketKeyword_1_2_0; }

		//list=RenamingList
		public Assignment getListAssignment_1_2_1() { return cListAssignment_1_2_1; }

		//RenamingList
		public RuleCall getListRenamingListParserRuleCall_1_2_1_0() { return cListRenamingListParserRuleCall_1_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2_2() { return cRightSquareBracketKeyword_1_2_2; }
	}

	public class ModuleRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModuleRenaming");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cModuleAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final CrossReference cModuleModuleCrossReference_0_0 = (CrossReference)cModuleAssignment_0.eContents().get(0);
		private final RuleCall cModuleModuleIDTerminalRuleCall_0_0_1 = (RuleCall)cModuleModuleCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cNewNameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cNewNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNewNameAssignment_1_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cModuleAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cModuleModuleCrossReference_1_2_0 = (CrossReference)cModuleAssignment_1_2.eContents().get(0);
		private final RuleCall cModuleModuleIDTerminalRuleCall_1_2_0_1 = (RuleCall)cModuleModuleCrossReference_1_2_0.eContents().get(1);
		
		//// Renamings
		//// -------------------------------------
		//ModuleRenaming:
		//	module=[Module] | newName=ID "/" module=[Module];
		public ParserRule getRule() { return rule; }

		//module=[Module] | newName=ID "/" module=[Module]
		public Alternatives getAlternatives() { return cAlternatives; }

		//module=[Module]
		public Assignment getModuleAssignment_0() { return cModuleAssignment_0; }

		//[Module]
		public CrossReference getModuleModuleCrossReference_0_0() { return cModuleModuleCrossReference_0_0; }

		//ID
		public RuleCall getModuleModuleIDTerminalRuleCall_0_0_1() { return cModuleModuleIDTerminalRuleCall_0_0_1; }

		//newName=ID "/" module=[Module]
		public Group getGroup_1() { return cGroup_1; }

		//newName=ID
		public Assignment getNewNameAssignment_1_0() { return cNewNameAssignment_1_0; }

		//ID
		public RuleCall getNewNameIDTerminalRuleCall_1_0_0() { return cNewNameIDTerminalRuleCall_1_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }

		//module=[Module]
		public Assignment getModuleAssignment_1_2() { return cModuleAssignment_1_2; }

		//[Module]
		public CrossReference getModuleModuleCrossReference_1_2_0() { return cModuleModuleCrossReference_1_2_0; }

		//ID
		public RuleCall getModuleModuleIDTerminalRuleCall_1_2_0_1() { return cModuleModuleIDTerminalRuleCall_1_2_0_1; }
	}

	public class RenamingListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RenamingList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cListAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cListRenamingParserRuleCall_0_0 = (RuleCall)cListAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cListAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cListRenamingParserRuleCall_1_1_0 = (RuleCall)cListAssignment_1_1.eContents().get(0);
		
		//RenamingList:
		//	list+=Renaming (";" list+=Renaming)*;
		public ParserRule getRule() { return rule; }

		//list+=Renaming (";" list+=Renaming)*
		public Group getGroup() { return cGroup; }

		//list+=Renaming
		public Assignment getListAssignment_0() { return cListAssignment_0; }

		//Renaming
		public RuleCall getListRenamingParserRuleCall_0_0() { return cListRenamingParserRuleCall_0_0; }

		//(";" list+=Renaming)*
		public Group getGroup_1() { return cGroup_1; }

		//";"
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }

		//list+=Renaming
		public Assignment getListAssignment_1_1() { return cListAssignment_1_1; }

		//Renaming
		public RuleCall getListRenamingParserRuleCall_1_1_0() { return cListRenamingParserRuleCall_1_1_0; }
	}

	public class RenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Renaming");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cRenamingsAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cRenamingsTypeRenamingParserRuleCall_0_1_0 = (RuleCall)cRenamingsAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cRenamingsTypeRenamingParserRuleCall_0_2_1_0 = (RuleCall)cRenamingsAssignment_0_2_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstantKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRenamingsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRenamingsConstantRenamingParserRuleCall_1_1_0 = (RuleCall)cRenamingsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cCommaKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cRenamingsConstantRenamingParserRuleCall_1_2_1_0 = (RuleCall)cRenamingsAssignment_1_2_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cFunctionKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cRenamingsFunctionRenamingParserRuleCall_2_1_0 = (RuleCall)cRenamingsAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cRenamingsFunctionRenamingParserRuleCall_2_2_1_0 = (RuleCall)cRenamingsAssignment_2_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cProcedureKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRenamingsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRenamingsProcedureRenamingParserRuleCall_3_1_0 = (RuleCall)cRenamingsAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cRenamingsProcedureRenamingParserRuleCall_3_2_1_0 = (RuleCall)cRenamingsAssignment_3_2_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cTaskKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cRenamingsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRenamingsTaskRenamingParserRuleCall_4_1_0 = (RuleCall)cRenamingsAssignment_4_1.eContents().get(0);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Keyword cCommaKeyword_4_2_0 = (Keyword)cGroup_4_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final RuleCall cRenamingsTaskRenamingParserRuleCall_4_2_1_0 = (RuleCall)cRenamingsAssignment_4_2_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cSignalKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cRenamingsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cRenamingsSignalRenamingParserRuleCall_5_1_0 = (RuleCall)cRenamingsAssignment_5_1.eContents().get(0);
		private final Group cGroup_5_2 = (Group)cGroup_5.eContents().get(2);
		private final Keyword cCommaKeyword_5_2_0 = (Keyword)cGroup_5_2.eContents().get(0);
		private final Assignment cRenamingsAssignment_5_2_1 = (Assignment)cGroup_5_2.eContents().get(1);
		private final RuleCall cRenamingsSignalRenamingParserRuleCall_5_2_1_0 = (RuleCall)cRenamingsAssignment_5_2_1.eContents().get(0);
		
		//Renaming:
		//	"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)* | "constant" renamings+=ConstantRenaming (","
		//	renamings+=ConstantRenaming)* | "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)* |
		//	"procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)* | "task" renamings+=TaskRenaming (","
		//	renamings+=TaskRenaming)* | "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*;
		public ParserRule getRule() { return rule; }

		//"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)* | "constant" renamings+=ConstantRenaming (","
		//renamings+=ConstantRenaming)* | "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)* | "procedure"
		//renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)* | "task" renamings+=TaskRenaming (","
		//renamings+=TaskRenaming)* | "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)*
		public Group getGroup_0() { return cGroup_0; }

		//"type"
		public Keyword getTypeKeyword_0_0() { return cTypeKeyword_0_0; }

		//renamings+=TypeRenaming
		public Assignment getRenamingsAssignment_0_1() { return cRenamingsAssignment_0_1; }

		//TypeRenaming
		public RuleCall getRenamingsTypeRenamingParserRuleCall_0_1_0() { return cRenamingsTypeRenamingParserRuleCall_0_1_0; }

		//("," renamings+=TypeRenaming)*
		public Group getGroup_0_2() { return cGroup_0_2; }

		//","
		public Keyword getCommaKeyword_0_2_0() { return cCommaKeyword_0_2_0; }

		//renamings+=TypeRenaming
		public Assignment getRenamingsAssignment_0_2_1() { return cRenamingsAssignment_0_2_1; }

		//TypeRenaming
		public RuleCall getRenamingsTypeRenamingParserRuleCall_0_2_1_0() { return cRenamingsTypeRenamingParserRuleCall_0_2_1_0; }

		//"constant" renamings+=ConstantRenaming ("," renamings+=ConstantRenaming)*
		public Group getGroup_1() { return cGroup_1; }

		//"constant"
		public Keyword getConstantKeyword_1_0() { return cConstantKeyword_1_0; }

		//renamings+=ConstantRenaming
		public Assignment getRenamingsAssignment_1_1() { return cRenamingsAssignment_1_1; }

		//ConstantRenaming
		public RuleCall getRenamingsConstantRenamingParserRuleCall_1_1_0() { return cRenamingsConstantRenamingParserRuleCall_1_1_0; }

		//("," renamings+=ConstantRenaming)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//","
		public Keyword getCommaKeyword_1_2_0() { return cCommaKeyword_1_2_0; }

		//renamings+=ConstantRenaming
		public Assignment getRenamingsAssignment_1_2_1() { return cRenamingsAssignment_1_2_1; }

		//ConstantRenaming
		public RuleCall getRenamingsConstantRenamingParserRuleCall_1_2_1_0() { return cRenamingsConstantRenamingParserRuleCall_1_2_1_0; }

		//"function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)*
		public Group getGroup_2() { return cGroup_2; }

		//"function"
		public Keyword getFunctionKeyword_2_0() { return cFunctionKeyword_2_0; }

		//renamings+=FunctionRenaming
		public Assignment getRenamingsAssignment_2_1() { return cRenamingsAssignment_2_1; }

		//FunctionRenaming
		public RuleCall getRenamingsFunctionRenamingParserRuleCall_2_1_0() { return cRenamingsFunctionRenamingParserRuleCall_2_1_0; }

		//("," renamings+=FunctionRenaming)*
		public Group getGroup_2_2() { return cGroup_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//renamings+=FunctionRenaming
		public Assignment getRenamingsAssignment_2_2_1() { return cRenamingsAssignment_2_2_1; }

		//FunctionRenaming
		public RuleCall getRenamingsFunctionRenamingParserRuleCall_2_2_1_0() { return cRenamingsFunctionRenamingParserRuleCall_2_2_1_0; }

		//"procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)*
		public Group getGroup_3() { return cGroup_3; }

		//"procedure"
		public Keyword getProcedureKeyword_3_0() { return cProcedureKeyword_3_0; }

		//renamings+=ProcedureRenaming
		public Assignment getRenamingsAssignment_3_1() { return cRenamingsAssignment_3_1; }

		//ProcedureRenaming
		public RuleCall getRenamingsProcedureRenamingParserRuleCall_3_1_0() { return cRenamingsProcedureRenamingParserRuleCall_3_1_0; }

		//("," renamings+=ProcedureRenaming)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }

		//renamings+=ProcedureRenaming
		public Assignment getRenamingsAssignment_3_2_1() { return cRenamingsAssignment_3_2_1; }

		//ProcedureRenaming
		public RuleCall getRenamingsProcedureRenamingParserRuleCall_3_2_1_0() { return cRenamingsProcedureRenamingParserRuleCall_3_2_1_0; }

		//"task" renamings+=TaskRenaming ("," renamings+=TaskRenaming)*
		public Group getGroup_4() { return cGroup_4; }

		//"task"
		public Keyword getTaskKeyword_4_0() { return cTaskKeyword_4_0; }

		//renamings+=TaskRenaming
		public Assignment getRenamingsAssignment_4_1() { return cRenamingsAssignment_4_1; }

		//TaskRenaming
		public RuleCall getRenamingsTaskRenamingParserRuleCall_4_1_0() { return cRenamingsTaskRenamingParserRuleCall_4_1_0; }

		//("," renamings+=TaskRenaming)*
		public Group getGroup_4_2() { return cGroup_4_2; }

		//","
		public Keyword getCommaKeyword_4_2_0() { return cCommaKeyword_4_2_0; }

		//renamings+=TaskRenaming
		public Assignment getRenamingsAssignment_4_2_1() { return cRenamingsAssignment_4_2_1; }

		//TaskRenaming
		public RuleCall getRenamingsTaskRenamingParserRuleCall_4_2_1_0() { return cRenamingsTaskRenamingParserRuleCall_4_2_1_0; }

		//"signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*
		public Group getGroup_5() { return cGroup_5; }

		//"signal"
		public Keyword getSignalKeyword_5_0() { return cSignalKeyword_5_0; }

		//renamings+=SignalRenaming
		public Assignment getRenamingsAssignment_5_1() { return cRenamingsAssignment_5_1; }

		//SignalRenaming
		public RuleCall getRenamingsSignalRenamingParserRuleCall_5_1_0() { return cRenamingsSignalRenamingParserRuleCall_5_1_0; }

		//("," renamings+=SignalRenaming)*
		public Group getGroup_5_2() { return cGroup_5_2; }

		//","
		public Keyword getCommaKeyword_5_2_0() { return cCommaKeyword_5_2_0; }

		//renamings+=SignalRenaming
		public Assignment getRenamingsAssignment_5_2_1() { return cRenamingsAssignment_5_2_1; }

		//SignalRenaming
		public RuleCall getRenamingsSignalRenamingParserRuleCall_5_2_1_0() { return cRenamingsSignalRenamingParserRuleCall_5_2_1_0; }
	}

	public class TypeRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameTypeCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameTypeIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameTypeCrossReference_0_0_0.eContents().get(1);
		private final Assignment cNewTypeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cNewTypeValueTypeEnumRuleCall_0_1_0 = (RuleCall)cNewTypeAssignment_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameTypeCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameTypeCrossReference_2_0.eContents().get(1);
		
		//TypeRenaming:
		//	(newName=[Type] | newType=ValueType) "/" oldName=[Type];
		public ParserRule getRule() { return rule; }

		//(newName=[Type] | newType=ValueType) "/" oldName=[Type]
		public Group getGroup() { return cGroup; }

		//newName=[Type] | newType=ValueType
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[Type]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[Type]
		public CrossReference getNewNameTypeCrossReference_0_0_0() { return cNewNameTypeCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameTypeIDTerminalRuleCall_0_0_0_1() { return cNewNameTypeIDTerminalRuleCall_0_0_0_1; }

		//newType=ValueType
		public Assignment getNewTypeAssignment_0_1() { return cNewTypeAssignment_0_1; }

		//ValueType
		public RuleCall getNewTypeValueTypeEnumRuleCall_0_1_0() { return cNewTypeValueTypeEnumRuleCall_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Type]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Type]
		public CrossReference getOldNameTypeCrossReference_2_0() { return cOldNameTypeCrossReference_2_0; }

		//ID
		public RuleCall getOldNameTypeIDTerminalRuleCall_2_0_1() { return cOldNameTypeIDTerminalRuleCall_2_0_1; }
	}

	public class ConstantRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameValuedObjectCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameValuedObjectIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameValuedObjectCrossReference_0_0_0.eContents().get(1);
		private final Assignment cNewValueAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cNewValueConstantAtomParserRuleCall_0_1_0 = (RuleCall)cNewValueAssignment_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameValuedObjectCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameValuedObjectIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameValuedObjectCrossReference_2_0.eContents().get(1);
		
		//ConstantRenaming:
		//	(newName=[kexpressions::ValuedObject] | newValue=ConstantAtom) "/" oldName=[kexpressions::ValuedObject];
		public ParserRule getRule() { return rule; }

		//(newName=[kexpressions::ValuedObject] | newValue=ConstantAtom) "/" oldName=[kexpressions::ValuedObject]
		public Group getGroup() { return cGroup; }

		//newName=[kexpressions::ValuedObject] | newValue=ConstantAtom
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[kexpressions::ValuedObject]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[kexpressions::ValuedObject]
		public CrossReference getNewNameValuedObjectCrossReference_0_0_0() { return cNewNameValuedObjectCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameValuedObjectIDTerminalRuleCall_0_0_0_1() { return cNewNameValuedObjectIDTerminalRuleCall_0_0_0_1; }

		//newValue=ConstantAtom
		public Assignment getNewValueAssignment_0_1() { return cNewValueAssignment_0_1; }

		//ConstantAtom
		public RuleCall getNewValueConstantAtomParserRuleCall_0_1_0() { return cNewValueConstantAtomParserRuleCall_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[kexpressions::ValuedObject]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[kexpressions::ValuedObject]
		public CrossReference getOldNameValuedObjectCrossReference_2_0() { return cOldNameValuedObjectCrossReference_2_0; }

		//ID
		public RuleCall getOldNameValuedObjectIDTerminalRuleCall_2_0_1() { return cOldNameValuedObjectIDTerminalRuleCall_2_0_1; }
	}

	public class FunctionRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameFunctionCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameFunctionIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameFunctionCrossReference_0_0_0.eContents().get(1);
		private final Assignment cNewFuncAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cNewFuncBuildInFunctionParserRuleCall_0_1_0 = (RuleCall)cNewFuncAssignment_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameFunctionCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameFunctionIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameFunctionCrossReference_2_0.eContents().get(1);
		
		//FunctionRenaming:
		//	(newName=[Function] | newFunc=BuildInFunction) "/" oldName=[Function];
		public ParserRule getRule() { return rule; }

		//(newName=[Function] | newFunc=BuildInFunction) "/" oldName=[Function]
		public Group getGroup() { return cGroup; }

		//newName=[Function] | newFunc=BuildInFunction
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[Function]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[Function]
		public CrossReference getNewNameFunctionCrossReference_0_0_0() { return cNewNameFunctionCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameFunctionIDTerminalRuleCall_0_0_0_1() { return cNewNameFunctionIDTerminalRuleCall_0_0_0_1; }

		//newFunc=BuildInFunction
		public Assignment getNewFuncAssignment_0_1() { return cNewFuncAssignment_0_1; }

		//BuildInFunction
		public RuleCall getNewFuncBuildInFunctionParserRuleCall_0_1_0() { return cNewFuncBuildInFunctionParserRuleCall_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Function]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Function]
		public CrossReference getOldNameFunctionCrossReference_2_0() { return cOldNameFunctionCrossReference_2_0; }

		//ID
		public RuleCall getOldNameFunctionIDTerminalRuleCall_2_0_1() { return cOldNameFunctionIDTerminalRuleCall_2_0_1; }
	}

	public class ProcedureRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ProcedureRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNewNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNewNameProcedureCrossReference_0_0 = (CrossReference)cNewNameAssignment_0.eContents().get(0);
		private final RuleCall cNewNameProcedureIDTerminalRuleCall_0_0_1 = (RuleCall)cNewNameProcedureCrossReference_0_0.eContents().get(1);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameProcedureCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameProcedureIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameProcedureCrossReference_2_0.eContents().get(1);
		
		//ProcedureRenaming:
		//	newName=[Procedure] "/" oldName=[Procedure];
		public ParserRule getRule() { return rule; }

		//newName=[Procedure] "/" oldName=[Procedure]
		public Group getGroup() { return cGroup; }

		//newName=[Procedure]
		public Assignment getNewNameAssignment_0() { return cNewNameAssignment_0; }

		//[Procedure]
		public CrossReference getNewNameProcedureCrossReference_0_0() { return cNewNameProcedureCrossReference_0_0; }

		//ID
		public RuleCall getNewNameProcedureIDTerminalRuleCall_0_0_1() { return cNewNameProcedureIDTerminalRuleCall_0_0_1; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Procedure]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Procedure]
		public CrossReference getOldNameProcedureCrossReference_2_0() { return cOldNameProcedureCrossReference_2_0; }

		//ID
		public RuleCall getOldNameProcedureIDTerminalRuleCall_2_0_1() { return cOldNameProcedureIDTerminalRuleCall_2_0_1; }
	}

	public class TaskRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TaskRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNewNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNewNameTaskCrossReference_0_0 = (CrossReference)cNewNameAssignment_0.eContents().get(0);
		private final RuleCall cNewNameTaskIDTerminalRuleCall_0_0_1 = (RuleCall)cNewNameTaskCrossReference_0_0.eContents().get(1);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameTaskCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameTaskIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameTaskCrossReference_2_0.eContents().get(1);
		
		//TaskRenaming:
		//	newName=[Task] "/" oldName=[Task];
		public ParserRule getRule() { return rule; }

		//newName=[Task] "/" oldName=[Task]
		public Group getGroup() { return cGroup; }

		//newName=[Task]
		public Assignment getNewNameAssignment_0() { return cNewNameAssignment_0; }

		//[Task]
		public CrossReference getNewNameTaskCrossReference_0_0() { return cNewNameTaskCrossReference_0_0; }

		//ID
		public RuleCall getNewNameTaskIDTerminalRuleCall_0_0_1() { return cNewNameTaskIDTerminalRuleCall_0_0_1; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[Task]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[Task]
		public CrossReference getOldNameTaskCrossReference_2_0() { return cOldNameTaskCrossReference_2_0; }

		//ID
		public RuleCall getOldNameTaskIDTerminalRuleCall_2_0_1() { return cOldNameTaskIDTerminalRuleCall_2_0_1; }
	}

	public class SignalRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNewNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final CrossReference cNewNameISignalCrossReference_0_0_0 = (CrossReference)cNewNameAssignment_0_0.eContents().get(0);
		private final RuleCall cNewNameISignalIDTerminalRuleCall_0_0_0_1 = (RuleCall)cNewNameISignalCrossReference_0_0_0.eContents().get(1);
		private final Keyword cTickKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cSolidusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOldNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cOldNameISignalCrossReference_2_0 = (CrossReference)cOldNameAssignment_2.eContents().get(0);
		private final RuleCall cOldNameISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cOldNameISignalCrossReference_2_0.eContents().get(1);
		
		//SignalRenaming:
		//	(newName=[kexpressions::ISignal] | "tick") "/" oldName=[kexpressions::ISignal];
		public ParserRule getRule() { return rule; }

		//(newName=[kexpressions::ISignal] | "tick") "/" oldName=[kexpressions::ISignal]
		public Group getGroup() { return cGroup; }

		//newName=[kexpressions::ISignal] | "tick"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//newName=[kexpressions::ISignal]
		public Assignment getNewNameAssignment_0_0() { return cNewNameAssignment_0_0; }

		//[kexpressions::ISignal]
		public CrossReference getNewNameISignalCrossReference_0_0_0() { return cNewNameISignalCrossReference_0_0_0; }

		//ID
		public RuleCall getNewNameISignalIDTerminalRuleCall_0_0_0_1() { return cNewNameISignalIDTerminalRuleCall_0_0_0_1; }

		//"tick"
		public Keyword getTickKeyword_0_1() { return cTickKeyword_0_1; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//oldName=[kexpressions::ISignal]
		public Assignment getOldNameAssignment_2() { return cOldNameAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getOldNameISignalCrossReference_2_0() { return cOldNameISignalCrossReference_2_0; }

		//ID
		public RuleCall getOldNameISignalIDTerminalRuleCall_2_0_1() { return cOldNameISignalIDTerminalRuleCall_2_0_1; }
	}

	public class BuildInFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuildInFunction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSolidusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPlusSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cHyphenMinusKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cModKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignGreaterThanSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLessThanSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cLessThanSignEqualsSignKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cGreaterThanSignEqualsSignKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cNotKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cAndKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cOrKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		
		//// renamings can also rename build in types and functions
		//BuildInFunction:
		//	"*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or";
		public ParserRule getRule() { return rule; }

		//"*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }

		//"/"
		public Keyword getSolidusKeyword_1() { return cSolidusKeyword_1; }

		//"+"
		public Keyword getPlusSignKeyword_2() { return cPlusSignKeyword_2; }

		//"-"
		public Keyword getHyphenMinusKeyword_3() { return cHyphenMinusKeyword_3; }

		//"mod"
		public Keyword getModKeyword_4() { return cModKeyword_4; }

		//"="
		public Keyword getEqualsSignKeyword_5() { return cEqualsSignKeyword_5; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_6() { return cLessThanSignGreaterThanSignKeyword_6; }

		//">"
		public Keyword getGreaterThanSignKeyword_7() { return cGreaterThanSignKeyword_7; }

		//"<"
		public Keyword getLessThanSignKeyword_8() { return cLessThanSignKeyword_8; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_9() { return cLessThanSignEqualsSignKeyword_9; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_10() { return cGreaterThanSignEqualsSignKeyword_10; }

		//"not"
		public Keyword getNotKeyword_11() { return cNotKeyword_11; }

		//"and"
		public Keyword getAndKeyword_12() { return cAndKeyword_12; }

		//"or"
		public Keyword getOrKeyword_13() { return cOrKeyword_13; }
	}

	public class SuspendElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Suspend");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSuspendKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cWhenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDelayAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDelayDelayExprParserRuleCall_3_0 = (RuleCall)cDelayAssignment_3.eContents().get(0);
		
		//// --> B.4.21 suspend: Preemption with State Freeze
		//// !-(suspend)-------------------------------------
		//Suspend:
		//	"suspend" statement=Statement "when" delay=DelayExpr;
		public ParserRule getRule() { return rule; }

		//"suspend" statement=Statement "when" delay=DelayExpr
		public Group getGroup() { return cGroup; }

		//"suspend"
		public Keyword getSuspendKeyword_0() { return cSuspendKeyword_0; }

		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }

		//"when"
		public Keyword getWhenKeyword_2() { return cWhenKeyword_2; }

		//delay=DelayExpr
		public Assignment getDelayAssignment_3() { return cDelayAssignment_3; }

		//DelayExpr
		public RuleCall getDelayDelayExprParserRuleCall_3_0() { return cDelayDelayExprParserRuleCall_3_0; }
	}

	public class SustainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sustain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSustainKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSignalAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cSignalISignalCrossReference_1_0_0 = (CrossReference)cSignalAssignment_1_0.eContents().get(0);
		private final RuleCall cSignalISignalIDTerminalRuleCall_1_0_0_1 = (RuleCall)cSignalISignalCrossReference_1_0_0.eContents().get(1);
		private final Assignment cTickAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTickTickParserRuleCall_1_1_0 = (RuleCall)cTickAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cExpressionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_2_1_0 = (RuleCall)cExpressionAssignment_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// -!
		//// --> B.4.22 sustain: Emit a Signal Indefinitely
		//// !-(sustain) -------------------------------------
		//Sustain:
		//	"sustain" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expression=Expression ")")?;
		public ParserRule getRule() { return rule; }

		//"sustain" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expression=Expression ")")?
		public Group getGroup() { return cGroup; }

		//"sustain"
		public Keyword getSustainKeyword_0() { return cSustainKeyword_0; }

		//signal=[kexpressions::ISignal] | tick=Tick
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//signal=[kexpressions::ISignal]
		public Assignment getSignalAssignment_1_0() { return cSignalAssignment_1_0; }

		//[kexpressions::ISignal]
		public CrossReference getSignalISignalCrossReference_1_0_0() { return cSignalISignalCrossReference_1_0_0; }

		//ID
		public RuleCall getSignalISignalIDTerminalRuleCall_1_0_0_1() { return cSignalISignalIDTerminalRuleCall_1_0_0_1; }

		//tick=Tick
		public Assignment getTickAssignment_1_1() { return cTickAssignment_1_1; }

		//Tick
		public RuleCall getTickTickParserRuleCall_1_1_0() { return cTickTickParserRuleCall_1_1_0; }

		//("(" expression=Expression ")")?
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_2_1() { return cExpressionAssignment_2_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_1_0() { return cExpressionExpressionParserRuleCall_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class TrapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Trap");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTrapKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTrapDeclListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTrapDeclListTrapDeclListParserRuleCall_1_0 = (RuleCall)cTrapDeclListAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		private final Assignment cTrapHandlerAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTrapHandlerTrapHandlerParserRuleCall_4_0 = (RuleCall)cTrapHandlerAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOptEndAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cOptEndTrapKeyword_6_0 = (Keyword)cOptEndAssignment_6.eContents().get(0);
		
		//// -!
		//// --> B.4.23 trap: TrapDeclaration and Handling
		//// !-(trap)-------------------------------------
		//Trap:
		//	"trap" trapDeclList=TrapDeclList "in" statement=Statement trapHandler+=TrapHandler* "end" optEnd="trap"?;
		public ParserRule getRule() { return rule; }

		//"trap" trapDeclList=TrapDeclList "in" statement=Statement trapHandler+=TrapHandler* "end" optEnd="trap"?
		public Group getGroup() { return cGroup; }

		//"trap"
		public Keyword getTrapKeyword_0() { return cTrapKeyword_0; }

		//trapDeclList=TrapDeclList
		public Assignment getTrapDeclListAssignment_1() { return cTrapDeclListAssignment_1; }

		//TrapDeclList
		public RuleCall getTrapDeclListTrapDeclListParserRuleCall_1_0() { return cTrapDeclListTrapDeclListParserRuleCall_1_0; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }

		//trapHandler+=TrapHandler*
		public Assignment getTrapHandlerAssignment_4() { return cTrapHandlerAssignment_4; }

		//TrapHandler
		public RuleCall getTrapHandlerTrapHandlerParserRuleCall_4_0() { return cTrapHandlerTrapHandlerParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }

		//optEnd="trap"?
		public Assignment getOptEndAssignment_6() { return cOptEndAssignment_6; }

		//"trap"
		public Keyword getOptEndTrapKeyword_6_0() { return cOptEndTrapKeyword_6_0; }
	}

	public class TrapDeclListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrapDeclList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTrapDeclsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTrapDeclsTrapDeclParserRuleCall_0_0 = (RuleCall)cTrapDeclsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTrapDeclsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTrapDeclsTrapDeclParserRuleCall_1_1_0 = (RuleCall)cTrapDeclsAssignment_1_1.eContents().get(0);
		
		//TrapDeclList:
		//	trapDecls+=TrapDecl ("," trapDecls+=TrapDecl)*;
		public ParserRule getRule() { return rule; }

		//trapDecls+=TrapDecl ("," trapDecls+=TrapDecl)*
		public Group getGroup() { return cGroup; }

		//trapDecls+=TrapDecl
		public Assignment getTrapDeclsAssignment_0() { return cTrapDeclsAssignment_0; }

		//TrapDecl
		public RuleCall getTrapDeclsTrapDeclParserRuleCall_0_0() { return cTrapDeclsTrapDeclParserRuleCall_0_0; }

		//("," trapDecls+=TrapDecl)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//trapDecls+=TrapDecl
		public Assignment getTrapDeclsAssignment_1_1() { return cTrapDeclsAssignment_1_1; }

		//TrapDecl
		public RuleCall getTrapDeclsTrapDeclParserRuleCall_1_1_0() { return cTrapDeclsTrapDeclParserRuleCall_1_1_0; }
	}

	public class TrapDeclElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrapDecl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrapDeclAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cChannelDescrAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChannelDescrChannelDescriptionParserRuleCall_2_0 = (RuleCall)cChannelDescrAssignment_2.eContents().get(0);
		
		//TrapDecl returns kexpressions::ISignal:
		//	{TrapDecl} name=ID channelDescr=ChannelDescription?;
		public ParserRule getRule() { return rule; }

		//{TrapDecl} name=ID channelDescr=ChannelDescription?
		public Group getGroup() { return cGroup; }

		//{TrapDecl}
		public Action getTrapDeclAction_0() { return cTrapDeclAction_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//channelDescr=ChannelDescription?
		public Assignment getChannelDescrAssignment_2() { return cChannelDescrAssignment_2; }

		//ChannelDescription
		public RuleCall getChannelDescrChannelDescriptionParserRuleCall_2_0() { return cChannelDescrChannelDescriptionParserRuleCall_2_0; }
	}

	public class TrapHandlerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrapHandler");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHandleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTrapExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTrapExprTrapExprParserRuleCall_1_0 = (RuleCall)cTrapExprAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStatementAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStatementStatementParserRuleCall_3_0 = (RuleCall)cStatementAssignment_3.eContents().get(0);
		
		//TrapHandler:
		//	"handle" trapExpr=TrapExpr "do" statement=Statement;
		public ParserRule getRule() { return rule; }

		//"handle" trapExpr=TrapExpr "do" statement=Statement
		public Group getGroup() { return cGroup; }

		//"handle"
		public Keyword getHandleKeyword_0() { return cHandleKeyword_0; }

		//trapExpr=TrapExpr
		public Assignment getTrapExprAssignment_1() { return cTrapExprAssignment_1; }

		//TrapExpr
		public RuleCall getTrapExprTrapExprParserRuleCall_1_0() { return cTrapExprTrapExprParserRuleCall_1_0; }

		//"do"
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }

		//statement=Statement
		public Assignment getStatementAssignment_3() { return cStatementAssignment_3; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_3_0() { return cStatementStatementParserRuleCall_3_0; }
	}

	public class LocalVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LocalVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarInterfaceVariableDeclParserRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		private final Keyword cEndKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOptEndAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final Keyword cOptEndVarKeyword_4_0 = (Keyword)cOptEndAssignment_4.eContents().get(0);
		
		//// -!
		//// --> B.4.24 var: Local Variable Declaration
		//// !-(localvariable) -------------------------------------
		//LocalVariable:
		//	var=InterfaceVariableDecl "in" statement=Statement "end" optEnd="var"?;
		public ParserRule getRule() { return rule; }

		//var=InterfaceVariableDecl "in" statement=Statement "end" optEnd="var"?
		public Group getGroup() { return cGroup; }

		//var=InterfaceVariableDecl
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }

		//InterfaceVariableDecl
		public RuleCall getVarInterfaceVariableDeclParserRuleCall_0_0() { return cVarInterfaceVariableDeclParserRuleCall_0_0; }

		//"in"
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//statement=Statement
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_0() { return cStatementStatementParserRuleCall_2_0; }

		//"end"
		public Keyword getEndKeyword_3() { return cEndKeyword_3; }

		//optEnd="var"?
		public Assignment getOptEndAssignment_4() { return cOptEndAssignment_4; }

		//"var"
		public Keyword getOptEndVarKeyword_4_0() { return cOptEndVarKeyword_4_0; }
	}

	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTrapExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBooleanValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cValuedObjectTestExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTextExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cBooleanExpressionParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5_2 = (Keyword)cGroup_5.eContents().get(2);
		private final RuleCall cConstantExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//// -!
		//// ==============================================
		//// ===            B.3 Expressions             ===
		//// ==============================================
		//// esterel is a bit richer than what is provided by kexpressions. These rules are introduced here
		//// care about order of the rules! 
		//AtomicExpression returns kexpressions::Expression:
		//	FunctionExpression | TrapExpression | BooleanValue | ValuedObjectTestExpression | TextExpression | "("
		//	BooleanExpression ")" | ConstantExpression;
		public ParserRule getRule() { return rule; }

		//FunctionExpression | TrapExpression | BooleanValue | ValuedObjectTestExpression | TextExpression | "(" BooleanExpression
		//")" | ConstantExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//FunctionExpression
		public RuleCall getFunctionExpressionParserRuleCall_0() { return cFunctionExpressionParserRuleCall_0; }

		//TrapExpression
		public RuleCall getTrapExpressionParserRuleCall_1() { return cTrapExpressionParserRuleCall_1; }

		//BooleanValue
		public RuleCall getBooleanValueParserRuleCall_2() { return cBooleanValueParserRuleCall_2; }

		//ValuedObjectTestExpression
		public RuleCall getValuedObjectTestExpressionParserRuleCall_3() { return cValuedObjectTestExpressionParserRuleCall_3; }

		//TextExpression
		public RuleCall getTextExpressionParserRuleCall_4() { return cTextExpressionParserRuleCall_4; }

		//"(" BooleanExpression ")"
		public Group getGroup_5() { return cGroup_5; }

		//"("
		public Keyword getLeftParenthesisKeyword_5_0() { return cLeftParenthesisKeyword_5_0; }

		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_5_1() { return cBooleanExpressionParserRuleCall_5_1; }

		//")"
		public Keyword getRightParenthesisKeyword_5_2() { return cRightParenthesisKeyword_5_2; }

		//ConstantExpression
		public RuleCall getConstantExpressionParserRuleCall_6() { return cConstantExpressionParserRuleCall_6; }
	}

	public class TrapExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrapExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrapExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cQuestionMarkQuestionMarkKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTrapAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTrapISignalCrossReference_2_0 = (CrossReference)cTrapAssignment_2.eContents().get(0);
		private final RuleCall cTrapISignalIDTerminalRuleCall_2_0_1 = (RuleCall)cTrapISignalCrossReference_2_0.eContents().get(1);
		
		//TrapExpression returns kexpressions::Expression:
		//	{TrapExpression} "??" trap=[kexpressions::ISignal];
		public ParserRule getRule() { return rule; }

		//{TrapExpression} "??" trap=[kexpressions::ISignal]
		public Group getGroup() { return cGroup; }

		//{TrapExpression}
		public Action getTrapExpressionAction_0() { return cTrapExpressionAction_0; }

		//"??"
		public Keyword getQuestionMarkQuestionMarkKeyword_1() { return cQuestionMarkQuestionMarkKeyword_1; }

		//trap=[kexpressions::ISignal]
		public Assignment getTrapAssignment_2() { return cTrapAssignment_2; }

		//[kexpressions::ISignal]
		public CrossReference getTrapISignalCrossReference_2_0() { return cTrapISignalCrossReference_2_0; }

		//ID
		public RuleCall getTrapISignalIDTerminalRuleCall_2_0_1() { return cTrapISignalIDTerminalRuleCall_2_0_1; }
	}

	public class FunctionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFunctionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFunctionFunctionCrossReference_1_0 = (CrossReference)cFunctionAssignment_1.eContents().get(0);
		private final RuleCall cFunctionFunctionIDTerminalRuleCall_1_0_1 = (RuleCall)cFunctionFunctionCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cKexpressionsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cKexpressionsExpressionParserRuleCall_3_0_0 = (RuleCall)cKexpressionsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cKexpressionsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cKexpressionsExpressionParserRuleCall_3_1_1_0 = (RuleCall)cKexpressionsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionExpression returns kexpressions::Expression:
		//	{FunctionExpression} function=[Function] "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
		public ParserRule getRule() { return rule; }

		//{FunctionExpression} function=[Function] "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//{FunctionExpression}
		public Action getFunctionExpressionAction_0() { return cFunctionExpressionAction_0; }

		//function=[Function]
		public Assignment getFunctionAssignment_1() { return cFunctionAssignment_1; }

		//[Function]
		public CrossReference getFunctionFunctionCrossReference_1_0() { return cFunctionFunctionCrossReference_1_0; }

		//ID
		public RuleCall getFunctionFunctionIDTerminalRuleCall_1_0_1() { return cFunctionFunctionIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(kexpressions+=Expression ("," kexpressions+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_3_0() { return cKexpressionsAssignment_3_0; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_3_0_0() { return cKexpressionsExpressionParserRuleCall_3_0_0; }

		//("," kexpressions+=Expression)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_3_1_1() { return cKexpressionsAssignment_3_1_1; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_3_1_1_0() { return cKexpressionsExpressionParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class ConstantExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cConstantAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cConstantConstantCrossReference_1_0_0 = (CrossReference)cConstantAssignment_1_0.eContents().get(0);
		private final RuleCall cConstantConstantIDTerminalRuleCall_1_0_0_1 = (RuleCall)cConstantConstantCrossReference_1_0_0.eContents().get(1);
		private final Assignment cValueAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cValueConstantAtomParserRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		
		//ConstantExpression returns kexpressions::Expression:
		//	{ConstantExpression} (constant=[Constant] | value=ConstantAtom);
		public ParserRule getRule() { return rule; }

		//{ConstantExpression} (constant=[Constant] | value=ConstantAtom)
		public Group getGroup() { return cGroup; }

		//{ConstantExpression}
		public Action getConstantExpressionAction_0() { return cConstantExpressionAction_0; }

		//constant=[Constant] | value=ConstantAtom
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//constant=[Constant]
		public Assignment getConstantAssignment_1_0() { return cConstantAssignment_1_0; }

		//[Constant]
		public CrossReference getConstantConstantCrossReference_1_0_0() { return cConstantConstantCrossReference_1_0_0; }

		//ID
		public RuleCall getConstantConstantIDTerminalRuleCall_1_0_0_1() { return cConstantConstantIDTerminalRuleCall_1_0_0_1; }

		//value=ConstantAtom
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//ConstantAtom
		public RuleCall getValueConstantAtomParserRuleCall_1_1_0() { return cValueConstantAtomParserRuleCall_1_1_0; }
	}

	public class TrapExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrapExpr");
		private final RuleCall cSignalExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// --> B.3.5 Trap Expressions <--
		//// -------------------------------------
		//TrapExpr returns kexpressions::Expression:
		//	SignalExpression;
		public ParserRule getRule() { return rule; }

		//SignalExpression
		public RuleCall getSignalExpressionParserRuleCall() { return cSignalExpressionParserRuleCall; }
	}

	public class SignalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSignalAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperatorExpressionSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorOrOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSubExpressionsSignalAndExpressionParserRuleCall_1_2_0 = (RuleCall)cSubExpressionsAssignment_1_2.eContents().get(0);
		
		//// --> B.3.3 Signal Expressions <--
		//// -------------------------------------
		//SignalExpression returns kexpressions::Expression:
		//	SignalAndExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator
		//	subExpressions+=SignalAndExpression)*;
		public ParserRule getRule() { return rule; }

		//SignalAndExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator
		//subExpressions+=SignalAndExpression)*
		public Group getGroup() { return cGroup; }

		//SignalAndExpression
		public RuleCall getSignalAndExpressionParserRuleCall_0() { return cSignalAndExpressionParserRuleCall_0; }

		//({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator subExpressions+=SignalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{kexpressions::OperatorExpression.subExpressions+=current}
		public Action getOperatorExpressionSubExpressionsAction_1_0() { return cOperatorExpressionSubExpressionsAction_1_0; }

		//operator=OrOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//OrOperator
		public RuleCall getOperatorOrOperatorEnumRuleCall_1_1_0() { return cOperatorOrOperatorEnumRuleCall_1_1_0; }

		//subExpressions+=SignalAndExpression
		public Assignment getSubExpressionsAssignment_1_2() { return cSubExpressionsAssignment_1_2; }

		//SignalAndExpression
		public RuleCall getSubExpressionsSignalAndExpressionParserRuleCall_1_2_0() { return cSubExpressionsSignalAndExpressionParserRuleCall_1_2_0; }
	}

	public class SignalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSignalNotExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOperatorExpressionSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorAndOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSubExpressionsSignalNotExpressionParserRuleCall_1_2_0 = (RuleCall)cSubExpressionsAssignment_1_2.eContents().get(0);
		
		//SignalAndExpression returns kexpressions::Expression:
		//	SignalNotExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator
		//	subExpressions+=SignalNotExpression)*;
		public ParserRule getRule() { return rule; }

		//SignalNotExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator
		//subExpressions+=SignalNotExpression)*
		public Group getGroup() { return cGroup; }

		//SignalNotExpression
		public RuleCall getSignalNotExpressionParserRuleCall_0() { return cSignalNotExpressionParserRuleCall_0; }

		//({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator subExpressions+=SignalNotExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{kexpressions::OperatorExpression.subExpressions+=current}
		public Action getOperatorExpressionSubExpressionsAction_1_0() { return cOperatorExpressionSubExpressionsAction_1_0; }

		//operator=AndOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//AndOperator
		public RuleCall getOperatorAndOperatorEnumRuleCall_1_1_0() { return cOperatorAndOperatorEnumRuleCall_1_1_0; }

		//subExpressions+=SignalNotExpression
		public Assignment getSubExpressionsAssignment_1_2() { return cSubExpressionsAssignment_1_2; }

		//SignalNotExpression
		public RuleCall getSubExpressionsSignalNotExpressionParserRuleCall_1_2_0() { return cSubExpressionsSignalNotExpressionParserRuleCall_1_2_0; }
	}

	public class SignalNotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalNotExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cOperatorExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOperatorNotOperatorEnumRuleCall_0_1_0 = (RuleCall)cOperatorAssignment_0_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cSubExpressionsSignalNotExpressionParserRuleCall_0_2_0 = (RuleCall)cSubExpressionsAssignment_0_2.eContents().get(0);
		private final RuleCall cSignalAtomicExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SignalNotExpression returns kexpressions::Expression:
		//	{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression | SignalAtomicExpression;
		public ParserRule getRule() { return rule; }

		//{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression | SignalAtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression
		public Group getGroup_0() { return cGroup_0; }

		//{kexpressions::OperatorExpression}
		public Action getOperatorExpressionAction_0_0() { return cOperatorExpressionAction_0_0; }

		//operator=NotOperator
		public Assignment getOperatorAssignment_0_1() { return cOperatorAssignment_0_1; }

		//NotOperator
		public RuleCall getOperatorNotOperatorEnumRuleCall_0_1_0() { return cOperatorNotOperatorEnumRuleCall_0_1_0; }

		//subExpressions+=SignalNotExpression
		public Assignment getSubExpressionsAssignment_0_2() { return cSubExpressionsAssignment_0_2; }

		//SignalNotExpression
		public RuleCall getSubExpressionsSignalNotExpressionParserRuleCall_0_2_0() { return cSubExpressionsSignalNotExpressionParserRuleCall_0_2_0; }

		//SignalAtomicExpression
		public RuleCall getSignalAtomicExpressionParserRuleCall_1() { return cSignalAtomicExpressionParserRuleCall_1; }
	}

	public class SignalAtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalAtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSignalReferenceExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSignalExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cSignalPreExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTrapReferenceExprParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//SignalAtomicExpression returns kexpressions::Expression:
		//	SignalReferenceExpr | "(" SignalExpression ")" | SignalPreExpr | // maybe place this somewhere else 
		//	TrapReferenceExpr;
		public ParserRule getRule() { return rule; }

		//SignalReferenceExpr | "(" SignalExpression ")" | SignalPreExpr | // maybe place this somewhere else 
		//TrapReferenceExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//SignalReferenceExpr
		public RuleCall getSignalReferenceExprParserRuleCall_0() { return cSignalReferenceExprParserRuleCall_0; }

		//"(" SignalExpression ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//SignalExpression
		public RuleCall getSignalExpressionParserRuleCall_1_1() { return cSignalExpressionParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//SignalPreExpr
		public RuleCall getSignalPreExprParserRuleCall_2() { return cSignalPreExprParserRuleCall_2; }

		//// maybe place this somewhere else 
		//TrapReferenceExpr
		public RuleCall getTrapReferenceExprParserRuleCall_3() { return cTrapReferenceExprParserRuleCall_3; }
	}

	public class SignalReferenceExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalReferenceExpr");
		private final Assignment cValuedObjectAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cValuedObjectISignalCrossReference_0 = (CrossReference)cValuedObjectAssignment.eContents().get(0);
		private final RuleCall cValuedObjectISignalIDTerminalRuleCall_0_1 = (RuleCall)cValuedObjectISignalCrossReference_0.eContents().get(1);
		
		//SignalReferenceExpr returns kexpressions::ValuedObjectReference:
		//	valuedObject=[kexpressions::ISignal];
		public ParserRule getRule() { return rule; }

		//valuedObject=[kexpressions::ISignal]
		public Assignment getValuedObjectAssignment() { return cValuedObjectAssignment; }

		//[kexpressions::ISignal]
		public CrossReference getValuedObjectISignalCrossReference_0() { return cValuedObjectISignalCrossReference_0; }

		//ID
		public RuleCall getValuedObjectISignalIDTerminalRuleCall_0_1() { return cValuedObjectISignalIDTerminalRuleCall_0_1; }
	}

	public class SignalPreExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SignalPreExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOperatorExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorPreOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSubExpressionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSubExpressionsSignalReferenceExprParserRuleCall_3_0 = (RuleCall)cSubExpressionsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//SignalPreExpr returns kexpressions::Expression:
		//	{kexpressions::OperatorExpression} operator=PreOperator "(" subExpressions+=SignalReferenceExpr ")";
		public ParserRule getRule() { return rule; }

		//{kexpressions::OperatorExpression} operator=PreOperator "(" subExpressions+=SignalReferenceExpr ")"
		public Group getGroup() { return cGroup; }

		//{kexpressions::OperatorExpression}
		public Action getOperatorExpressionAction_0() { return cOperatorExpressionAction_0; }

		//operator=PreOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }

		//PreOperator
		public RuleCall getOperatorPreOperatorEnumRuleCall_1_0() { return cOperatorPreOperatorEnumRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//subExpressions+=SignalReferenceExpr
		public Assignment getSubExpressionsAssignment_3() { return cSubExpressionsAssignment_3; }

		//SignalReferenceExpr
		public RuleCall getSubExpressionsSignalReferenceExprParserRuleCall_3_0() { return cSubExpressionsSignalReferenceExprParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class TrapReferenceExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrapReferenceExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrapReferenceExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValuedObjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValuedObjectTrapDeclCrossReference_1_0 = (CrossReference)cValuedObjectAssignment_1.eContents().get(0);
		private final RuleCall cValuedObjectTrapDeclIDTerminalRuleCall_1_0_1 = (RuleCall)cValuedObjectTrapDeclCrossReference_1_0.eContents().get(1);
		
		//TrapReferenceExpr returns kexpressions::ValuedObjectReference:
		//	{TrapReferenceExpr} valuedObject=[TrapDecl];
		public ParserRule getRule() { return rule; }

		//{TrapReferenceExpr} valuedObject=[TrapDecl]
		public Group getGroup() { return cGroup; }

		//{TrapReferenceExpr}
		public Action getTrapReferenceExprAction_0() { return cTrapReferenceExprAction_0; }

		//valuedObject=[TrapDecl]
		public Assignment getValuedObjectAssignment_1() { return cValuedObjectAssignment_1; }

		//[TrapDecl]
		public CrossReference getValuedObjectTrapDeclCrossReference_1_0() { return cValuedObjectTrapDeclCrossReference_1_0; }

		//ID
		public RuleCall getValuedObjectTrapDeclIDTerminalRuleCall_1_0_1() { return cValuedObjectTrapDeclIDTerminalRuleCall_1_0_1; }
	}

	public class DelayExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DelayExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cExprAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cExprExpressionParserRuleCall_0_0_0 = (RuleCall)cExprAssignment_0_0.eContents().get(0);
		private final Assignment cEventAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cEventDelayEventParserRuleCall_0_1_0 = (RuleCall)cEventAssignment_0_1.eContents().get(0);
		private final Assignment cEventAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cEventDelayEventParserRuleCall_1_0 = (RuleCall)cEventAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cIsImmediateAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cIsImmediateImmediateKeyword_2_0_0 = (Keyword)cIsImmediateAssignment_2_0.eContents().get(0);
		private final Assignment cEventAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEventDelayEventParserRuleCall_2_1_0 = (RuleCall)cEventAssignment_2_1.eContents().get(0);
		
		//// --> B.3.4 Delay Expressions <--
		//// -------------------------------------
		//DelayExpr:
		//	expr=Expression event=DelayEvent | event=DelayEvent | isImmediate?="immediate" event=DelayEvent;
		public ParserRule getRule() { return rule; }

		//expr=Expression event=DelayEvent | event=DelayEvent | isImmediate?="immediate" event=DelayEvent
		public Alternatives getAlternatives() { return cAlternatives; }

		//expr=Expression event=DelayEvent
		public Group getGroup_0() { return cGroup_0; }

		//expr=Expression
		public Assignment getExprAssignment_0_0() { return cExprAssignment_0_0; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_0_0_0() { return cExprExpressionParserRuleCall_0_0_0; }

		//event=DelayEvent
		public Assignment getEventAssignment_0_1() { return cEventAssignment_0_1; }

		//DelayEvent
		public RuleCall getEventDelayEventParserRuleCall_0_1_0() { return cEventDelayEventParserRuleCall_0_1_0; }

		//event=DelayEvent
		public Assignment getEventAssignment_1() { return cEventAssignment_1; }

		//DelayEvent
		public RuleCall getEventDelayEventParserRuleCall_1_0() { return cEventDelayEventParserRuleCall_1_0; }

		//isImmediate?="immediate" event=DelayEvent
		public Group getGroup_2() { return cGroup_2; }

		//isImmediate?="immediate"
		public Assignment getIsImmediateAssignment_2_0() { return cIsImmediateAssignment_2_0; }

		//"immediate"
		public Keyword getIsImmediateImmediateKeyword_2_0_0() { return cIsImmediateImmediateKeyword_2_0_0; }

		//event=DelayEvent
		public Assignment getEventAssignment_2_1() { return cEventAssignment_2_1; }

		//DelayEvent
		public RuleCall getEventDelayEventParserRuleCall_2_1_0() { return cEventDelayEventParserRuleCall_2_1_0; }
	}

	public class DelayEventElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DelayEvent");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTickAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTickTickParserRuleCall_0_0 = (RuleCall)cTickAssignment_0.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cExprSignalReferenceExprParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cFBAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cFBLeftSquareBracketKeyword_2_0_0 = (Keyword)cFBAssignment_2_0.eContents().get(0);
		private final Assignment cExprAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExprSignalExpressionParserRuleCall_2_1_0 = (RuleCall)cExprAssignment_2_1.eContents().get(0);
		private final Assignment cEBAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final Keyword cEBRightSquareBracketKeyword_2_2_0 = (Keyword)cEBAssignment_2_2.eContents().get(0);
		
		//DelayEvent:
		//	tick=Tick | expr=SignalReferenceExpr | fB="[" expr=SignalExpression eB="]";
		public ParserRule getRule() { return rule; }

		//tick=Tick | expr=SignalReferenceExpr | fB="[" expr=SignalExpression eB="]"
		public Alternatives getAlternatives() { return cAlternatives; }

		//tick=Tick
		public Assignment getTickAssignment_0() { return cTickAssignment_0; }

		//Tick
		public RuleCall getTickTickParserRuleCall_0_0() { return cTickTickParserRuleCall_0_0; }

		//expr=SignalReferenceExpr
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//SignalReferenceExpr
		public RuleCall getExprSignalReferenceExprParserRuleCall_1_0() { return cExprSignalReferenceExprParserRuleCall_1_0; }

		//fB="[" expr=SignalExpression eB="]"
		public Group getGroup_2() { return cGroup_2; }

		//fB="["
		public Assignment getFBAssignment_2_0() { return cFBAssignment_2_0; }

		//"["
		public Keyword getFBLeftSquareBracketKeyword_2_0_0() { return cFBLeftSquareBracketKeyword_2_0_0; }

		//expr=SignalExpression
		public Assignment getExprAssignment_2_1() { return cExprAssignment_2_1; }

		//SignalExpression
		public RuleCall getExprSignalExpressionParserRuleCall_2_1_0() { return cExprSignalExpressionParserRuleCall_2_1_0; }

		//eB="]"
		public Assignment getEBAssignment_2_2() { return cEBAssignment_2_2; }

		//"]"
		public Keyword getEBRightSquareBracketKeyword_2_2_0() { return cEBRightSquareBracketKeyword_2_2_0; }
	}

	public class ExecElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Exec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Keyword cExecKeyword_0_0_0 = (Keyword)cGroup_0_0.eContents().get(0);
		private final Assignment cTaskAssignment_0_0_1 = (Assignment)cGroup_0_0.eContents().get(1);
		private final CrossReference cTaskTaskCrossReference_0_0_1_0 = (CrossReference)cTaskAssignment_0_0_1.eContents().get(0);
		private final RuleCall cTaskTaskIDTerminalRuleCall_0_0_1_0_1 = (RuleCall)cTaskTaskCrossReference_0_0_1_0.eContents().get(1);
		private final Assignment cBodyAssignment_0_0_2 = (Assignment)cGroup_0_0.eContents().get(2);
		private final RuleCall cBodyExecBodyParserRuleCall_0_0_2_0 = (RuleCall)cBodyAssignment_0_0_2.eContents().get(0);
		private final Keyword cReturnKeyword_0_0_3 = (Keyword)cGroup_0_0.eContents().get(3);
		private final Assignment cRetSignalAssignment_0_0_4 = (Assignment)cGroup_0_0.eContents().get(4);
		private final CrossReference cRetSignalISignalCrossReference_0_0_4_0 = (CrossReference)cRetSignalAssignment_0_0_4.eContents().get(0);
		private final RuleCall cRetSignalISignalIDTerminalRuleCall_0_0_4_0_1 = (RuleCall)cRetSignalISignalCrossReference_0_0_4_0.eContents().get(1);
		private final Group cGroup_0_0_5 = (Group)cGroup_0_0.eContents().get(5);
		private final Keyword cDoKeyword_0_0_5_0 = (Keyword)cGroup_0_0_5.eContents().get(0);
		private final Assignment cStatementAssignment_0_0_5_1 = (Assignment)cGroup_0_0_5.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_0_0_5_1_0 = (RuleCall)cStatementAssignment_0_0_5_1.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cExecKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cExecCaseListAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cExecCaseListExecCaseParserRuleCall_0_1_1_0 = (RuleCall)cExecCaseListAssignment_0_1_1.eContents().get(0);
		private final Assignment cExecCaseListAssignment_0_1_2 = (Assignment)cGroup_0_1.eContents().get(2);
		private final RuleCall cExecCaseListExecCaseParserRuleCall_0_1_2_0 = (RuleCall)cExecCaseListAssignment_0_1_2.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOptEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cOptEndExecKeyword_2_0 = (Keyword)cOptEndAssignment_2.eContents().get(0);
		
		//// --> Exec
		//// -------------------------------------
		//Exec:
		//	("exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
		//	execCaseList+=ExecCase execCaseList+=ExecCase*) "end" optEnd="exec"?;
		public ParserRule getRule() { return rule; }

		//("exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
		//execCaseList+=ExecCase execCaseList+=ExecCase*) "end" optEnd="exec"?
		public Group getGroup() { return cGroup; }

		//"exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
		//execCaseList+=ExecCase execCaseList+=ExecCase*
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?
		public Group getGroup_0_0() { return cGroup_0_0; }

		//"exec"
		public Keyword getExecKeyword_0_0_0() { return cExecKeyword_0_0_0; }

		//task=[Task]
		public Assignment getTaskAssignment_0_0_1() { return cTaskAssignment_0_0_1; }

		//[Task]
		public CrossReference getTaskTaskCrossReference_0_0_1_0() { return cTaskTaskCrossReference_0_0_1_0; }

		//ID
		public RuleCall getTaskTaskIDTerminalRuleCall_0_0_1_0_1() { return cTaskTaskIDTerminalRuleCall_0_0_1_0_1; }

		//body=ExecBody
		public Assignment getBodyAssignment_0_0_2() { return cBodyAssignment_0_0_2; }

		//ExecBody
		public RuleCall getBodyExecBodyParserRuleCall_0_0_2_0() { return cBodyExecBodyParserRuleCall_0_0_2_0; }

		//"return"
		public Keyword getReturnKeyword_0_0_3() { return cReturnKeyword_0_0_3; }

		//retSignal=[kexpressions::ISignal]
		public Assignment getRetSignalAssignment_0_0_4() { return cRetSignalAssignment_0_0_4; }

		//[kexpressions::ISignal]
		public CrossReference getRetSignalISignalCrossReference_0_0_4_0() { return cRetSignalISignalCrossReference_0_0_4_0; }

		//ID
		public RuleCall getRetSignalISignalIDTerminalRuleCall_0_0_4_0_1() { return cRetSignalISignalIDTerminalRuleCall_0_0_4_0_1; }

		//("do" statement=Statement)?
		public Group getGroup_0_0_5() { return cGroup_0_0_5; }

		//"do"
		public Keyword getDoKeyword_0_0_5_0() { return cDoKeyword_0_0_5_0; }

		//statement=Statement
		public Assignment getStatementAssignment_0_0_5_1() { return cStatementAssignment_0_0_5_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_0_0_5_1_0() { return cStatementStatementParserRuleCall_0_0_5_1_0; }

		//"exec" execCaseList+=ExecCase execCaseList+=ExecCase*
		public Group getGroup_0_1() { return cGroup_0_1; }

		//"exec"
		public Keyword getExecKeyword_0_1_0() { return cExecKeyword_0_1_0; }

		//execCaseList+=ExecCase
		public Assignment getExecCaseListAssignment_0_1_1() { return cExecCaseListAssignment_0_1_1; }

		//ExecCase
		public RuleCall getExecCaseListExecCaseParserRuleCall_0_1_1_0() { return cExecCaseListExecCaseParserRuleCall_0_1_1_0; }

		//execCaseList+=ExecCase*
		public Assignment getExecCaseListAssignment_0_1_2() { return cExecCaseListAssignment_0_1_2; }

		//ExecCase
		public RuleCall getExecCaseListExecCaseParserRuleCall_0_1_2_0() { return cExecCaseListExecCaseParserRuleCall_0_1_2_0; }

		//"end"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//optEnd="exec"?
		public Assignment getOptEndAssignment_2() { return cOptEndAssignment_2; }

		//"exec"
		public Keyword getOptEndExecKeyword_2_0() { return cOptEndExecKeyword_2_0; }
	}

	public class ExecBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExecBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExecBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cVarsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final CrossReference cVarsIVariableCrossReference_2_0_0 = (CrossReference)cVarsAssignment_2_0.eContents().get(0);
		private final RuleCall cVarsIVariableIDTerminalRuleCall_2_0_0_1 = (RuleCall)cVarsIVariableCrossReference_2_0_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cVarsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final CrossReference cVarsIVariableCrossReference_2_1_1_0 = (CrossReference)cVarsAssignment_2_1_1.eContents().get(0);
		private final RuleCall cVarsIVariableIDTerminalRuleCall_2_1_1_0_1 = (RuleCall)cVarsIVariableCrossReference_2_1_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cKexpressionsAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cKexpressionsExpressionParserRuleCall_5_0_0 = (RuleCall)cKexpressionsAssignment_5_0.eContents().get(0);
		private final Group cGroup_5_1 = (Group)cGroup_5.eContents().get(1);
		private final Keyword cCommaKeyword_5_1_0 = (Keyword)cGroup_5_1.eContents().get(0);
		private final Assignment cKexpressionsAssignment_5_1_1 = (Assignment)cGroup_5_1.eContents().get(1);
		private final RuleCall cKexpressionsExpressionParserRuleCall_5_1_1_0 = (RuleCall)cKexpressionsAssignment_5_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ExecBody:
		//	{ExecBody} "(" (vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)? ")" "("
		//	(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
		public ParserRule getRule() { return rule; }

		//{ExecBody} "(" (vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)? ")" "("
		//(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//{ExecBody}
		public Action getExecBodyAction_0() { return cExecBodyAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)?
		public Group getGroup_2() { return cGroup_2; }

		//vars+=[kexpressions::IVariable]
		public Assignment getVarsAssignment_2_0() { return cVarsAssignment_2_0; }

		//[kexpressions::IVariable]
		public CrossReference getVarsIVariableCrossReference_2_0_0() { return cVarsIVariableCrossReference_2_0_0; }

		//ID
		public RuleCall getVarsIVariableIDTerminalRuleCall_2_0_0_1() { return cVarsIVariableIDTerminalRuleCall_2_0_0_1; }

		//("," vars+=[kexpressions::IVariable])*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//vars+=[kexpressions::IVariable]
		public Assignment getVarsAssignment_2_1_1() { return cVarsAssignment_2_1_1; }

		//[kexpressions::IVariable]
		public CrossReference getVarsIVariableCrossReference_2_1_1_0() { return cVarsIVariableCrossReference_2_1_1_0; }

		//ID
		public RuleCall getVarsIVariableIDTerminalRuleCall_2_1_1_0_1() { return cVarsIVariableIDTerminalRuleCall_2_1_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_4() { return cLeftParenthesisKeyword_4; }

		//(kexpressions+=Expression ("," kexpressions+=Expression)*)?
		public Group getGroup_5() { return cGroup_5; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_5_0() { return cKexpressionsAssignment_5_0; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_5_0_0() { return cKexpressionsExpressionParserRuleCall_5_0_0; }

		//("," kexpressions+=Expression)*
		public Group getGroup_5_1() { return cGroup_5_1; }

		//","
		public Keyword getCommaKeyword_5_1_0() { return cCommaKeyword_5_1_0; }

		//kexpressions+=Expression
		public Assignment getKexpressionsAssignment_5_1_1() { return cKexpressionsAssignment_5_1_1; }

		//Expression
		public RuleCall getKexpressionsExpressionParserRuleCall_5_1_1_0() { return cKexpressionsExpressionParserRuleCall_5_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}

	public class ExecCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ExecCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTaskAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cTaskTaskCrossReference_1_0 = (CrossReference)cTaskAssignment_1.eContents().get(0);
		private final RuleCall cTaskTaskIDTerminalRuleCall_1_0_1 = (RuleCall)cTaskTaskCrossReference_1_0.eContents().get(1);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyExecBodyParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		private final Keyword cReturnKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRetSignalAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cRetSignalISignalCrossReference_4_0 = (CrossReference)cRetSignalAssignment_4.eContents().get(0);
		private final RuleCall cRetSignalISignalIDTerminalRuleCall_4_0_1 = (RuleCall)cRetSignalISignalCrossReference_4_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cDoKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cStatementAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_5_1_0 = (RuleCall)cStatementAssignment_5_1.eContents().get(0);
		
		//ExecCase:
		//	"case" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?;
		public ParserRule getRule() { return rule; }

		//"case" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?
		public Group getGroup() { return cGroup; }

		//"case"
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }

		//task=[Task]
		public Assignment getTaskAssignment_1() { return cTaskAssignment_1; }

		//[Task]
		public CrossReference getTaskTaskCrossReference_1_0() { return cTaskTaskCrossReference_1_0; }

		//ID
		public RuleCall getTaskTaskIDTerminalRuleCall_1_0_1() { return cTaskTaskIDTerminalRuleCall_1_0_1; }

		//body=ExecBody
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//ExecBody
		public RuleCall getBodyExecBodyParserRuleCall_2_0() { return cBodyExecBodyParserRuleCall_2_0; }

		//"return"
		public Keyword getReturnKeyword_3() { return cReturnKeyword_3; }

		//retSignal=[kexpressions::ISignal]
		public Assignment getRetSignalAssignment_4() { return cRetSignalAssignment_4; }

		//[kexpressions::ISignal]
		public CrossReference getRetSignalISignalCrossReference_4_0() { return cRetSignalISignalCrossReference_4_0; }

		//ID
		public RuleCall getRetSignalISignalIDTerminalRuleCall_4_0_1() { return cRetSignalISignalIDTerminalRuleCall_4_0_1; }

		//("do" statement=Statement)?
		public Group getGroup_5() { return cGroup_5; }

		//"do"
		public Keyword getDoKeyword_5_0() { return cDoKeyword_5_0; }

		//statement=Statement
		public Assignment getStatementAssignment_5_1() { return cStatementAssignment_5_1; }

		//Statement
		public RuleCall getStatementStatementParserRuleCall_5_1_0() { return cStatementStatementParserRuleCall_5_1_0; }
	}

	public class TickElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Tick");
		private final Keyword cTickKeyword = (Keyword)rule.eContents().get(1);
		
		//// ==============================================
		//// === B.2 Namespaces and Predefined Objects  ===
		//// ==============================================
		//Tick:
		//	"tick";
		public ParserRule getRule() { return rule; }

		//"tick"
		public Keyword getTickKeyword() { return cTickKeyword; }
	}
	
	
	private ProgramElements pProgram;
	private ModuleElements pModule;
	private EndModuleElements pEndModule;
	private ModuleBodyElements pModuleBody;
	private ModuleInterfaceElements pModuleInterface;
	private ChannelDescriptionElements pChannelDescription;
	private EsterelTypeIdentifierElements pEsterelTypeIdentifier;
	private TypeIdentifierElements pTypeIdentifier;
	private LocalSignalDeclElements pLocalSignalDecl;
	private LocalSignalListElements pLocalSignalList;
	private SensorDeclElements pSensorDecl;
	private SensorWithTypeElements pSensorWithType;
	private SensorElements pSensor;
	private RelationDeclElements pRelationDecl;
	private RelationTypeElements pRelationType;
	private RelationImplicationElements pRelationImplication;
	private RelationIncompatibilityElements pRelationIncompatibility;
	private TypeDeclElements pTypeDecl;
	private TypeElements pType;
	private ConstantDeclsElements pConstantDecls;
	private OneTypeConstantDeclsElements pOneTypeConstantDecls;
	private ConstantWithValueElements pConstantWithValue;
	private ConstantElements pConstant;
	private ConstantAtomElements pConstantAtom;
	private ConstantLiteralElements pConstantLiteral;
	private FunctionDeclElements pFunctionDecl;
	private FunctionElements pFunction;
	private ProcedureDeclElements pProcedureDecl;
	private ProcedureElements pProcedure;
	private TaskDeclElements pTaskDecl;
	private TaskElements pTask;
	private StatementContainerElements pStatementContainer;
	private StatementContainerInterfaceElements pStatementContainerInterface;
	private StatementElements pStatement;
	private AtomicStatementElements pAtomicStatement;
	private SequenceElements pSequence;
	private BlockElements pBlock;
	private AssignmentElements pAssignment;
	private AbortElements pAbort;
	private AbortBodyElements pAbortBody;
	private AbortInstanceElements pAbortInstance;
	private AbortCaseElements pAbortCase;
	private AbortCaseSingleElements pAbortCaseSingle;
	private WeakAbortElements pWeakAbort;
	private WeakAbortBodyElements pWeakAbortBody;
	private WeakAbortEndElements pWeakAbortEnd;
	private WeakAbortEndAltElements pWeakAbortEndAlt;
	private WeakAbortInstanceElements pWeakAbortInstance;
	private WeakAbortCaseElements pWeakAbortCase;
	private AwaitElements pAwait;
	private AwaitBodyElements pAwaitBody;
	private AwaitInstanceElements pAwaitInstance;
	private AwaitCaseElements pAwaitCase;
	private AwaitEndElements pAwaitEnd;
	private ProcCallElements pProcCall;
	private DoElements pDo;
	private DoUptoElements pDoUpto;
	private DoWatchingElements pDoWatching;
	private DoWatchingEndElements pDoWatchingEnd;
	private EmitElements pEmit;
	private EveryDoElements pEveryDo;
	private ExitElements pExit;
	private HaltElements pHalt;
	private IfTestElements pIfTest;
	private ElsIfElements pElsIf;
	private ThenPartElements pThenPart;
	private ElsePartElements pElsePart;
	private LoopElements pLoop;
	private EndLoopElements pEndLoop;
	private LoopEachElements pLoopEach;
	private LoopDelayElements pLoopDelay;
	private LoopBodyElements pLoopBody;
	private NothingElements pNothing;
	private PauseElements pPause;
	private PresentElements pPresent;
	private PresentBodyElements pPresentBody;
	private PresentEventBodyElements pPresentEventBody;
	private PresentCaseListElements pPresentCaseList;
	private PresentCaseElements pPresentCase;
	private PresentEventElements pPresentEvent;
	private RepeatElements pRepeat;
	private RunElements pRun;
	private ModuleRenamingElements pModuleRenaming;
	private RenamingListElements pRenamingList;
	private RenamingElements pRenaming;
	private TypeRenamingElements pTypeRenaming;
	private ConstantRenamingElements pConstantRenaming;
	private FunctionRenamingElements pFunctionRenaming;
	private ProcedureRenamingElements pProcedureRenaming;
	private TaskRenamingElements pTaskRenaming;
	private SignalRenamingElements pSignalRenaming;
	private BuildInFunctionElements pBuildInFunction;
	private SuspendElements pSuspend;
	private SustainElements pSustain;
	private TrapElements pTrap;
	private TrapDeclListElements pTrapDeclList;
	private TrapDeclElements pTrapDecl;
	private TrapHandlerElements pTrapHandler;
	private LocalVariableElements pLocalVariable;
	private AtomicExpressionElements pAtomicExpression;
	private TrapExpressionElements pTrapExpression;
	private FunctionExpressionElements pFunctionExpression;
	private ConstantExpressionElements pConstantExpression;
	private TrapExprElements pTrapExpr;
	private SignalExpressionElements pSignalExpression;
	private SignalAndExpressionElements pSignalAndExpression;
	private SignalNotExpressionElements pSignalNotExpression;
	private SignalAtomicExpressionElements pSignalAtomicExpression;
	private SignalReferenceExprElements pSignalReferenceExpr;
	private SignalPreExprElements pSignalPreExpr;
	private TrapReferenceExprElements pTrapReferenceExpr;
	private DelayExprElements pDelayExpr;
	private DelayEventElements pDelayEvent;
	private ExecElements pExec;
	private ExecBodyElements pExecBody;
	private ExecCaseElements pExecCase;
	private TickElements pTick;
	private TerminalRule tEsterel_SL_Comment;
	private TerminalRule tEsterel_ML_Comment;
	private TerminalRule tSTRING;
	
	private final GrammarProvider grammarProvider;

	private KExpressionsGrammarAccess gaKExpressions;

	@Inject
	public EsterelGrammarAccess(GrammarProvider grammarProvider,
		KExpressionsGrammarAccess gaKExpressions) {
		this.grammarProvider = grammarProvider;
		this.gaKExpressions = gaKExpressions;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public KExpressionsGrammarAccess getKExpressionsGrammarAccess() {
		return gaKExpressions;
	}

	
	////	root rule. an esterel file can contain multiple modules
	//Program hidden(Esterel_SL_Comment, Esterel_ML_Comment, WS):
	//	modules+=Module*;
	public ProgramElements getProgramAccess() {
		return (pProgram != null) ? pProgram : (pProgram = new ProgramElements());
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//// a module consists of an interface and a body
	//// !-(module)
	//Module:
	//	"module" name=ID ":" interface=ModuleInterface? body=ModuleBody end=EndModule;
	public ModuleElements getModuleAccess() {
		return (pModule != null) ? pModule : (pModule = new ModuleElements());
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}

	////deprecated
	//EndModule:
	//	"end" "module" | ".";
	public EndModuleElements getEndModuleAccess() {
		return (pEndModule != null) ? pEndModule : (pEndModule = new EndModuleElements());
	}
	
	public ParserRule getEndModuleRule() {
		return getEndModuleAccess().getRule();
	}

	//ModuleBody:
	//	statements+=Statement;
	public ModuleBodyElements getModuleBodyAccess() {
		return (pModuleBody != null) ? pModuleBody : (pModuleBody = new ModuleBodyElements());
	}
	
	public ParserRule getModuleBodyRule() {
		return getModuleBodyAccess().getRule();
	}

	//// -!
	////            Interface Declarations
	//// ----------------------------------------------
	//ModuleInterface:
	//	(intSignalDecls+=InterfaceSignalDecl | intTypeDecls+=TypeDecl | intSensorDecls+=SensorDecl |
	//	intConstantDecls+=ConstantDecls | intRelationDecls+=RelationDecl | intTaskDecls+=TaskDecl |
	//	intFunctionDecls+=FunctionDecl | intProcedureDecls+=ProcedureDecl)+;
	public ModuleInterfaceElements getModuleInterfaceAccess() {
		return (pModuleInterface != null) ? pModuleInterface : (pModuleInterface = new ModuleInterfaceElements());
	}
	
	public ParserRule getModuleInterfaceRule() {
		return getModuleInterfaceAccess().getRule();
	}

	//// overwrite to add the EsterelTypeIdentifier
	//ChannelDescription:
	//	":" type=EsterelTypeIdentifier | "(" type=EsterelTypeIdentifier ")" | ":=" expression=Expression ":"
	//	type=EsterelTypeIdentifier;
	public ChannelDescriptionElements getChannelDescriptionAccess() {
		return (pChannelDescription != null) ? pChannelDescription : (pChannelDescription = new ChannelDescriptionElements());
	}
	
	public ParserRule getChannelDescriptionRule() {
		return getChannelDescriptionAccess().getRule();
	}

	//// overwrite to allow function references for signal declarations
	//EsterelTypeIdentifier returns kexpressions::TypeIdentifier:
	//	type=ValueType | typeID=ID | {EsterelTypeIdentifier} ("combine" (type=ValueType | typeID=ID) "with" (func=[Function] |
	//	operator=CombineOperator));
	public EsterelTypeIdentifierElements getEsterelTypeIdentifierAccess() {
		return (pEsterelTypeIdentifier != null) ? pEsterelTypeIdentifier : (pEsterelTypeIdentifier = new EsterelTypeIdentifierElements());
	}
	
	public ParserRule getEsterelTypeIdentifierRule() {
		return getEsterelTypeIdentifierAccess().getRule();
	}

	//// overwrite to allow type definitions in a specific module
	//TypeIdentifier:
	//	type=ValueType | typeID=ID | "combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator | {EsterelType}
	//	estType=[Type];
	public TypeIdentifierElements getTypeIdentifierAccess() {
		return (pTypeIdentifier != null) ? pTypeIdentifier : (pTypeIdentifier = new TypeIdentifierElements());
	}
	
	public ParserRule getTypeIdentifierRule() {
		return getTypeIdentifierAccess().getRule();
	}

	//// ==> Local Signal Declaration
	//// !-(localsignal) -------------------------------------
	//LocalSignalDecl:
	//	"signal" signalList=LocalSignalList "in" statement=Statement "end" optEnd="signal"?;
	public LocalSignalDeclElements getLocalSignalDeclAccess() {
		return (pLocalSignalDecl != null) ? pLocalSignalDecl : (pLocalSignalDecl = new LocalSignalDeclElements());
	}
	
	public ParserRule getLocalSignalDeclRule() {
		return getLocalSignalDeclAccess().getRule();
	}

	//LocalSignalList:
	//	{LocalSignal} signal+=ISignal ("," signal+=ISignal)*;
	public LocalSignalListElements getLocalSignalListAccess() {
		return (pLocalSignalList != null) ? pLocalSignalList : (pLocalSignalList = new LocalSignalListElements());
	}
	
	public ParserRule getLocalSignalListRule() {
		return getLocalSignalListAccess().getRule();
	}

	//// -!
	//// ==> Sensor
	//// -------------------------------------
	//SensorDecl:
	//	"sensor" sensors+=SensorWithType ("," sensors+=SensorWithType)* ";";
	public SensorDeclElements getSensorDeclAccess() {
		return (pSensorDecl != null) ? pSensorDecl : (pSensorDecl = new SensorDeclElements());
	}
	
	public ParserRule getSensorDeclRule() {
		return getSensorDeclAccess().getRule();
	}

	//SensorWithType:
	//	sensor=Sensor (":" type=TypeIdentifier) | sensor=Sensor "(" type=TypeIdentifier ")";
	public SensorWithTypeElements getSensorWithTypeAccess() {
		return (pSensorWithType != null) ? pSensorWithType : (pSensorWithType = new SensorWithTypeElements());
	}
	
	public ParserRule getSensorWithTypeRule() {
		return getSensorWithTypeAccess().getRule();
	}

	//Sensor returns kexpressions::ISignal:
	//	name=ID;
	public SensorElements getSensorAccess() {
		return (pSensor != null) ? pSensor : (pSensor = new SensorElements());
	}
	
	public ParserRule getSensorRule() {
		return getSensorAccess().getRule();
	}

	//// ==> Relations
	//// -------------------------------------
	//RelationDecl:
	//	{Relation} "relation" relations+=RelationType ("," relations+=RelationType)* ";";
	public RelationDeclElements getRelationDeclAccess() {
		return (pRelationDecl != null) ? pRelationDecl : (pRelationDecl = new RelationDeclElements());
	}
	
	public ParserRule getRelationDeclRule() {
		return getRelationDeclAccess().getRule();
	}

	//RelationType:
	//	RelationImplication | RelationIncompatibility;
	public RelationTypeElements getRelationTypeAccess() {
		return (pRelationType != null) ? pRelationType : (pRelationType = new RelationTypeElements());
	}
	
	public ParserRule getRelationTypeRule() {
		return getRelationTypeAccess().getRule();
	}

	//RelationImplication:
	//	first=[kexpressions::ISignal] type="=>" second=[kexpressions::ISignal];
	public RelationImplicationElements getRelationImplicationAccess() {
		return (pRelationImplication != null) ? pRelationImplication : (pRelationImplication = new RelationImplicationElements());
	}
	
	public ParserRule getRelationImplicationRule() {
		return getRelationImplicationAccess().getRule();
	}

	//RelationIncompatibility:
	//	incomp+=[kexpressions::ISignal] type="#" incomp+=[kexpressions::ISignal] ("#" incomp+=[kexpressions::ISignal])*;
	public RelationIncompatibilityElements getRelationIncompatibilityAccess() {
		return (pRelationIncompatibility != null) ? pRelationIncompatibility : (pRelationIncompatibility = new RelationIncompatibilityElements());
	}
	
	public ParserRule getRelationIncompatibilityRule() {
		return getRelationIncompatibilityAccess().getRule();
	}

	//// ==> Types
	//// -------------------------------------
	//TypeDecl:
	//	"type" types+=Type ("," types+=Type)* ";";
	public TypeDeclElements getTypeDeclAccess() {
		return (pTypeDecl != null) ? pTypeDecl : (pTypeDecl = new TypeDeclElements());
	}
	
	public ParserRule getTypeDeclRule() {
		return getTypeDeclAccess().getRule();
	}

	//Type:
	//	name=ID;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//// ==> Constants
	//// -------------------------------------
	//ConstantDecls:
	//	"constant" constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* ";";
	public ConstantDeclsElements getConstantDeclsAccess() {
		return (pConstantDecls != null) ? pConstantDecls : (pConstantDecls = new ConstantDeclsElements());
	}
	
	public ParserRule getConstantDeclsRule() {
		return getConstantDeclsAccess().getRule();
	}

	//OneTypeConstantDecls:
	//	constants+=ConstantWithValue ("," constants+=ConstantWithValue)* ":" type=TypeIdentifier;
	public OneTypeConstantDeclsElements getOneTypeConstantDeclsAccess() {
		return (pOneTypeConstantDecls != null) ? pOneTypeConstantDecls : (pOneTypeConstantDecls = new OneTypeConstantDeclsElements());
	}
	
	public ParserRule getOneTypeConstantDeclsRule() {
		return getOneTypeConstantDeclsAccess().getRule();
	}

	//ConstantWithValue:
	//	constant=Constant ("=" value=ConstantAtom)?;
	public ConstantWithValueElements getConstantWithValueAccess() {
		return (pConstantWithValue != null) ? pConstantWithValue : (pConstantWithValue = new ConstantWithValueElements());
	}
	
	public ParserRule getConstantWithValueRule() {
		return getConstantWithValueAccess().getRule();
	}

	//Constant returns kexpressions::ValuedObject:
	//	{Constant} name=ID;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//ConstantAtom:
	//	INT | ConstantLiteral;
	public ConstantAtomElements getConstantAtomAccess() {
		return (pConstantAtom != null) ? pConstantAtom : (pConstantAtom = new ConstantAtomElements());
	}
	
	public ParserRule getConstantAtomRule() {
		return getConstantAtomAccess().getRule();
	}

	//ConstantLiteral:
	//	Float | Boolean | ID | STRING;
	public ConstantLiteralElements getConstantLiteralAccess() {
		return (pConstantLiteral != null) ? pConstantLiteral : (pConstantLiteral = new ConstantLiteralElements());
	}
	
	public ParserRule getConstantLiteralRule() {
		return getConstantLiteralAccess().getRule();
	}

	//// ==> Functions
	//// -------------------------------------
	//FunctionDecl:
	//	"function" functions+=Function ("," functions+=Function)* ";";
	public FunctionDeclElements getFunctionDeclAccess() {
		return (pFunctionDecl != null) ? pFunctionDecl : (pFunctionDecl = new FunctionDeclElements());
	}
	
	public ParserRule getFunctionDeclRule() {
		return getFunctionDeclAccess().getRule();
	}

	//Function:
	//	name=ID "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" ":" type=TypeIdentifier;
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//// ==> Procedures
	//ProcedureDecl:
	//	"procedure" procedures+=Procedure ("," procedures+=Procedure)* ";";
	public ProcedureDeclElements getProcedureDeclAccess() {
		return (pProcedureDecl != null) ? pProcedureDecl : (pProcedureDecl = new ProcedureDeclElements());
	}
	
	public ParserRule getProcedureDeclRule() {
		return getProcedureDeclAccess().getRule();
	}

	//Procedure:
	//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
	//	idList2+=TypeIdentifier)*)? ")";
	public ProcedureElements getProcedureAccess() {
		return (pProcedure != null) ? pProcedure : (pProcedure = new ProcedureElements());
	}
	
	public ParserRule getProcedureRule() {
		return getProcedureAccess().getRule();
	}

	//// ==> Tasks
	//TaskDecl:
	//	"task" tasks+=Task ("," tasks+=Task)* ";";
	public TaskDeclElements getTaskDeclAccess() {
		return (pTaskDecl != null) ? pTaskDecl : (pTaskDecl = new TaskDeclElements());
	}
	
	public ParserRule getTaskDeclRule() {
		return getTaskDeclAccess().getRule();
	}

	//Task:
	//	name=ID "(" (idList1+=TypeIdentifier ("," idList1+=TypeIdentifier)*)? ")" "(" (idList2+=TypeIdentifier (","
	//	idList2+=TypeIdentifier)*)? ")";
	public TaskElements getTaskAccess() {
		return (pTask != null) ? pTask : (pTask = new TaskElements());
	}
	
	public ParserRule getTaskRule() {
		return getTaskAccess().getRule();
	}

	//StatementContainer:
	//	statement=Statement;
	public StatementContainerElements getStatementContainerAccess() {
		return (pStatementContainer != null) ? pStatementContainer : (pStatementContainer = new StatementContainerElements());
	}
	
	public ParserRule getStatementContainerRule() {
		return getStatementContainerAccess().getRule();
	}

	//StatementContainerInterface returns StatementContainer:
	//	LocalSignalDecl | Block | Abort | AbortInstance | AbortCaseSingle | WeakAbort | WeakAbortInstance | AwaitInstance | Do
	//	| DoWatchingEnd | EveryDo | ThenPart | ElsePart | LoopBody | PresentCase | Repeat | Suspend | Trap | TrapHandler |
	//	LocalVariable | Exec | ExecCase;
	public StatementContainerInterfaceElements getStatementContainerInterfaceAccess() {
		return (pStatementContainerInterface != null) ? pStatementContainerInterface : (pStatementContainerInterface = new StatementContainerInterfaceElements());
	}
	
	public ParserRule getStatementContainerInterfaceRule() {
		return getStatementContainerInterfaceAccess().getRule();
	}

	//// ==============================================
	//// ===            B.4 Statements              ===
	//// ==============================================
	//// !-(parallel)
	//Statement:
	//	Sequence ({Parallel.list+=current} "||" list+=Sequence)*;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//// -!
	//AtomicStatement returns Statement:
	//	Abort | Assignment | Await | Block | ProcCall | Do | Emit | EveryDo | Exit | Exec | Halt | IfTest | LocalSignalDecl |
	//	Loop | Nothing | Pause | Present | Repeat | Run | Suspend | Sustain | Trap | LocalVariable | WeakAbort;
	public AtomicStatementElements getAtomicStatementAccess() {
		return (pAtomicStatement != null) ? pAtomicStatement : (pAtomicStatement = new AtomicStatementElements());
	}
	
	public ParserRule getAtomicStatementRule() {
		return getAtomicStatementAccess().getRule();
	}

	//// --> B.4.1 Control Flow Operators <--	
	//// !-(sequence)
	//Sequence returns Statement:
	//	AtomicStatement ({Sequence.list+=current} ";" list+=AtomicStatement)* ";"?;
	public SequenceElements getSequenceAccess() {
		return (pSequence != null) ? pSequence : (pSequence = new SequenceElements());
	}
	
	public ParserRule getSequenceRule() {
		return getSequenceAccess().getRule();
	}

	//// -!
	//Block:
	//	"[" statement=Statement "]";
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// Assignment
	//// !-(assign) -------------------------------------
	//Assignment:
	//	var=[kexpressions::IVariable] ":=" expr=Expression;
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//// -!
	//// !-(abort) --> B.4.2 abort: Strong Preemption
	//// -------------------------------------
	//Abort:
	//	"abort" statement=Statement "when" body=AbortBody;
	public AbortElements getAbortAccess() {
		return (pAbort != null) ? pAbort : (pAbort = new AbortElements());
	}
	
	public ParserRule getAbortRule() {
		return getAbortAccess().getRule();
	}

	//AbortBody:
	//	AbortInstance | AbortCase;
	public AbortBodyElements getAbortBodyAccess() {
		return (pAbortBody != null) ? pAbortBody : (pAbortBody = new AbortBodyElements());
	}
	
	public ParserRule getAbortBodyRule() {
		return getAbortBodyAccess().getRule();
	}

	//AbortInstance:
	//	delay=DelayExpr ("do" statement=Statement "end" optEnd="abort"?)?;
	public AbortInstanceElements getAbortInstanceAccess() {
		return (pAbortInstance != null) ? pAbortInstance : (pAbortInstance = new AbortInstanceElements());
	}
	
	public ParserRule getAbortInstanceRule() {
		return getAbortInstanceAccess().getRule();
	}

	//AbortCase:
	//	cases+=AbortCaseSingle cases+=AbortCaseSingle* "end" optEnd="abort"?;
	public AbortCaseElements getAbortCaseAccess() {
		return (pAbortCase != null) ? pAbortCase : (pAbortCase = new AbortCaseElements());
	}
	
	public ParserRule getAbortCaseRule() {
		return getAbortCaseAccess().getRule();
	}

	//AbortCaseSingle:
	//	"case" delay=DelayExpr ("do" statement=Statement)?;
	public AbortCaseSingleElements getAbortCaseSingleAccess() {
		return (pAbortCaseSingle != null) ? pAbortCaseSingle : (pAbortCaseSingle = new AbortCaseSingleElements());
	}
	
	public ParserRule getAbortCaseSingleRule() {
		return getAbortCaseSingleAccess().getRule();
	}

	//// -!
	//// --> B.4.25 weak abort: Weak Preemption
	//// -------------------------------------
	//WeakAbort returns Abort:
	//	{WeakAbort} "weak" "abort" statement=Statement "when" body=WeakAbortBody;
	public WeakAbortElements getWeakAbortAccess() {
		return (pWeakAbort != null) ? pWeakAbort : (pWeakAbort = new WeakAbortElements());
	}
	
	public ParserRule getWeakAbortRule() {
		return getWeakAbortAccess().getRule();
	}

	//WeakAbortBody:
	//	WeakAbortInstance | WeakAbortCase;
	public WeakAbortBodyElements getWeakAbortBodyAccess() {
		return (pWeakAbortBody != null) ? pWeakAbortBody : (pWeakAbortBody = new WeakAbortBodyElements());
	}
	
	public ParserRule getWeakAbortBodyRule() {
		return getWeakAbortBodyAccess().getRule();
	}

	//WeakAbortEnd:
	//	{WeakAbortEnd} "end" optEnd=WeakAbortEndAlt?;
	public WeakAbortEndElements getWeakAbortEndAccess() {
		return (pWeakAbortEnd != null) ? pWeakAbortEnd : (pWeakAbortEnd = new WeakAbortEndElements());
	}
	
	public ParserRule getWeakAbortEndRule() {
		return getWeakAbortEndAccess().getRule();
	}

	//WeakAbortEndAlt:
	//	end="weak"? endA="abort";
	public WeakAbortEndAltElements getWeakAbortEndAltAccess() {
		return (pWeakAbortEndAlt != null) ? pWeakAbortEndAlt : (pWeakAbortEndAlt = new WeakAbortEndAltElements());
	}
	
	public ParserRule getWeakAbortEndAltRule() {
		return getWeakAbortEndAltAccess().getRule();
	}

	//WeakAbortInstance returns AbortInstance:
	//	{WeakAbortInstance} delay=DelayExpr ("do" statement=Statement end=WeakAbortEnd)?;
	public WeakAbortInstanceElements getWeakAbortInstanceAccess() {
		return (pWeakAbortInstance != null) ? pWeakAbortInstance : (pWeakAbortInstance = new WeakAbortInstanceElements());
	}
	
	public ParserRule getWeakAbortInstanceRule() {
		return getWeakAbortInstanceAccess().getRule();
	}

	//WeakAbortCase returns AbortCase:
	//	{WeakAbortCase} cases+=AbortCaseSingle cases+=AbortCaseSingle* end=WeakAbortEnd;
	public WeakAbortCaseElements getWeakAbortCaseAccess() {
		return (pWeakAbortCase != null) ? pWeakAbortCase : (pWeakAbortCase = new WeakAbortCaseElements());
	}
	
	public ParserRule getWeakAbortCaseRule() {
		return getWeakAbortCaseAccess().getRule();
	}

	//// --> B.4.3 await: Strong Preemption
	//// !-(await) -------------------------------------
	//Await:
	//	"await" body=AwaitBody;
	public AwaitElements getAwaitAccess() {
		return (pAwait != null) ? pAwait : (pAwait = new AwaitElements());
	}
	
	public ParserRule getAwaitRule() {
		return getAwaitAccess().getRule();
	}

	//AwaitBody:
	//	AwaitInstance | AwaitCase;
	public AwaitBodyElements getAwaitBodyAccess() {
		return (pAwaitBody != null) ? pAwaitBody : (pAwaitBody = new AwaitBodyElements());
	}
	
	public ParserRule getAwaitBodyRule() {
		return getAwaitBodyAccess().getRule();
	}

	//AwaitInstance:
	//	delay=DelayExpr ("do" statement=Statement end=AwaitEnd)?;
	public AwaitInstanceElements getAwaitInstanceAccess() {
		return (pAwaitInstance != null) ? pAwaitInstance : (pAwaitInstance = new AwaitInstanceElements());
	}
	
	public ParserRule getAwaitInstanceRule() {
		return getAwaitInstanceAccess().getRule();
	}

	//AwaitCase:
	//	cases+=AbortCaseSingle cases+=AbortCaseSingle* end=AwaitEnd;
	public AwaitCaseElements getAwaitCaseAccess() {
		return (pAwaitCase != null) ? pAwaitCase : (pAwaitCase = new AwaitCaseElements());
	}
	
	public ParserRule getAwaitCaseRule() {
		return getAwaitCaseAccess().getRule();
	}

	//AwaitEnd:
	//	"end" "await"?;
	public AwaitEndElements getAwaitEndAccess() {
		return (pAwaitEnd != null) ? pAwaitEnd : (pAwaitEnd = new AwaitEndElements());
	}
	
	public ParserRule getAwaitEndRule() {
		return getAwaitEndAccess().getRule();
	}

	//// -!
	//// --> B.4.4 call: Procedure Call
	//// -------------------------------------
	//ProcCall:
	//	"call" proc=[Procedure] "(" (varList+=[kexpressions::IVariable] ("," varList+=[kexpressions::IVariable])*)? ")" "("
	//	(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
	public ProcCallElements getProcCallAccess() {
		return (pProcCall != null) ? pProcCall : (pProcCall = new ProcCallElements());
	}
	
	public ParserRule getProcCallRule() {
		return getProcCallAccess().getRule();
	}

	//// --> B.4.5 do-upto: Conditional Iteration (deprecated)
	//// --> B.4.6 do-watching: Strong Preemption (deprecated)
	//// !-(doupto) -------------------------------------
	//Do:
	//	"do" statement=Statement (end=DoUpto | end=DoWatching);
	public DoElements getDoAccess() {
		return (pDo != null) ? pDo : (pDo = new DoElements());
	}
	
	public ParserRule getDoRule() {
		return getDoAccess().getRule();
	}

	//DoUpto:
	//	"upto" expr=DelayExpr;
	public DoUptoElements getDoUptoAccess() {
		return (pDoUpto != null) ? pDoUpto : (pDoUpto = new DoUptoElements());
	}
	
	public ParserRule getDoUptoRule() {
		return getDoUptoAccess().getRule();
	}

	//DoWatching:
	//	"watching" delay=DelayExpr end=DoWatchingEnd?;
	public DoWatchingElements getDoWatchingAccess() {
		return (pDoWatching != null) ? pDoWatching : (pDoWatching = new DoWatchingElements());
	}
	
	public ParserRule getDoWatchingRule() {
		return getDoWatchingAccess().getRule();
	}

	//DoWatchingEnd:
	//	"timeout" statement=Statement "end" optEnd="timeout"?;
	public DoWatchingEndElements getDoWatchingEndAccess() {
		return (pDoWatchingEnd != null) ? pDoWatchingEnd : (pDoWatchingEnd = new DoWatchingEndElements());
	}
	
	public ParserRule getDoWatchingEndRule() {
		return getDoWatchingEndAccess().getRule();
	}

	//// -!
	//// --> B.4.7 emit: Signal Emission <--
	//// !-(emit)2 -------------------------------------
	//Emit:
	//	"emit" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expr=Expression ")")?;
	public EmitElements getEmitAccess() {
		return (pEmit != null) ? pEmit : (pEmit = new EmitElements());
	}
	
	public ParserRule getEmitRule() {
		return getEmitAccess().getRule();
	}

	//// -!
	//// --> B.4.8 every-do: Conditional Iteration
	//// !-(every)-------------------------------------
	//EveryDo:
	//	"every" delay=DelayExpr "do" statement=Statement "end" optEnd="every"?;
	public EveryDoElements getEveryDoAccess() {
		return (pEveryDo != null) ? pEveryDo : (pEveryDo = new EveryDoElements());
	}
	
	public ParserRule getEveryDoRule() {
		return getEveryDoAccess().getRule();
	}

	//// -!
	//// --> B.4.10 exit: Trap Exit
	//// !-(exit) -------------------------------------
	//Exit:
	//	"exit" trap=[TrapDecl] ("(" expression=Expression ")")?;
	public ExitElements getExitAccess() {
		return (pExit != null) ? pExit : (pExit = new ExitElements());
	}
	
	public ParserRule getExitRule() {
		return getExitAccess().getRule();
	}

	//// -!
	//// --> B.4.11 halt: Wait Forever
	//// !-(halt) -------------------------------------
	//Halt:
	//	{Halt} "halt";
	public HaltElements getHaltAccess() {
		return (pHalt != null) ? pHalt : (pHalt = new HaltElements());
	}
	
	public ParserRule getHaltRule() {
		return getHaltAccess().getRule();
	}

	//// -!
	//// --> B.4.12: if: Conditional for Data
	//// !-(if)-------------------------------------
	//IfTest:
	//	"if" expr=Expression thenPart=ThenPart? elsif+=ElsIf* elsePart=ElsePart? "end" optEnd="if"?;
	public IfTestElements getIfTestAccess() {
		return (pIfTest != null) ? pIfTest : (pIfTest = new IfTestElements());
	}
	
	public ParserRule getIfTestRule() {
		return getIfTestAccess().getRule();
	}

	//ElsIf:
	//	"elsif" expr=Expression thenPart=ThenPart?;
	public ElsIfElements getElsIfAccess() {
		return (pElsIf != null) ? pElsIf : (pElsIf = new ElsIfElements());
	}
	
	public ParserRule getElsIfRule() {
		return getElsIfAccess().getRule();
	}

	//ThenPart:
	//	"then" statement=Statement;
	public ThenPartElements getThenPartAccess() {
		return (pThenPart != null) ? pThenPart : (pThenPart = new ThenPartElements());
	}
	
	public ParserRule getThenPartRule() {
		return getThenPartAccess().getRule();
	}

	//ElsePart:
	//	"else" statement=Statement;
	public ElsePartElements getElsePartAccess() {
		return (pElsePart != null) ? pElsePart : (pElsePart = new ElsePartElements());
	}
	
	public ParserRule getElsePartRule() {
		return getElsePartAccess().getRule();
	}

	//// -!
	//// --> B.4.13 loop: Infinite Loop
	//// --> B.4.14 loop-each: Condition Iteration
	//// !-(loop)-------------------------------------
	//Loop:
	//	"loop" body=LoopBody (end1=EndLoop | end=LoopEach);
	public LoopElements getLoopAccess() {
		return (pLoop != null) ? pLoop : (pLoop = new LoopElements());
	}
	
	public ParserRule getLoopRule() {
		return getLoopAccess().getRule();
	}

	//EndLoop:
	//	{EndLoop} "end" endOpt="loop"?;
	public EndLoopElements getEndLoopAccess() {
		return (pEndLoop != null) ? pEndLoop : (pEndLoop = new EndLoopElements());
	}
	
	public ParserRule getEndLoopRule() {
		return getEndLoopAccess().getRule();
	}

	//LoopEach:
	//	"each" LoopDelay;
	public LoopEachElements getLoopEachAccess() {
		return (pLoopEach != null) ? pLoopEach : (pLoopEach = new LoopEachElements());
	}
	
	public ParserRule getLoopEachRule() {
		return getLoopEachAccess().getRule();
	}

	//LoopDelay:
	//	delay=DelayExpr;
	public LoopDelayElements getLoopDelayAccess() {
		return (pLoopDelay != null) ? pLoopDelay : (pLoopDelay = new LoopDelayElements());
	}
	
	public ParserRule getLoopDelayRule() {
		return getLoopDelayAccess().getRule();
	}

	//LoopBody:
	//	statement=Statement;
	public LoopBodyElements getLoopBodyAccess() {
		return (pLoopBody != null) ? pLoopBody : (pLoopBody = new LoopBodyElements());
	}
	
	public ParserRule getLoopBodyRule() {
		return getLoopBodyAccess().getRule();
	}

	//// -!
	//// --> B.4.15 nothing: No Operation
	//// !-(nothing) -------------------------------------
	//Nothing:
	//	"nothing" {Nothing};
	public NothingElements getNothingAccess() {
		return (pNothing != null) ? pNothing : (pNothing = new NothingElements());
	}
	
	public ParserRule getNothingRule() {
		return getNothingAccess().getRule();
	}

	//// -!
	//// --> B.4.16 pause: Unit Delay
	//// !-(pause) -------------------------------------
	//Pause:
	//	"pause" {Pause};
	public PauseElements getPauseAccess() {
		return (pPause != null) ? pPause : (pPause = new PauseElements());
	}
	
	public ParserRule getPauseRule() {
		return getPauseAccess().getRule();
	}

	//// -!
	//// --> B.4.17 present: Conditional for Signals
	//// !-(present) -------------------------------------
	//Present:
	//	"present" body=PresentBody elsePart=ElsePart? "end" optEnd="present"?;
	public PresentElements getPresentAccess() {
		return (pPresent != null) ? pPresent : (pPresent = new PresentElements());
	}
	
	public ParserRule getPresentRule() {
		return getPresentAccess().getRule();
	}

	//PresentBody:
	//	PresentEventBody | PresentCaseList;
	public PresentBodyElements getPresentBodyAccess() {
		return (pPresentBody != null) ? pPresentBody : (pPresentBody = new PresentBodyElements());
	}
	
	public ParserRule getPresentBodyRule() {
		return getPresentBodyAccess().getRule();
	}

	//PresentEventBody:
	//	event=PresentEvent thenPart=ThenPart?;
	public PresentEventBodyElements getPresentEventBodyAccess() {
		return (pPresentEventBody != null) ? pPresentEventBody : (pPresentEventBody = new PresentEventBodyElements());
	}
	
	public ParserRule getPresentEventBodyRule() {
		return getPresentEventBodyAccess().getRule();
	}

	//PresentCaseList:
	//	cases+=PresentCase cases+=PresentCase*;
	public PresentCaseListElements getPresentCaseListAccess() {
		return (pPresentCaseList != null) ? pPresentCaseList : (pPresentCaseList = new PresentCaseListElements());
	}
	
	public ParserRule getPresentCaseListRule() {
		return getPresentCaseListAccess().getRule();
	}

	//PresentCase:
	//	"case" event=PresentEvent ("do" statement=Statement)?;
	public PresentCaseElements getPresentCaseAccess() {
		return (pPresentCase != null) ? pPresentCase : (pPresentCase = new PresentCaseElements());
	}
	
	public ParserRule getPresentCaseRule() {
		return getPresentCaseAccess().getRule();
	}

	//PresentEvent:
	//	expression=SignalExpression | fB="[" expression=SignalExpression eB="]" | tick=Tick;
	public PresentEventElements getPresentEventAccess() {
		return (pPresentEvent != null) ? pPresentEvent : (pPresentEvent = new PresentEventElements());
	}
	
	public ParserRule getPresentEventRule() {
		return getPresentEventAccess().getRule();
	}

	//// -!
	//// --> B.4.18 repeat: Iterate a Fixed Number of Times
	//// -------------------------------------
	//Repeat:
	//	positive?="positive"? "repeat" expression=Expression "times" statement=Statement "end" optEnd="repeat"?;
	public RepeatElements getRepeatAccess() {
		return (pRepeat != null) ? pRepeat : (pRepeat = new RepeatElements());
	}
	
	public ParserRule getRepeatRule() {
		return getRepeatAccess().getRule();
	}

	//// --> B.4.19 run: Module Instantiation
	//// -------------------------------------
	////deprecated
	//Run:
	//	"run" module=ModuleRenaming ("[" list=RenamingList "]")? | "copymodule" module=ModuleRenaming ("[" list=RenamingList
	//	"]")?;
	public RunElements getRunAccess() {
		return (pRun != null) ? pRun : (pRun = new RunElements());
	}
	
	public ParserRule getRunRule() {
		return getRunAccess().getRule();
	}

	//// Renamings
	//// -------------------------------------
	//ModuleRenaming:
	//	module=[Module] | newName=ID "/" module=[Module];
	public ModuleRenamingElements getModuleRenamingAccess() {
		return (pModuleRenaming != null) ? pModuleRenaming : (pModuleRenaming = new ModuleRenamingElements());
	}
	
	public ParserRule getModuleRenamingRule() {
		return getModuleRenamingAccess().getRule();
	}

	//RenamingList:
	//	list+=Renaming (";" list+=Renaming)*;
	public RenamingListElements getRenamingListAccess() {
		return (pRenamingList != null) ? pRenamingList : (pRenamingList = new RenamingListElements());
	}
	
	public ParserRule getRenamingListRule() {
		return getRenamingListAccess().getRule();
	}

	//Renaming:
	//	"type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)* | "constant" renamings+=ConstantRenaming (","
	//	renamings+=ConstantRenaming)* | "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)* |
	//	"procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)* | "task" renamings+=TaskRenaming (","
	//	renamings+=TaskRenaming)* | "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)*;
	public RenamingElements getRenamingAccess() {
		return (pRenaming != null) ? pRenaming : (pRenaming = new RenamingElements());
	}
	
	public ParserRule getRenamingRule() {
		return getRenamingAccess().getRule();
	}

	//TypeRenaming:
	//	(newName=[Type] | newType=ValueType) "/" oldName=[Type];
	public TypeRenamingElements getTypeRenamingAccess() {
		return (pTypeRenaming != null) ? pTypeRenaming : (pTypeRenaming = new TypeRenamingElements());
	}
	
	public ParserRule getTypeRenamingRule() {
		return getTypeRenamingAccess().getRule();
	}

	//ConstantRenaming:
	//	(newName=[kexpressions::ValuedObject] | newValue=ConstantAtom) "/" oldName=[kexpressions::ValuedObject];
	public ConstantRenamingElements getConstantRenamingAccess() {
		return (pConstantRenaming != null) ? pConstantRenaming : (pConstantRenaming = new ConstantRenamingElements());
	}
	
	public ParserRule getConstantRenamingRule() {
		return getConstantRenamingAccess().getRule();
	}

	//FunctionRenaming:
	//	(newName=[Function] | newFunc=BuildInFunction) "/" oldName=[Function];
	public FunctionRenamingElements getFunctionRenamingAccess() {
		return (pFunctionRenaming != null) ? pFunctionRenaming : (pFunctionRenaming = new FunctionRenamingElements());
	}
	
	public ParserRule getFunctionRenamingRule() {
		return getFunctionRenamingAccess().getRule();
	}

	//ProcedureRenaming:
	//	newName=[Procedure] "/" oldName=[Procedure];
	public ProcedureRenamingElements getProcedureRenamingAccess() {
		return (pProcedureRenaming != null) ? pProcedureRenaming : (pProcedureRenaming = new ProcedureRenamingElements());
	}
	
	public ParserRule getProcedureRenamingRule() {
		return getProcedureRenamingAccess().getRule();
	}

	//TaskRenaming:
	//	newName=[Task] "/" oldName=[Task];
	public TaskRenamingElements getTaskRenamingAccess() {
		return (pTaskRenaming != null) ? pTaskRenaming : (pTaskRenaming = new TaskRenamingElements());
	}
	
	public ParserRule getTaskRenamingRule() {
		return getTaskRenamingAccess().getRule();
	}

	//SignalRenaming:
	//	(newName=[kexpressions::ISignal] | "tick") "/" oldName=[kexpressions::ISignal];
	public SignalRenamingElements getSignalRenamingAccess() {
		return (pSignalRenaming != null) ? pSignalRenaming : (pSignalRenaming = new SignalRenamingElements());
	}
	
	public ParserRule getSignalRenamingRule() {
		return getSignalRenamingAccess().getRule();
	}

	//// renamings can also rename build in types and functions
	//BuildInFunction:
	//	"*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or";
	public BuildInFunctionElements getBuildInFunctionAccess() {
		return (pBuildInFunction != null) ? pBuildInFunction : (pBuildInFunction = new BuildInFunctionElements());
	}
	
	public ParserRule getBuildInFunctionRule() {
		return getBuildInFunctionAccess().getRule();
	}

	//// --> B.4.21 suspend: Preemption with State Freeze
	//// !-(suspend)-------------------------------------
	//Suspend:
	//	"suspend" statement=Statement "when" delay=DelayExpr;
	public SuspendElements getSuspendAccess() {
		return (pSuspend != null) ? pSuspend : (pSuspend = new SuspendElements());
	}
	
	public ParserRule getSuspendRule() {
		return getSuspendAccess().getRule();
	}

	//// -!
	//// --> B.4.22 sustain: Emit a Signal Indefinitely
	//// !-(sustain) -------------------------------------
	//Sustain:
	//	"sustain" (signal=[kexpressions::ISignal] | tick=Tick) ("(" expression=Expression ")")?;
	public SustainElements getSustainAccess() {
		return (pSustain != null) ? pSustain : (pSustain = new SustainElements());
	}
	
	public ParserRule getSustainRule() {
		return getSustainAccess().getRule();
	}

	//// -!
	//// --> B.4.23 trap: TrapDeclaration and Handling
	//// !-(trap)-------------------------------------
	//Trap:
	//	"trap" trapDeclList=TrapDeclList "in" statement=Statement trapHandler+=TrapHandler* "end" optEnd="trap"?;
	public TrapElements getTrapAccess() {
		return (pTrap != null) ? pTrap : (pTrap = new TrapElements());
	}
	
	public ParserRule getTrapRule() {
		return getTrapAccess().getRule();
	}

	//TrapDeclList:
	//	trapDecls+=TrapDecl ("," trapDecls+=TrapDecl)*;
	public TrapDeclListElements getTrapDeclListAccess() {
		return (pTrapDeclList != null) ? pTrapDeclList : (pTrapDeclList = new TrapDeclListElements());
	}
	
	public ParserRule getTrapDeclListRule() {
		return getTrapDeclListAccess().getRule();
	}

	//TrapDecl returns kexpressions::ISignal:
	//	{TrapDecl} name=ID channelDescr=ChannelDescription?;
	public TrapDeclElements getTrapDeclAccess() {
		return (pTrapDecl != null) ? pTrapDecl : (pTrapDecl = new TrapDeclElements());
	}
	
	public ParserRule getTrapDeclRule() {
		return getTrapDeclAccess().getRule();
	}

	//TrapHandler:
	//	"handle" trapExpr=TrapExpr "do" statement=Statement;
	public TrapHandlerElements getTrapHandlerAccess() {
		return (pTrapHandler != null) ? pTrapHandler : (pTrapHandler = new TrapHandlerElements());
	}
	
	public ParserRule getTrapHandlerRule() {
		return getTrapHandlerAccess().getRule();
	}

	//// -!
	//// --> B.4.24 var: Local Variable Declaration
	//// !-(localvariable) -------------------------------------
	//LocalVariable:
	//	var=InterfaceVariableDecl "in" statement=Statement "end" optEnd="var"?;
	public LocalVariableElements getLocalVariableAccess() {
		return (pLocalVariable != null) ? pLocalVariable : (pLocalVariable = new LocalVariableElements());
	}
	
	public ParserRule getLocalVariableRule() {
		return getLocalVariableAccess().getRule();
	}

	//// -!
	//// ==============================================
	//// ===            B.3 Expressions             ===
	//// ==============================================
	//// esterel is a bit richer than what is provided by kexpressions. These rules are introduced here
	//// care about order of the rules! 
	//AtomicExpression returns kexpressions::Expression:
	//	FunctionExpression | TrapExpression | BooleanValue | ValuedObjectTestExpression | TextExpression | "("
	//	BooleanExpression ")" | ConstantExpression;
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return (pAtomicExpression != null) ? pAtomicExpression : (pAtomicExpression = new AtomicExpressionElements());
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}

	//TrapExpression returns kexpressions::Expression:
	//	{TrapExpression} "??" trap=[kexpressions::ISignal];
	public TrapExpressionElements getTrapExpressionAccess() {
		return (pTrapExpression != null) ? pTrapExpression : (pTrapExpression = new TrapExpressionElements());
	}
	
	public ParserRule getTrapExpressionRule() {
		return getTrapExpressionAccess().getRule();
	}

	//FunctionExpression returns kexpressions::Expression:
	//	{FunctionExpression} function=[Function] "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
	public FunctionExpressionElements getFunctionExpressionAccess() {
		return (pFunctionExpression != null) ? pFunctionExpression : (pFunctionExpression = new FunctionExpressionElements());
	}
	
	public ParserRule getFunctionExpressionRule() {
		return getFunctionExpressionAccess().getRule();
	}

	//ConstantExpression returns kexpressions::Expression:
	//	{ConstantExpression} (constant=[Constant] | value=ConstantAtom);
	public ConstantExpressionElements getConstantExpressionAccess() {
		return (pConstantExpression != null) ? pConstantExpression : (pConstantExpression = new ConstantExpressionElements());
	}
	
	public ParserRule getConstantExpressionRule() {
		return getConstantExpressionAccess().getRule();
	}

	//// --> B.3.5 Trap Expressions <--
	//// -------------------------------------
	//TrapExpr returns kexpressions::Expression:
	//	SignalExpression;
	public TrapExprElements getTrapExprAccess() {
		return (pTrapExpr != null) ? pTrapExpr : (pTrapExpr = new TrapExprElements());
	}
	
	public ParserRule getTrapExprRule() {
		return getTrapExprAccess().getRule();
	}

	//// --> B.3.3 Signal Expressions <--
	//// -------------------------------------
	//SignalExpression returns kexpressions::Expression:
	//	SignalAndExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=OrOperator
	//	subExpressions+=SignalAndExpression)*;
	public SignalExpressionElements getSignalExpressionAccess() {
		return (pSignalExpression != null) ? pSignalExpression : (pSignalExpression = new SignalExpressionElements());
	}
	
	public ParserRule getSignalExpressionRule() {
		return getSignalExpressionAccess().getRule();
	}

	//SignalAndExpression returns kexpressions::Expression:
	//	SignalNotExpression ({kexpressions::OperatorExpression.subExpressions+=current} operator=AndOperator
	//	subExpressions+=SignalNotExpression)*;
	public SignalAndExpressionElements getSignalAndExpressionAccess() {
		return (pSignalAndExpression != null) ? pSignalAndExpression : (pSignalAndExpression = new SignalAndExpressionElements());
	}
	
	public ParserRule getSignalAndExpressionRule() {
		return getSignalAndExpressionAccess().getRule();
	}

	//SignalNotExpression returns kexpressions::Expression:
	//	{kexpressions::OperatorExpression} operator=NotOperator subExpressions+=SignalNotExpression | SignalAtomicExpression;
	public SignalNotExpressionElements getSignalNotExpressionAccess() {
		return (pSignalNotExpression != null) ? pSignalNotExpression : (pSignalNotExpression = new SignalNotExpressionElements());
	}
	
	public ParserRule getSignalNotExpressionRule() {
		return getSignalNotExpressionAccess().getRule();
	}

	//SignalAtomicExpression returns kexpressions::Expression:
	//	SignalReferenceExpr | "(" SignalExpression ")" | SignalPreExpr | // maybe place this somewhere else 
	//	TrapReferenceExpr;
	public SignalAtomicExpressionElements getSignalAtomicExpressionAccess() {
		return (pSignalAtomicExpression != null) ? pSignalAtomicExpression : (pSignalAtomicExpression = new SignalAtomicExpressionElements());
	}
	
	public ParserRule getSignalAtomicExpressionRule() {
		return getSignalAtomicExpressionAccess().getRule();
	}

	//SignalReferenceExpr returns kexpressions::ValuedObjectReference:
	//	valuedObject=[kexpressions::ISignal];
	public SignalReferenceExprElements getSignalReferenceExprAccess() {
		return (pSignalReferenceExpr != null) ? pSignalReferenceExpr : (pSignalReferenceExpr = new SignalReferenceExprElements());
	}
	
	public ParserRule getSignalReferenceExprRule() {
		return getSignalReferenceExprAccess().getRule();
	}

	//SignalPreExpr returns kexpressions::Expression:
	//	{kexpressions::OperatorExpression} operator=PreOperator "(" subExpressions+=SignalReferenceExpr ")";
	public SignalPreExprElements getSignalPreExprAccess() {
		return (pSignalPreExpr != null) ? pSignalPreExpr : (pSignalPreExpr = new SignalPreExprElements());
	}
	
	public ParserRule getSignalPreExprRule() {
		return getSignalPreExprAccess().getRule();
	}

	//TrapReferenceExpr returns kexpressions::ValuedObjectReference:
	//	{TrapReferenceExpr} valuedObject=[TrapDecl];
	public TrapReferenceExprElements getTrapReferenceExprAccess() {
		return (pTrapReferenceExpr != null) ? pTrapReferenceExpr : (pTrapReferenceExpr = new TrapReferenceExprElements());
	}
	
	public ParserRule getTrapReferenceExprRule() {
		return getTrapReferenceExprAccess().getRule();
	}

	//// --> B.3.4 Delay Expressions <--
	//// -------------------------------------
	//DelayExpr:
	//	expr=Expression event=DelayEvent | event=DelayEvent | isImmediate?="immediate" event=DelayEvent;
	public DelayExprElements getDelayExprAccess() {
		return (pDelayExpr != null) ? pDelayExpr : (pDelayExpr = new DelayExprElements());
	}
	
	public ParserRule getDelayExprRule() {
		return getDelayExprAccess().getRule();
	}

	//DelayEvent:
	//	tick=Tick | expr=SignalReferenceExpr | fB="[" expr=SignalExpression eB="]";
	public DelayEventElements getDelayEventAccess() {
		return (pDelayEvent != null) ? pDelayEvent : (pDelayEvent = new DelayEventElements());
	}
	
	public ParserRule getDelayEventRule() {
		return getDelayEventAccess().getRule();
	}

	//// --> Exec
	//// -------------------------------------
	//Exec:
	//	("exec" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)? | "exec"
	//	execCaseList+=ExecCase execCaseList+=ExecCase*) "end" optEnd="exec"?;
	public ExecElements getExecAccess() {
		return (pExec != null) ? pExec : (pExec = new ExecElements());
	}
	
	public ParserRule getExecRule() {
		return getExecAccess().getRule();
	}

	//ExecBody:
	//	{ExecBody} "(" (vars+=[kexpressions::IVariable] ("," vars+=[kexpressions::IVariable])*)? ")" "("
	//	(kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";
	public ExecBodyElements getExecBodyAccess() {
		return (pExecBody != null) ? pExecBody : (pExecBody = new ExecBodyElements());
	}
	
	public ParserRule getExecBodyRule() {
		return getExecBodyAccess().getRule();
	}

	//ExecCase:
	//	"case" task=[Task] body=ExecBody "return" retSignal=[kexpressions::ISignal] ("do" statement=Statement)?;
	public ExecCaseElements getExecCaseAccess() {
		return (pExecCase != null) ? pExecCase : (pExecCase = new ExecCaseElements());
	}
	
	public ParserRule getExecCaseRule() {
		return getExecCaseAccess().getRule();
	}

	//// ==============================================
	//// === B.2 Namespaces and Predefined Objects  ===
	//// ==============================================
	//Tick:
	//	"tick";
	public TickElements getTickAccess() {
		return (pTick != null) ? pTick : (pTick = new TickElements());
	}
	
	public ParserRule getTickRule() {
		return getTickAccess().getRule();
	}

	//terminal Esterel_SL_Comment:
	//	"%" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getEsterel_SL_CommentRule() {
		return (tEsterel_SL_Comment != null) ? tEsterel_SL_Comment : (tEsterel_SL_Comment = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "Esterel_SL_Comment"));
	} 

	//terminal Esterel_ML_Comment:
	//	("%" "{")->("}" "%");
	public TerminalRule getEsterel_ML_CommentRule() {
		return (tEsterel_ML_Comment != null) ? tEsterel_ML_Comment : (tEsterel_ML_Comment = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "Esterel_ML_Comment"));
	} 

	//// allow escaping by double quotes ( "this is a ""quote"", how nice." ) - esterelstyle
	//terminal STRING:
	//	"\"" (!"\"" | "\"" "\"")* "\"";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//Root returns ecore::EObject:
	//	Expression | InterfaceDeclaration;
	public KExpressionsGrammarAccess.RootElements getRootAccess() {
		return gaKExpressions.getRootAccess();
	}
	
	public ParserRule getRootRule() {
		return getRootAccess().getRule();
	}

	////Variable returns annotations::Annotatable:
	////    (annotations += StringAnnotation)*;
	//// --------------------------
	////
	////   EXPRESSIONS
	////
	//// --------------------------
	//Expression:
	//	BooleanExpression | ValuedExpression;
	public KExpressionsGrammarAccess.ExpressionElements getExpressionAccess() {
		return gaKExpressions.getExpressionAccess();
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// Example: not D and C or ?E = 42 or not (A and (B or C))
	//BooleanExpression returns Expression:
	//	OrExpression;
	public KExpressionsGrammarAccess.BooleanExpressionElements getBooleanExpressionAccess() {
		return gaKExpressions.getBooleanExpressionAccess();
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}

	//// Example: A or B, A and B and C, C and B or D and not E, A and B and C
	//OrExpression returns Expression:
	//	AndExpression ({OperatorExpression.subExpressions+=current} operator=OrOperator subExpressions+=AndExpression)*;
	public KExpressionsGrammarAccess.OrExpressionElements getOrExpressionAccess() {
		return gaKExpressions.getOrExpressionAccess();
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//// Example: A and B, not C and 42 <= ?D
	//AndExpression returns Expression:
	//	CompareOperation ({OperatorExpression.subExpressions+=current} operator=AndOperator
	//	subExpressions+=CompareOperation)*;
	public KExpressionsGrammarAccess.AndExpressionElements getAndExpressionAccess() {
		return gaKExpressions.getAndExpressionAccess();
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//// Example: 42 <= ?A
	//CompareOperation returns Expression:
	//	NotOrValuedExpression ({OperatorExpression.subExpressions+=current} operator=CompareOperator
	//	subExpressions+=NotOrValuedExpression) | NotExpression;
	public KExpressionsGrammarAccess.CompareOperationElements getCompareOperationAccess() {
		return gaKExpressions.getCompareOperationAccess();
	}
	
	public ParserRule getCompareOperationRule() {
		return getCompareOperationAccess().getRule();
	}

	//// order IS IMPORTANT
	//NotOrValuedExpression returns Expression:
	//	ValuedExpression | NotExpression;
	public KExpressionsGrammarAccess.NotOrValuedExpressionElements getNotOrValuedExpressionAccess() {
		return gaKExpressions.getNotOrValuedExpressionAccess();
	}
	
	public ParserRule getNotOrValuedExpressionRule() {
		return getNotOrValuedExpressionAccess().getRule();
	}

	//// Example: not A, not false, not (A or B)
	//// at the latter we need the parans to indicate the right binding
	//NotExpression returns Expression:
	//	{OperatorExpression} operator=NotOperator subExpressions+=NotExpression | AtomicExpression;
	public KExpressionsGrammarAccess.NotExpressionElements getNotExpressionAccess() {
		return gaKExpressions.getNotExpressionAccess();
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//// everything that evaluates to a primitive number value
	//ValuedExpression returns Expression:
	//	AddExpression;
	public KExpressionsGrammarAccess.ValuedExpressionElements getValuedExpressionAccess() {
		return gaKExpressions.getValuedExpressionAccess();
	}
	
	public ParserRule getValuedExpressionRule() {
		return getValuedExpressionAccess().getRule();
	}

	//// Example: 1 + 2
	//AddExpression returns Expression:
	//	SubExpression ({OperatorExpression.subExpressions+=current} operator=AddOperator subExpressions+=SubExpression)*;
	public KExpressionsGrammarAccess.AddExpressionElements getAddExpressionAccess() {
		return gaKExpressions.getAddExpressionAccess();
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}

	//// Example: varA - ?B
	//SubExpression returns Expression:
	//	MultExpression ({OperatorExpression.subExpressions+=current} operator=SubOperator subExpressions+=MultExpression)*;
	public KExpressionsGrammarAccess.SubExpressionElements getSubExpressionAccess() {
		return gaKExpressions.getSubExpressionAccess();
	}
	
	public ParserRule getSubExpressionRule() {
		return getSubExpressionAccess().getRule();
	}

	////    ({OperatorExpression} subExpressions+=MultExpression (operator=SubOperator subExpressions+=MultExpression)+)
	////	| ({OperatorExpression} subExpressions+=MultExpression subExpressions+=NIntValue)
	////    | MultExpression;
	//// Example: 2 * 4
	//MultExpression returns Expression:
	//	DivExpression ({OperatorExpression.subExpressions+=current} operator=MultOperator subExpressions+=DivExpression)*;
	public KExpressionsGrammarAccess.MultExpressionElements getMultExpressionAccess() {
		return gaKExpressions.getMultExpressionAccess();
	}
	
	public ParserRule getMultExpressionRule() {
		return getMultExpressionAccess().getRule();
	}

	//// Example: (2 / 4)
	//// note: division always has to have parantheses because the '/' sign is also used for trigger/effect delimiter
	//DivExpression returns Expression:
	//	ModExpression ({OperatorExpression.subExpressions+=current} operator=DivOperator subExpressions+=ModExpression)?;
	public KExpressionsGrammarAccess.DivExpressionElements getDivExpressionAccess() {
		return gaKExpressions.getDivExpressionAccess();
	}
	
	public ParserRule getDivExpressionRule() {
		return getDivExpressionAccess().getRule();
	}

	//// Example: varA mod ?B
	//ModExpression returns Expression:
	//	NegExpression ({OperatorExpression.subExpressions+=current} operator=ModOperator
	//	subExpressions+=AtomicValuedExpression)?;
	public KExpressionsGrammarAccess.ModExpressionElements getModExpressionAccess() {
		return gaKExpressions.getModExpressionAccess();
	}
	
	public ParserRule getModExpressionRule() {
		return getModExpressionAccess().getRule();
	}

	//// Example: not A, not false, not (A or B)
	//// at the latter we need the parans to indicate the right binding
	//NegExpression returns Expression:
	//	{OperatorExpression} operator=SubOperator subExpressions+=NegExpression | AtomicValuedExpression;
	public KExpressionsGrammarAccess.NegExpressionElements getNegExpressionAccess() {
		return gaKExpressions.getNegExpressionAccess();
	}
	
	public ParserRule getNegExpressionRule() {
		return getNegExpressionAccess().getRule();
	}

	//AtomicValuedExpression returns Expression:
	//	IntValue //    | '(' DivExpression ')'
	//	| FloatValue | "(" ValuedExpression ")" | AtomicExpression;
	public KExpressionsGrammarAccess.AtomicValuedExpressionElements getAtomicValuedExpressionAccess() {
		return gaKExpressions.getAtomicValuedExpressionAccess();
	}
	
	public ParserRule getAtomicValuedExpressionRule() {
		return getAtomicValuedExpressionAccess().getRule();
	}

	//// Example: pre(pre(?A)), pre(pre(A)), ?A, A varX
	//ValuedObjectTestExpression returns Expression:
	//	{OperatorExpression} operator=PreOperator "(" subExpressions+=ValuedObjectTestExpression ")" | {OperatorExpression}
	//	operator=ValueTestOperator subExpressions+=ValuedObjectReference | ValuedObjectReference;
	public KExpressionsGrammarAccess.ValuedObjectTestExpressionElements getValuedObjectTestExpressionAccess() {
		return gaKExpressions.getValuedObjectTestExpressionAccess();
	}
	
	public ParserRule getValuedObjectTestExpressionRule() {
		return getValuedObjectTestExpressionAccess().getRule();
	}

	//// Example: A, varB
	//ValuedObjectReference:
	//	valuedObject=[ValuedObject];
	public KExpressionsGrammarAccess.ValuedObjectReferenceElements getValuedObjectReferenceAccess() {
		return gaKExpressions.getValuedObjectReferenceAccess();
	}
	
	public ParserRule getValuedObjectReferenceRule() {
		return getValuedObjectReferenceAccess().getRule();
	}

	//// Example: 'printf(...)'(C)
	//TextExpression:
	//	code=HOSTCODE ("(" type=ID ")")?;
	public KExpressionsGrammarAccess.TextExpressionElements getTextExpressionAccess() {
		return gaKExpressions.getTextExpressionAccess();
	}
	
	public ParserRule getTextExpressionRule() {
		return getTextExpressionAccess().getRule();
	}

	//IntValue:
	//	value=INT;
	public KExpressionsGrammarAccess.IntValueElements getIntValueAccess() {
		return gaKExpressions.getIntValueAccess();
	}
	
	public ParserRule getIntValueRule() {
		return getIntValueAccess().getRule();
	}

	////NIntValue returns IntValue:
	////	value=NINT;
	//FloatValue:
	//	value=Float;
	public KExpressionsGrammarAccess.FloatValueElements getFloatValueAccess() {
		return gaKExpressions.getFloatValueAccess();
	}
	
	public ParserRule getFloatValueRule() {
		return getFloatValueAccess().getRule();
	}

	//BooleanValue:
	//	value=Boolean;
	public KExpressionsGrammarAccess.BooleanValueElements getBooleanValueAccess() {
		return gaKExpressions.getBooleanValueAccess();
	}
	
	public ParserRule getBooleanValueRule() {
		return getBooleanValueAccess().getRule();
	}

	//// data type rule allowing any kind of value to be accepted,
	//// e.g. as initialValues of valuedObjects
	//// used in Kits.xtext 
	//AnyType returns ecore::EString:
	//	Boolean | INT | Float | ID | STRING;
	public KExpressionsGrammarAccess.AnyTypeElements getAnyTypeAccess() {
		return gaKExpressions.getAnyTypeAccess();
	}
	
	public ParserRule getAnyTypeRule() {
		return getAnyTypeAccess().getRule();
	}

	//// --------------------------
	////
	////  Interface Declarations
	////
	//// --------------------------
	//InterfaceDeclaration:
	//	InterfaceSignalDecl | InterfaceVariableDecl;
	public KExpressionsGrammarAccess.InterfaceDeclarationElements getInterfaceDeclarationAccess() {
		return gaKExpressions.getInterfaceDeclarationAccess();
	}
	
	public ParserRule getInterfaceDeclarationRule() {
		return getInterfaceDeclarationAccess().getRule();
	}

	//ISignal:
	//	name=ID channelDescr=ChannelDescription?;
	public KExpressionsGrammarAccess.ISignalElements getISignalAccess() {
		return gaKExpressions.getISignalAccess();
	}
	
	public ParserRule getISignalRule() {
		return getISignalAccess().getRule();
	}

	//InterfaceSignalDecl:
	//	{Input} "input" signals+=ISignal ("," signals+=ISignal)* ";" | {Output} "output" signals+=ISignal (","
	//	signals+=ISignal)* ";" | {InputOutput} "inputoutput" signals+=ISignal ("," signals+=ISignal)* ";" | {Return} "return"
	//	signals+=ISignal ("," signals+=ISignal)* ";";
	public KExpressionsGrammarAccess.InterfaceSignalDeclElements getInterfaceSignalDeclAccess() {
		return gaKExpressions.getInterfaceSignalDeclAccess();
	}
	
	public ParserRule getInterfaceSignalDeclRule() {
		return getInterfaceSignalDeclAccess().getRule();
	}

	//// Variables
	//InterfaceVariableDecl:
	//	"var" varDecls+=VariableDecl ("," varDecls+=VariableDecl)*;
	public KExpressionsGrammarAccess.InterfaceVariableDeclElements getInterfaceVariableDeclAccess() {
		return gaKExpressions.getInterfaceVariableDeclAccess();
	}
	
	public ParserRule getInterfaceVariableDeclRule() {
		return getInterfaceVariableDeclAccess().getRule();
	}

	//VariableDecl:
	//	variables+=IVariable ("," variables+=IVariable)* ":" type=TypeIdentifier;
	public KExpressionsGrammarAccess.VariableDeclElements getVariableDeclAccess() {
		return gaKExpressions.getVariableDeclAccess();
	}
	
	public ParserRule getVariableDeclRule() {
		return getVariableDeclAccess().getRule();
	}

	//IVariable:
	//	name=ID (":=" expression=Expression)?;
	public KExpressionsGrammarAccess.IVariableElements getIVariableAccess() {
		return gaKExpressions.getIVariableAccess();
	}
	
	public ParserRule getIVariableRule() {
		return getIVariableAccess().getRule();
	}

	//// --------------------------
	////
	////  Terminals...
	////
	//// --------------------------
	//enum CompareOperator returns OperatorType:
	//	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";
	public KExpressionsGrammarAccess.CompareOperatorElements getCompareOperatorAccess() {
		return gaKExpressions.getCompareOperatorAccess();
	}
	
	public EnumRule getCompareOperatorRule() {
		return getCompareOperatorAccess().getRule();
	}

	//enum PreOperator returns OperatorType:
	//	PRE="pre";
	public KExpressionsGrammarAccess.PreOperatorElements getPreOperatorAccess() {
		return gaKExpressions.getPreOperatorAccess();
	}
	
	public EnumRule getPreOperatorRule() {
		return getPreOperatorAccess().getRule();
	}

	//enum OrOperator returns OperatorType:
	//	OR="or";
	public KExpressionsGrammarAccess.OrOperatorElements getOrOperatorAccess() {
		return gaKExpressions.getOrOperatorAccess();
	}
	
	public EnumRule getOrOperatorRule() {
		return getOrOperatorAccess().getRule();
	}

	//enum AndOperator returns OperatorType:
	//	AND="and";
	public KExpressionsGrammarAccess.AndOperatorElements getAndOperatorAccess() {
		return gaKExpressions.getAndOperatorAccess();
	}
	
	public EnumRule getAndOperatorRule() {
		return getAndOperatorAccess().getRule();
	}

	//enum NotOperator returns OperatorType:
	//	NOT="not";
	public KExpressionsGrammarAccess.NotOperatorElements getNotOperatorAccess() {
		return gaKExpressions.getNotOperatorAccess();
	}
	
	public EnumRule getNotOperatorRule() {
		return getNotOperatorAccess().getRule();
	}

	//enum AddOperator returns OperatorType:
	//	ADD="+";
	public KExpressionsGrammarAccess.AddOperatorElements getAddOperatorAccess() {
		return gaKExpressions.getAddOperatorAccess();
	}
	
	public EnumRule getAddOperatorRule() {
		return getAddOperatorAccess().getRule();
	}

	//enum SubOperator returns OperatorType:
	//	SUB="-";
	public KExpressionsGrammarAccess.SubOperatorElements getSubOperatorAccess() {
		return gaKExpressions.getSubOperatorAccess();
	}
	
	public EnumRule getSubOperatorRule() {
		return getSubOperatorAccess().getRule();
	}

	//enum MultOperator returns OperatorType:
	//	MULT="*";
	public KExpressionsGrammarAccess.MultOperatorElements getMultOperatorAccess() {
		return gaKExpressions.getMultOperatorAccess();
	}
	
	public EnumRule getMultOperatorRule() {
		return getMultOperatorAccess().getRule();
	}

	//enum ModOperator returns OperatorType:
	//	MOD="mod";
	public KExpressionsGrammarAccess.ModOperatorElements getModOperatorAccess() {
		return gaKExpressions.getModOperatorAccess();
	}
	
	public EnumRule getModOperatorRule() {
		return getModOperatorAccess().getRule();
	}

	//enum DivOperator returns OperatorType:
	//	DIV="/";
	public KExpressionsGrammarAccess.DivOperatorElements getDivOperatorAccess() {
		return gaKExpressions.getDivOperatorAccess();
	}
	
	public EnumRule getDivOperatorRule() {
		return getDivOperatorAccess().getRule();
	}

	//enum ValueTestOperator returns OperatorType:
	//	VAL="?";
	public KExpressionsGrammarAccess.ValueTestOperatorElements getValueTestOperatorAccess() {
		return gaKExpressions.getValueTestOperatorAccess();
	}
	
	public EnumRule getValueTestOperatorRule() {
		return getValueTestOperatorAccess().getRule();
	}

	/// *
	//   the following declarations are re-used in Actions.xtext, Interface.xtext, Kits.xtext 
	// * / enum ValueType:
	//	PURE="pure" | BOOL="boolean" | UNSIGNED="unsigned" | INT="integer" | FLOAT="float" | DOUBLE="double" | STRING="string"
	//	| HOST="host";
	public KExpressionsGrammarAccess.ValueTypeElements getValueTypeAccess() {
		return gaKExpressions.getValueTypeAccess();
	}
	
	public EnumRule getValueTypeRule() {
		return getValueTypeAccess().getRule();
	}

	//enum CombineOperator:
	//	NONE="none" | ADD="+" | MULT="*" | MAX="max" | MIN="min" | OR="or" | AND="and" | HOST="host";
	public KExpressionsGrammarAccess.CombineOperatorElements getCombineOperatorAccess() {
		return gaKExpressions.getCombineOperatorAccess();
	}
	
	public EnumRule getCombineOperatorRule() {
		return getCombineOperatorAccess().getRule();
	}

	//// custom terminal rule allowing to save transition label string as they are
	//terminal HOSTCODE:
	//	"\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getHOSTCODERule() {
		return gaKExpressions.getHOSTCODERule();
	} 

	//// --------------------------
	////
	////   ANNOTATIONS
	////
	//// --------------------------
	//Annotation:
	//	CommentAnnotation | TagAnnotation | KeyStringValueAnnotation | TypedKeyStringValueAnnotation |
	//	KeyBooleanValueAnnotation | KeyIntValueAnnotation | KeyFloatValueAnnotation;
	public AnnotationsGrammarAccess.AnnotationElements getAnnotationAccess() {
		return gaKExpressions.getAnnotationAccess();
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// e.g.: / ** semantic comment * /
	//CommentAnnotation returns StringAnnotation:
	//	value=COMMENT_ANNOTATION;
	public AnnotationsGrammarAccess.CommentAnnotationElements getCommentAnnotationAccess() {
		return gaKExpressions.getCommentAnnotationAccess();
	}
	
	public ParserRule getCommentAnnotationRule() {
		return getCommentAnnotationAccess().getRule();
	}

	//// e.g.: @HVlayout
	//TagAnnotation returns Annotation:
	//	"@" name=ExtendedID ("(" annotations+=Annotation* ")")?;
	public AnnotationsGrammarAccess.TagAnnotationElements getTagAnnotationAccess() {
		return gaKExpressions.getTagAnnotationAccess();
	}
	
	public ParserRule getTagAnnotationRule() {
		return getTagAnnotationAccess().getRule();
	}

	//// e.g.: @layouter dot;   
	//KeyStringValueAnnotation returns StringAnnotation:
	//	"@" name=ExtendedID value=EString ("(" annotations+=Annotation* ")")?;
	public AnnotationsGrammarAccess.KeyStringValueAnnotationElements getKeyStringValueAnnotationAccess() {
		return gaKExpressions.getKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getKeyStringValueAnnotationRule() {
		return getKeyStringValueAnnotationAccess().getRule();
	}

	//// e.g.: @position[de.cau.cs.kieler.core.math.KVector] "(3,2)"
	//TypedKeyStringValueAnnotation returns TypedStringAnnotation:
	//	"@" name=ExtendedID "[" type=ExtendedID "]" value=EString ("(" annotations+=Annotation* ")")?;
	public AnnotationsGrammarAccess.TypedKeyStringValueAnnotationElements getTypedKeyStringValueAnnotationAccess() {
		return gaKExpressions.getTypedKeyStringValueAnnotationAccess();
	}
	
	public ParserRule getTypedKeyStringValueAnnotationRule() {
		return getTypedKeyStringValueAnnotationAccess().getRule();
	}

	//// e.g.: @visible true;
	//KeyBooleanValueAnnotation returns BooleanAnnotation:
	//	"@" name=ExtendedID value=Boolean ("(" annotations+=Annotation* ")")?;
	public AnnotationsGrammarAccess.KeyBooleanValueAnnotationElements getKeyBooleanValueAnnotationAccess() {
		return gaKExpressions.getKeyBooleanValueAnnotationAccess();
	}
	
	public ParserRule getKeyBooleanValueAnnotationRule() {
		return getKeyBooleanValueAnnotationAccess().getRule();
	}

	//// e.g.: @minSpace 10;    
	//KeyIntValueAnnotation returns IntAnnotation:
	//	"@" name=ExtendedID value=INT ("(" annotations+=Annotation* ")")?;
	public AnnotationsGrammarAccess.KeyIntValueAnnotationElements getKeyIntValueAnnotationAccess() {
		return gaKExpressions.getKeyIntValueAnnotationAccess();
	}
	
	public ParserRule getKeyIntValueAnnotationRule() {
		return getKeyIntValueAnnotationAccess().getRule();
	}

	//// e.g.: @minSpace 10.0;    
	//KeyFloatValueAnnotation returns FloatAnnotation:
	//	"@" name=ExtendedID value=Float ("(" annotations+=Annotation* ")")?;
	public AnnotationsGrammarAccess.KeyFloatValueAnnotationElements getKeyFloatValueAnnotationAccess() {
		return gaKExpressions.getKeyFloatValueAnnotationAccess();
	}
	
	public ParserRule getKeyFloatValueAnnotationRule() {
		return getKeyFloatValueAnnotationAccess().getRule();
	}

	//// needed for importing other resources
	//ImportAnnotation:
	//	"import" importURI=STRING;
	public AnnotationsGrammarAccess.ImportAnnotationElements getImportAnnotationAccess() {
		return gaKExpressions.getImportAnnotationAccess();
	}
	
	public ParserRule getImportAnnotationRule() {
		return getImportAnnotationAccess().getRule();
	}

	//// allow strings without quotes as they don'c contain spaces
	//EString returns ecore::EString:
	//	STRING | ID;
	public AnnotationsGrammarAccess.EStringElements getEStringAccess() {
		return gaKExpressions.getEStringAccess();
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}

	//ExtendedID returns ecore::EString:
	//	ID ("." ID)*;
	public AnnotationsGrammarAccess.ExtendedIDElements getExtendedIDAccess() {
		return gaKExpressions.getExtendedIDAccess();
	}
	
	public ParserRule getExtendedIDRule() {
		return getExtendedIDAccess().getRule();
	}

	//// --------------------------
	////
	////  Terminals...
	////
	//// --------------------------
	//// custom terminals
	//// custom terminal rule introducing semantic comments
	//terminal COMMENT_ANNOTATION:
	//	"/ **"->"* /";
	public TerminalRule getCOMMENT_ANNOTATIONRule() {
		return gaKExpressions.getCOMMENT_ANNOTATIONRule();
	} 

	//// modified version of Terminals.ML_COMMENT as
	//// COMMENT_ANNOTATION is not recognized correctly with original one 
	//terminal ML_COMMENT:
	//	"/ *" !"*"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaKExpressions.getML_COMMENTRule();
	} 

	//// generic terminals
	//// redefine INT terminal to allow negative numbers
	//terminal INT returns ecore::EInt:
	//	"-"? "0".."9"+;
	public TerminalRule getINTRule() {
		return gaKExpressions.getINTRule();
	} 

	//// make sure the Float rule does not shadow the INT rule
	//terminal Float returns ecore::EFloatObject:
	//	"-"? "0".."9"+ ("." "0".."9"*) (("e" | "E") ("+" | "-")? "0".."9"+)? "f"? | "-"? "0".."9"+ "f";
	public TerminalRule getFloatRule() {
		return gaKExpressions.getFloatRule();
	} 

	//// introduce boolean values
	//terminal Boolean returns ecore::EBooleanObject:
	//	"true" | "false";
	public TerminalRule getBooleanRule() {
		return gaKExpressions.getBooleanRule();
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaKExpressions.getIDRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaKExpressions.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaKExpressions.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaKExpressions.getANY_OTHERRule();
	} 
}
