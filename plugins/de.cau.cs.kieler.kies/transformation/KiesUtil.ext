import ecore;
import annotations;
import kexpressions;
import synccharts;
import utilities; 
import esterel; 

//extension feature;
extension org::eclipse::xtend::util::stdlib::io; // provides clone functionality
extension org::eclipse::xtend::util::stdlib::cloning; // provides clone functionality

 /*
  * #################################################################################
  * 
  * Convenient methods used by the Esterel to SyncCharts transformation.
  * 
  */

/**
 * extracts the expression and immediate information of a esterel::DelayExpr
 * and adds them to the synccharts::Transition
 */
Void addTriggerToTransition(synccharts::Action t, DelayExpr delay):
	if delay.isImmediate then 
		t.setIsImmediate(true) ->
	// clone the expression as in should stay in esterel model too
	t.setTrigger((Expression)clone(delay.event.expr)) ->
	if delay.expr != null then
		t -> // TODO not yet supported, as synccharts do not offer a delay expression! 
	t		
;

/**
 * extracts all signals from the InterfaceSignalDecl and adds them to the state
 */
Void extractSignals(InterfaceSignalDecl decl, State s):
	let clonedDecl = (InterfaceSignalDecl) clone(decl):
	//let copy = (List[Signal]) copyList(clonedDecl.signals):
	// CHSCH: changed list to be a list of ISignal, was Signal
	let copy = (List[ISignal]) copyList(clonedDecl.signals):
	switch {
		// clone loses the information
		case Input.isInstance(decl) : (copy.setIsInput(true) ->  copy.setIsOutput(false))
		case Output.isInstance(decl) : (copy.setIsInput(false) ->  copy.setIsOutput(true))
		case InputOutput.isInstance(decl) : (copy.setIsInput(true) ->  copy.setIsOutput(true))
   		default : decl //no information about input/output
	} ->
	if clonedDecl.signals.size > 0 then (
		copy.select(e|e.channelDescr != null).modifyHostType() ->
		copy.addSignalToState(s)
    )
;

Void addSignalToState(Signal sig, State st):
	st.signals.add(sig)
;

/**
 * extract all variables
 */ 
Void extractLocalVariables(VariableDecl decl, State s):
	let vars = (List[IVariable]) clone(decl.variables):
	//info(vars.type.toString()) ->
	vars.addVariableToState(s)
; 

Void addVariableToState(kexpressions::Variable v, State s):
	s.variables.add(v)
;

Void modifyHostType(ISignal copy):
  copy.setType(ValueType::HOST) ->
  //copy.setType(ValueType::PURE) //->
  //info(copy.name) ->
  //copy.setName(copy.name+"Hugo") ->
  //info(copy.name) 
  //info(copy.name) 
  copy.setHostType(copy.channelDescr.type.typeID)
;

/**
 * extracts all local signals
 */
Void extractLocalSignals(LocalSignalList lsl, State s):
	if LocalSignal.isInstance(lsl) then
		(let copy = (List[ISignal]) clone(((LocalSignal)lsl).signal):
        	//info(((LocalSignal)lsl).signal.select(e|e.channelDescr != null).name) ->
        	copy.select(e|e.channelDescr != null).modifyHostType() ->
		 copy.addSignalToState(s)
		 //null
		)
;

/**
 * connects a transition to the two passed states
 */
Void connectTransition(Transition t, State source, State target):
	t.setSourceState(source) ->
	t.setTargetState(target) ->
	source.outgoingTransitions.add(t)
;

/**
 * removes EVERYTHING !! body text, sets state type to NORMAL
 */
Void removeBodyText(State s):
 	s.bodyText.removeAll(s.bodyText) ->
 	s.setBodyReference(null) ->
 	s.setType(StateType::NORMAL)
;

/** 
 * clears bodycontents of EVERY child states of State s.
 */
Void clearBodyReferences(State s):
	let states = (Set[State]) s.eAllContents.select(e| State.isInstance(e) && ((State)e).bodyReference != null):
	states.add(s) ->
	states.setBodyReference(null)
;

/**
 * only sets the label if there's no previous label
 */
Void setLabelIfEmpty(State s, String label):
	(s.label == null || s.label.trim().length == 0) ? 
		s.setLabel(label) : s
;

// collect all traps in an "or" expression
Void collectTraps(TrapDeclList traps, OperatorExpression expr):
 	traps.trapDecls.addTrapToExpression(expr)
;
// as trap just extends ISignal .. TrapDecl is unknown here
Void addTrapToExpression(ISignal trap, OperatorExpression expr):
	let ref = new ValuedObjectReference:
	ref.setValuedObject(trap) ->
	expr.subExpressions.add(ref)
;

/*
 * esterel provides additional expression constructs which need to be converted 
 * into a synccharts adequate form.
 * These are: - FunctionExpression (replaced by hostcode)
 * 			  - ConstantExpression (replaced by corresponding primitive type)
 * 
 */
Expression convertEsterelExpression(Expression e):
	if e != null then 
		 convertEsterelExpressionRec(e)
;
// in case there is no expression at all, null is no problem here
Expression convertEsterelExpression(Void v):
	null
;
Void replaceWithCorrespondingExpression(Expression e):
	let parent = (ComplexExpression) e.eContainer:
	parent.subExpressions.add(e.convertEsterelExpression()) ->
	parent.subExpressions.remove(e)
;
// apply conversion on children
Expression convertEsterelExpressionRec(Expression e):
	if ComplexExpression.isInstance(e) then
		((ComplexExpression) e).subExpressions.convertEsterelExpression()
;
//ValuedObjectReference - added by cmot for handleIfSingle() function (present tests of simple triggers)
Expression convertEsterelExpressionRec(ValuedObjectReference e):
	if ValuedObjectReference.isInstance(e) then
		e
;
// Function expression
Expression convertEsterelExpressionRec(FunctionExpression fe):
	let textExpr = new TextExpression:
	textExpr.setCode(fe.function.name + "(todo" + ")") ->
	textExpr
;
// Constant expression
Expression convertEsterelExpression(ConstantExpression te):
    convertConstantExpressionJava(te)
;

/**
 * finds and returns the initial state of the passed region.
 * In case an inconsistency occurs, a dummy state is created giving feedback about the problem.
 */
State findInitialState(Region r):
	let initials = r.states.select(e|e.isInitial):
	if initials.isEmpty then
		(let s = new State:
		 s.setLabel("Inconsistency! Could not find initial state in this region.") ->
		 r.states.add(s) ->
		 initials.add(s)) ->
	initials.get(0)
;

/**
 * creates an immediate weakly aborting transition between the two passed states.
 */
Void createImmediateWeakAbortTo(State from, State to, Transition original):
	let t = new Transition:
	from.outgoingTransitions.add(t) ->
	t.setSourceState(from) ->
	t.setTargetState(to) ->
	t.addEffects(original.effects) ->
	to.incomingTransitions.add(t) ->
	
	t.setType(TransitionType::WEAKABORT) ->
	t.setIsImmediate(true)
;

/**
 * copies a normal transition with "from" as the new source state.
 */
Void copyNormalTransitionFrom(State from, Transition t):
	let newT = new Transition:
	newT.setSourceState(from) ->
	newT.setType(t.type) ->
	newT.setTrigger((Expression) clone(t.trigger)) -> 
	newT.setEffects((List[Effect]) clone(t.effects)) ->
	newT.setTargetState(t.targetState) ->
	from.outgoingTransitions.add(newT) ->
	t.targetState.incomingTransitions.add(newT)
;

/**
 * adds all the passed effects to the transition (clones them previously)
 */
Void addEffects(Transition t, List[Effect] effects):
	// make sure to clone! as it's containment
	t.effects.addAll(clone(effects))
; 

/**
 * removes the passed transition from all containments
 */
Void removeTransition(Transition t):
	let source = t.sourceState:
	let target = t.targetState:
	t.setTargetState(null) ->
	t.setSourceState(null) ->
	source.outgoingTransitions.remove(t) ->
	target.incomingTransitions.remove(t)
;

/**
 * remove a state from its parent region, if the state was the last one within that region,
 * the region is removed as well.
 */
Void removeStateFromRegion(State state):
	let parent = state.parentRegion:
 	state.outgoingTransitions.removeAll(state.outgoingTransitions) ->
 	state.incomingTransitions.removeAll(state.incomingTransitions) ->
 	parent.states.remove(state) ->
 	if parent.states.isEmpty then
 		(if parent.parentState != null then
 			parent.parentState.regions.remove(parent))
;

/**
 * adds all states of r to the list
 */
Void collectStates(Region r, List[State] states):
	states.addAll(r.states)
;

/**
 * collects the number of already defined traphalt signals
 */ 
Integer getNumberOfTraphalts(State s):
	s.parentRegion.parentState != null ?
		getNumberOfTraphalts(s.parentRegion.parentState) :
		getNumberOfTraphaltsFromRoot(s)
;
Integer getNumberOfTraphaltsFromRoot(State root):
	let signals = root.eAllContents.select(e|Signal.isInstance(e)) :
	let traphalts = signals.select(e|((Signal)e).name.contains("traphalt")):
	traphalts.size
;

/**
 * adds the trap as signal to the specified state.
 */
Void addTrapSignalToState(ISignal trap, State s):
	let sig = new ISignal:
	sig.setName(trap.name) ->
	sig.setChannelDescr((ChannelDescription) clone(trap.channelDescr)) ->
	addSignalToState(sig, s)
;

/**
 * collect all traphalts in between an exit and the fired trap
 */
List[ISignal] findAndAddCorrespondingTraphalts(ISignal trap, State s, Transition t):
	let found = (Collection[ISignal]) {}:
	collectTrapHalts(trap, s, found) ->
	found.addTrapHalt(t) ->
	found
;
Void collectTrapHalts(ISignal trap, State s, Collection[ISignal] found):
	if !(s.signals.containsSignalWithSameName(trap)) then
		(let currentHalts = s.signals.select(e|e.name.contains("traphalt")):
		 found.addAll(currentHalts) ->
		 collectTrapHalts(trap, s.parentRegion.parentState, found))	
;
Void addTrapHalt(Signal traphalt, Transition t):
	let emission = new Emission:
	emission.setSignal(traphalt) ->
	t.effects.add(emission)
;
Boolean containsSignalWithSameName(List[Signal] signals, Signal s2):
	let sameName = signals.select(e|(e.name.matches(s2.name))):
	!sameName.isEmpty
;

/**
 * returns a copy of the passed list, just the list is new, all elements
 * remain the same
 */
List copyList(List list):
	let copy = {}:
	copy.addAll(list)
;

// to avoid casting
List[Transition] copyListTrans(List[Transition] list):
	let copy = {}:
	copy.addAll(list)
;

/**
 * #################################################################################
 * 		Predicates used to determine the optimization capacity of a state.
 */

Boolean isConditional(State s):
	s.type == StateType::CONDITIONAL
;

Boolean isTransitionWithoutTaE(Transition t):
	t.trigger == null && t.effects.size == 0
;

Boolean isTransitionWithoutT(Transition t):
	t.trigger == null
;

Boolean isImmediateTransition(Transition t):
	t.isImmediate
;

Boolean isParallelMacroState(State s):
	s.regions.size > 1	
;

// determine whether a scope contains signals or variables
Boolean scopeHasSignalsVariables(Scope scope):
 (scope.signals.size > 0 || scope.variables.size > 0)
;

// delegate methods
Boolean hasSignalsVariables(Region region):
 scopeHasSignalsVariables(region)
;
Boolean hasSignalsVariables(State state):
 scopeHasSignalsVariables(state)
;



Boolean isSimpleState(State s):
 	!s.hasSignalsVariables() 
    && s.regions.isEmpty 
    && s.entryActions.isEmpty 
    && s.innerActions.isEmpty
    && s.exitActions.isEmpty
    && s.suspensionTrigger == null
;

Boolean hasSignalXXXsVariables(State state):
	state.scopeHasSignalsVariables()
;


Boolean hasOnlySelfLoop(State s):
	let self = s.incomingTransitions.select(e|e.targetState == e.sourceState):
	self.size > 0 && self.size == s.outgoingTransitions.size
;

Boolean hasNumberOfSubStates(State s, Integer number):
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	states.size == number
;

Boolean hasNumberOfOutgoingTrans(State s, Integer n):
	s.outgoingTransitions.size == n
;

Boolean hasNumberOfIncomingTrans(State s, Integer n):
	s.incomingTransitions.size == n
;

Boolean hasOutTransitions(State s):
	!s.outgoingTransitions.isEmpty
;

Boolean hasOutWeakTransitions(State s):
	let weaks = s.outgoingTransitions.select(e|e.type == TransitionType::WEAKABORT):
	weaks.size > 0
;

// only use after checking for existing transitions
Boolean hasOnlyMatchingTriggerTrans(State s):
	let in = s.incomingTransitions.get(0):
	let out = s.outgoingTransitions.get(0):
	// incoming trans may not have any effect
	(in.effects.isEmpty) ?
		in.compareTrigger(out)
		:
		false	
;

Boolean hasOutNormalTransitions(State s):
	let normals = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	normals.size > 0
;

Boolean hasOutStrongTransitions(State s):
	let strongs = s.outgoingTransitions.select(e|e.type == TransitionType::STRONGABORT):
	strongs.size > 0 
;

Boolean hasFinalSubState(State s):
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	!states.select(e|e.isFinal).isEmpty
;

Boolean hasMultipleSimpleFinalSubStates(State s):
	let regions = s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	!regions.isEmpty
;

Boolean hasParentMacroState(State s):
	s.parentRegion.parentState != null
;


/**
 * #####################################################################
 * 		Methods calling Java
 */
 
/**
 * converts a ConstantExpression into a kexpressions valid form. See javadoc for futher information.
 */
Expression convertConstantExpressionJava(ConstantExpression e):
	JAVA de.cau.cs.kieler.kies.util.TransformationUtil.convertConstantExpression(de.cau.cs.kieler.esterel.esterel.ConstantExpression)
;

/**
 * sets the state's body reference and adds TextualCode for the specific esterel element.  
 */
Void setJavaBodyReference(State s, emf::EObject esterelElement):
	JAVA  de.cau.cs.kieler.kies.util.TransformationUtil.setBodyReference(de.cau.cs.kieler.synccharts.State, org.eclipse.emf.ecore.EObject)
;
 
/**
 * adds all elements of list2 to the front of list1.
 */
Void addToFrontOfList(List list1, List list2):
	JAVA  de.cau.cs.kieler.kies.util.TransformationUtil.addToFrontOfList(java.util.List, java.util.List)
;

/**
 * compares the two passed triggers and returns wheter they are equivalent. Ignores possible delays and t2's effects.
 */
Boolean compareTrigger(Action t1, Action t2):
	JAVA de.cau.cs.kieler.kies.util.TransformationUtil.compareTrigger(de.cau.cs.kieler.synccharts.Action, 
	de.cau.cs.kieler.synccharts.Action) 
;

Void informUser(String s):
	JAVA de.cau.cs.kieler.kies.util.TransformationUtil.raiseStatus(java.lang.String)
;

/* Void debug(Object obj):
	JAVA  de.cau.cs.kieler.kies.util.TransformationUtil.debug(java.lang.Object)
; */