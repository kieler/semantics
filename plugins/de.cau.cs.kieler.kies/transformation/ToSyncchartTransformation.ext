import ecore;
import annotations;
import kexpressions;
import synccharts;
import utilities; 
import esterel; 

extension KiesUtil;
extension feature;
extension org::eclipse::xtend::util::stdlib::cloning;
extension org::eclipse::xtend::util::stdlib::io;
 
 
/**
 * Esterel to SyncCharts transformation rules.
 *
 * Some notes: 
 * - currently just the FIRST module is transformed, if there are more than one they are ignored
 * - keep in mind to add states to their parents first, so potential transitions 
 *   generate a notification which is handled
 * - if the parent state has a label, do not overwrite it
 * - if automatic recursion is desired, use the recursiveRule()
 * - remember to pass the GLOBALVAR "recursive" to the XtendFacade
 * - add / remove bodytext!
 * - DO NOT use states.addAll{s1, s2}. this does NOT trigger the listener for unique ids!
 * - there is NO specific return value. it depends on the last call of each rule.
 *
 * @author uru
 */
 
/**
 * Recursive rule used to specify whether the control flow should be passed
 * back to the java implementation or if xtend should keep on transforming
 */
Void recursiveRule(State s, emf::EObject e):
	 ((boolean) GLOBALVAR recursive) ?
		rule(s, e)
	 :
	 s
;

/**
 * Assures that every transformation rule with further statements is finished 
 * properly. This means that any further statement is passed as body reference and the
 * recursive rule is called.
 */
Void finalizeRule(State s, emf::EObject esterelObject):
	setJavaBodyReference(s, esterelObject) ->
	recursiveRule(s, esterelObject)
;

/**
 * Called at the beginning of each rule, currently just removes any bodytext and sets the name
 */
Void initializeRule(State s, emf::EObject esterelObject):
	removeBodyText(s) ->
	s.setLabelIfEmpty(esterelObject.metaType.name.replaceAll("esterel::", "") + " State")
;
 
// rule for the case an unknown object should be transformed
Void rule(State s, emf::EObject noSupport):
	s.setLabel("Not Supported yet: " + noSupport.metaType)
;

// rule for Program, just forwards the first module
Void rule(State s, Program p):		
	rule(s, p.modules.get(0))
;

// rule allows to execute transformation for more than one state simultaneously
Void rule(List[State] states, List[emf::EObject] esterel):
	rule(states.first(), esterel.first()) ->
	if states.size > 1 then
		rule(states.withoutFirst(), esterel.withoutFirst())
;

/** !-
 * rule 1 (module)
 */ 
Void rule(State s, Module m):
	let statement = m.body.statements.get(0):
	initializeRule(s, m) ->
	// always set label here!
	s.setLabel(m.name) ->

	// extract the signals
	if(!m.interface.intSignalDecls.isEmpty) then
		m.interface.intSignalDecls.extractSignals(s) ->	
	// TODO extract all other declarations
	// for this a proper synccharts representation is needed
	
	s.finalizeRule(statement)
;

/** !-
 * rule 2 (nothing)
 */ 
Void rule(State s, Nothing n):
	let nState = new State:
	let r = new Region:
	initializeRule(s, n) ->
	s.regions.add(r) ->
	r.states.add(nState) ->
	nState.setIsFinal(true) ->
	nState.setIsInitial(true) ->
	nState
;

/** !-
 * rule 3 (halt)
 */
Void rule(State s, Halt h):
	let r = new Region:
	let ns = new State:
	initializeRule(s, h) ->
	s.regions.add(r) ->
	r.states.add(ns) ->
	ns.setIsInitial(true) ->
	ns
;
 
/** !-
 * rule 4 (pause)
 */
Void rule(State s, Pause p):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let t = new Transition:
	initializeRule(s, p) ->
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	// add transition
	t.setType(TransitionType::WEAKABORT) ->
	t.connectTransition(initS, finalS) ->
	initS
;

/** !-
 * rule 5 (abort), rule 6 (weak abort)
 */
Void rule(State s, Abort a):
	ruleAbort(s, a)
;
 
// helping rule, to allow usual aborts to be handled as well as weak aborts
Void ruleAbort(State s, Abort a):
  	let r = new Region:
 	let initState = new State:
 	let caseStates = {}:
 	let finalState = new State:
 	let toFinalTrans = new Transition:
 	initializeRule(s, a) ->
 	// add new state
 	s.regions.add(r) ->
 	r.states.add(initState) ->
 	r.states.add(finalState) ->
 	// connect initial and final state with of a normal termination
 	toFinalTrans.setType(TransitionType::NORMALTERMINATION) ->
 	toFinalTrans.setPriority(1) ->
	initState.setIsInitial(true) ->
	finalState.setIsFinal(true) ->
	
	// ERRORMARKERS are not really errors!
	// just an instance or cases? 
 	(AbortInstance.isInstance(a.body) ?
 		// INSTANCE
	 	handleAbortCaseSingle(r, initState, 1, 
	 		a.body.toAbortInstance().delay,
	 		a.body.toAbortInstance().statement,
	 		WeakAbort.isInstance(a)) 
 	:
 		// CASES
 		(toFinalTrans.setPriority(a.body.toAbortCase().cases.size + 1) ->
	 	handleAbortCases(r, initState, 1, a.body.toAbortCase().cases, WeakAbort.isInstance(a)))
	) -> 	
	toFinalTrans.connectTransition(initState, finalState) ->
	// handle abort's body statement
	finalizeRule(initState, a.statement)
;

// CHSCH: just some helper to get rid of the down false positive markers
AbortInstance toAbortInstance(EObject o): o;
AbortInstance toAbortInstance(AbortInstance o): o;
AbortCase toAbortCase(EObject o): o;
AbortCase toAbortCase(AbortCase o): o;


		
Void handleAbortCases(Region parent, State source, Integer prio, List[AbortCaseSingle] cases, boolean weak):
	(cases.size > 1) ?
		(handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement, weak) ->
		handleAbortCases(parent, source, prio + 1, cases.withoutFirst(), weak))
		:
		handleAbortCaseSingle(parent, source, prio, cases.first().delay, cases.first().statement, weak)
;

Void handleAbortCaseSingle(Region parent, State source, Integer prio, DelayExpr expr, Statement body, boolean weak):
	let caseState = new State:
	let trans = new Transition:
	caseState.setIsFinal(true) ->
	parent.states.add(caseState) ->
	
	// create and add transition (weak abort needs strong abortion!)
	if !weak then trans.setType(TransitionType::STRONGABORT) ->
	trans.setPriority(prio) ->
	
	// handle delayexpr
	trans.addTriggerToTransition(expr) ->
		
	trans.connectTransition(source, caseState) ->
	// care! the "do" body of abort might be null
	if (body != null) then
		// set body text 
		finalizeRule(caseState, body)
;

/** !-
 * rule 7 (assign)
 */
Void rule(State s, esterel::Assignment assign):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let t = new Transition:
	let sa = new synccharts::Assignment:
	initializeRule(s, assign) ->
	// setup states
	s.regions.add(r) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	r.states.add(initS) ->
	r.states.add(finalS) ->
	// init transition
	t.connectTransition(initS, finalS) ->
 	sa.setVariable(assign.var) ->
	// care to convert the expression prior adding it
	if (assign.expr != null) then
		(sa.setExpression(
		  let clone = ((Expression) clone(assign.expr)).convertEsterelExpression():
          // this is an ugly hack needed with the Indigo release
		  {clone}.flatten().first()
		 )) ->
	// add assignment to the transition
	t.effects.add(sa) ->
	initS
;

/** !-
 * rule 8 (await)
 */
Void rule(State s, Await a):
 	let r = new Region :
 	let initState = new State:
 	let caseStates = {}:
	initializeRule(s, a) ->
 	// add state
 	s.regions.add(r) ->
 	initState.setIsInitial(true) ->
 	r.states.add(initState) ->

 	// just one instance or cases?
	(AwaitInstance.isInstance(a.body)?
		handleAwaitCaseSingle(r, initState, 1, 
			((AwaitInstance)a.body).delay, 
			((AwaitInstance)a.body).statement)
	:
		handleAwaitCases(r, initState, 1, ((AwaitCase)a.body).cases))
	-> initState
;
 
// as abort and await cases are equal, we use AbortCaseSingles 
Void handleAwaitCases(Region r, State previous, Integer prio, List[AbortCaseSingle] cases):
	handleAbortCases(r, previous, prio, cases, true)
;

Void handleAwaitCaseSingle(Region r, State previous, Integer prio, DelayExpr expr, Statement body):
	handleAbortCaseSingle(r, previous, prio, expr, body, true)
;


/** !-
 * rule 10 & 11 (do upto & watching)
 */
Void rule(State s, Do d):
	// end is either DoUpto or DoWatching and just affects the outgoing context.
 	// hence we transform the "do" statement here and then decide
 	let r = new Region :
 	let initState = new State:
	initializeRule(s, d) ->
	s.regions.add(r) ->
	r.states.add(initState) ->
	initState.setIsInitial(true) ->
 	
 	// ERRORMARKERS are not really errors!
 	// handle end
 	((DoUpto.isInstance(d.end)) ? 
 		handleDoUpto(s, initState, r, d.end.toDoUpto())
 		:
 		handleDoWatching(s, initState, r, d.end.toDoWatching())
 	) ->

	finalizeRule(initState, d.statement)
;

// CHSCH: just some helper to get rid of the down false positive markers
DoUpto toDoUpto(EObject o): o;
DoUpto toDoUpto(DoUpto o): o;
DoWatching toDoWatching(EObject o): o;
DoWatching toDoWatching(DoWatching o): o;

		

/** !-
 * rule 10 (doupto)
 */
Void handleDoUpto(State parent, State previous, Region parentR, DoUpto du):
	let finalS = new State:
	let t = new Transition:
	// set a more explicit state name
	parent.setLabelIfEmpty("Doupto State") ->
	parentR.states.add(finalS) ->
	finalS.setIsFinal(true) ->
	
	t.setType(TransitionType::STRONGABORT) ->
	t.connectTransition(previous, finalS) ->
	t.addTriggerToTransition(du.expr)
;

/** !-
 * rule 11 (do watching)
 */
Void handleDoWatching(State parent, State previous, Region parentR, DoWatching dw):
	let abortF = new State:
	let normalF = new State:
	let abortT = new Transition:
	let normalT = new Transition:
	// set a more explicit state name
	parent.setLabelIfEmpty("Dowatching State") ->
	parentR.states.add(abortF) ->
	parentR.states.add(normalF) ->
	normalF.setId("_") ->
	normalF.setIsFinal(true) ->
	abortF.setIsFinal(true) ->
	
	// transitions
	abortT.setType(TransitionType::STRONGABORT) ->
	normalT.setType(TransitionType::NORMALTERMINATION) ->
	abortT.connectTransition(previous, abortF) ->
	normalT.connectTransition(previous, normalF) ->
	
	// add delay
	abortT.addTriggerToTransition(dw.delay) ->
	
	// if timeout
	if (dw.end != null) then
		finalizeRule(abortF, dw.end.statement)
;

/** !-
 * rule 12 (emit)
 */
Void rule(State s, Emit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	let emission = new Emission:
	initializeRule(s, e) ->
	s.regions.add(r) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS) ->
	
	// add the effect
	emitTrans.setIsImmediate(true) ->
	emission.setSignal(e.signal) ->
	emission.setNewValue(
	  let clone = ((Expression)clone(e.expr)).convertEsterelExpression():
	  // this is an ugly hack needed with the Indigo release
	  {clone}.flatten().first()
	 ) ->
	emitTrans.effects.add(emission) ->
	// add transition to state
	emitTrans.connectTransition(initS, finalS) ->
	initS
;

/** !-
 * rule 13 (every)
 */
Void rule(State s, EveryDo e):
	let r = new Region:
	let initS = new State:
	let everyS = new State:
	let initT = new Transition:
	let everyT = new Transition:
	initializeRule(s, e) ->
	// setup states
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(everyS) ->
	initS.setIsInitial(true) ->
	// init transitions
	initT.setType(TransitionType::WEAKABORT) ->
	everyT.setType(TransitionType::STRONGABORT) ->
	initT.connectTransition(initS, everyS) ->
	everyT.connectTransition(everyS, everyS) ->
	// add delays
	initT.addTriggerToTransition(e.delay) ->
	everyT.addTriggerToTransition(e.delay) ->
	// recursive
	finalizeRule(everyS, e.statement)
;

/** !-
 * rule 14 (if)
 */
Void rule(State s, IfTest ift):
	let r = new Region:
	let initS = new State:
	// priority for possible else case
	let maxprio = 2 + ift.elsif.size:
	initializeRule(s, ift) ->
	// IfTest does not sound nice :)
	s.setLabelIfEmpty("If State") ->
	s.regions.add(r) ->
	r.states.add(initS) ->
	initS.setIsInitial(true) ->
	// first if
	handleIfSingle(r, initS, 1, ift.expr, (ift.thenPart != null) ? ift.thenPart.statement : null) ->
	
	// possible else ifs
	if (!ift.elsif.isEmpty) then
		handleElseIfParts(r, initS, 2, ift.elsif) ->
	
	// possible else
	if (ift.elsePart != null) then
		handleIfSingle(r, initS, maxprio, null, ift.elsePart.statement)
;

Void handleElseIfParts(Region parent, State previous, Integer prio, List[ElsIf] elses):
	handleIfSingle(parent, previous, prio, elses.first().expr, 
		(elses.first().thenPart != null) ? elses.first().thenPart.statement : null) ->
	if(elses.size > 1) then
		handleElseIfParts(parent, previous, prio+1, elses.withoutFirst())
;

Void handleIfSingle(Region parent, State previous, Integer prio, Expression e, Statement s):
	let ifS = new State:
	let ifT = new Transition:
	parent.states.add(ifS) ->
	ifS.setIsFinal(true) ->
	ifT.setIsImmediate(true) ->
	
	// setup transition
	if (e != null) then
		(ifT.setTrigger(
		  let clone = ((Expression) clone(e)):
		  let cloneConverted = clone.convertEsterelExpression():
          // this is an ugly hack needed with the Indigo release
          {cloneConverted}.flatten().first()
		 )) ->
	
	ifT.connectTransition(previous, ifS) ->
	ifT.setPriority(prio) ->
	
	// if thenpart, recursive
	if (s != null) then
		finalizeRule(ifS, s) ->
		
	// create artificial nothing
	if (s == null) then 
		(let n = new Nothing:
		rule(ifS, n))
;

/** !-
 * rule 15 (localsignal)
 */
Void rule(State s, LocalSignalDecl ls):
	let r = new Region:
	let sigS = new State:
	initializeRule(s, ls) ->
	// setup
	s.regions.add(r) ->
	r.states.add(sigS) ->
	sigS.setIsInitial(true) ->
	sigS.setIsFinal(true) ->
	// extract local signals
	ls.signalList.extractLocalSignals(s) ->
	// recursive
	finalizeRule(sigS, ls.statement)
;

/** !-
 * rule 16 (localvariable)
 */
Void rule(State s, LocalVariable v):
	let r = new Region:
	let varS = new State:
	initializeRule(s, v) ->
	// setup
	s.regions.add(r) ->
	r.states.add(varS) ->
	varS.setIsInitial(true) ->
	varS.setIsFinal(true) ->
	// add variables to state
	v.var.varDecls.extractLocalVariables(s) ->
	// recursive
	finalizeRule(varS, v.statement)
;


/** !-
 * rule 17 (loop) & rule 18 (loop each)
 */
Void rule(State s, Loop l):
	let r = new Region:
	let loopState = new State:
 	let selfTrans = new Transition:
 	initializeRule(s, l) ->
	// name has to be determined separately
	(LoopEach.isInstance(l.end) ? s.setLabelIfEmpty("LoopEach State") 
		: s.setLabelIfEmpty("Loop State")) ->
	// setup state
	s.regions.add(r) ->
	r.states.add(loopState) ->
	loopState.setIsInitial(true) ->
	loopState.setIsFinal(true) ->
	// setup transition
	selfTrans.setType(TransitionType::NORMALTERMINATION) ->
 	selfTrans.connectTransition(loopState, loopState) ->
	
	// handle each case
	if LoopEach.isInstance(l.end) then
 		(selfTrans.setType(TransitionType::STRONGABORT) ->
 		 s) -> selfTrans.addTriggerToTransition(((LoopDelay)l.end).delay) ->
 	
	finalizeRule(loopState, l.body.statement)
;
 
/** !-
 * rule 19 (parallel)
 */
Void rule(State s, Parallel p):
	initializeRule(s, p) ->	
	// important to copy the list here! otherwise the esterel resource gets destroyed
 	ruleParallelRecursive(s, p.list.copyList())
;

Void ruleParallelRecursive(State parent, List[Statement] statements):
	// if inner parallel, extract the statements
	(Parallel.isInstance(statements.first()) ? 
		(
		statements.addAll(((Parallel)statements.first()).list) ->
		statements.remove(statements.first()) ->
		ruleParallelRecursive(parent, statements)
		)
	: 
		// else create this state and add it to the parallel region
		(
		let r = new Region:
		let s = new State:
		parent.regions.add(r) ->
		r.states.add(s) ->
		// add this to parallel
		s.setIsFinal(true) ->
		s.setIsInitial(true) ->
		
		if(statements.size > 1) then
			ruleParallelRecursive(parent, statements.withoutFirst()) ->
		
		finalizeRule(s, statements.first())
		)
	)	
;

/** !-
 * rule 20 (present)
 */
Void rule(State s, Present p):
	let r = new Region:
	let pS = new State:
	let nothing = new Nothing:
	initializeRule(s, p) ->
	// setup
	s.regions.add(r) ->
	r.states.add(pS) ->
	pS.setIsInitial(true) ->
	
	(PresentEventBody.isInstance(p.body) ? 
		// handle present ... then ... form
		(let event = ((PresentEventBody)p.body).event.expression:
		 let thenPart = ((PresentEventBody)p.body).thenPart:  
		 info(((ValuedObjectReference)event).valuedObject.name) ->
    //cmot: added implicit nothing if thenPart == null	
		 handleIfSingle(r, pS, 1, event, thenPart != null ? thenPart.statement : nothing) 
		)
		:
		// handle present cases
		handlePresentCases(r, pS, 1, ((PresentCaseList)p.body).cases)
	) ->

    //cmot: added implicit nothing if elsePart == null	
		// calculate the maximal priority. for a PresentEventBody this is 2 as no more cases can occur.
		(let maxprio = (PresentCaseList.isInstance(p.body) ? ((PresentCaseList)p.body).cases.size + 1 : 2):
		 handleIfSingle(r, pS, maxprio, null, p.elsePart != null ? p.elsePart.statement : nothing ))
;

Void handlePresentCases(Region parent, State previous, Integer prio, List[PresentCase] cases):
	(cases.size > 1) ?
		(handlePresentCaseSingle(parent, previous, prio, cases.first().event.expression, cases.first().statement) ->
		handlePresentCases(parent, previous, prio + 1, cases.withoutFirst()))
		:
		(handlePresentCaseSingle(parent, previous, prio, cases.first().event.expression, cases.first().statement)
	)
;

Void handlePresentCaseSingle(Region parent, State previous, Integer prio, Expression e, Statement st):
	let newS = new State:
	let t = new Transition:
	newS.setIsFinal(true) ->
	parent.states.add(newS) ->
	// transition
	t.setPriority(prio) ->
	t.setTrigger(convertEsterelExpression((Expression) clone(e))) ->
	t.connectTransition(previous, newS) ->
	// if thenpart, recursive
	if (st != null) then
		finalizeRule(newS, st) ->
		
	// create artificial nothing
	if (st == null) then 
		(let n = new Nothing:
		rule(newS, n))
;

/** !-
 * rule 22 (call)
 */
Void rule(State s, ProcCall c):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let t = new Transition:
	let textEffect = new TextEffect:
	initializeRule(s, c) ->
	// setup
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	finalS.setIsFinal(true) ->
	t.connectTransition(initS, finalS) ->
	
	// create call statement
	textEffect.setCode(c.createCallStatement()) ->
	t.effects.add(textEffect) ->
	initS
;

String createCallStatement(ProcCall c):
	let s = new String:
	"call " + c.proc.name + "(todo" + ")" + "(todo" + ")"   
;

/** !-
 * rule 23 (sequence)
 */
 Void rule(State s, Sequence seq):
 	let r = new Region:
 	let initial = new State:
 	let list = (List[Statement]){}:
 	initializeRule(s, seq) ->
	s.regions.add(r) ->
	initial.setIsInitial(true) ->
	r.states.add(initial) ->
	// as the grammar generates nested sequences, we flatten it first
	// this is important to conserve order!
	seq.flattenSequence(list) ->
	// call recursively
	ruleSequenceRecursive(r, initial, list.withoutFirst()) ->
	
	// process body of first sequence state
	finalizeRule(initial, list.first())
;

Void flattenSequence(Statement s, List list):
	Sequence.isInstance(s) ? (
		(Sequence)s).list.flattenSequence(list) 
		:
		(list.add(s))
;

Void ruleSequenceRecursive(Region region, State previous, List[Statement] statements):
	let s = new State:
	let t = new Transition:
	// create the new state and add to the sequence chain
	region.states.add(s) ->
	t.setType(TransitionType::NORMALTERMINATION) ->
	t.connectTransition(previous, s) ->
		
	(((statements.size > 1) ? 
	// if more than 1 element we have to handle another one
	ruleSequenceRecursive(region, s, statements.withoutFirst())  
	: 
	// else finished and the last one is a final state!
	s.setIsFinal(true))) ->
	finalizeRule(s, statements.first())
;

/** !-
 * rule 24 (suspend)
 */
Void rule(State s, Suspend sus):
	let r = new Region:
	let susState = new State:
	let act = new synccharts::Action:
	initializeRule(s, sus) ->
	s.regions.add(r) ->
	r.states.add(susState) ->
	// setup
	susState.setIsInitial(true) ->
	susState.setIsFinal(true) ->
	// add suspension
	act.addTriggerToTransition(sus.delay) ->
	susState.setSuspensionTrigger(act) ->
	// recursive
	finalizeRule(susState, sus.statement)
;

/** !-
 * rule 25 (sustain)
 */
Void rule(State s, Sustain sus):
	let r = new Region:
	let initS = new State:
	let finalS = new State:
	let initT = new Transition:
	let sustT = new Transition:
	let emission = new Emission:
	initializeRule(s, sus) ->
	s.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	// setup transitions
	initT.connectTransition(initS, finalS) ->
	sustT.connectTransition(finalS, finalS) ->
	emission.setSignal(sus.signal) ->
	emission.setNewValue(convertEsterelExpression((Expression) clone(sus.expression))) ->
	initT.effects.add(emission) ->
	sustT.effects.add((Emission) clone(emission)) ->
	initS
;

/** !-
 * rule 26 (trap)
 */
Void rule(State s, Trap t):
	let r = new Region: 
	let trapS = new State:
	let finalS = new State:
	let normalT = new Transition:
	let haltS = new State:
	let haltT = new Transition:
	let haltSig = new ISignal:
	initializeRule(s, t) ->
	// setup
	s.regions.add(r) ->
	r.states.add(trapS) ->
	r.states.add(finalS) ->
	r.states.add(haltS) ->
	// normal termination
	finalS.setIsFinal(true) ->
	normalT.setType(TransitionType::NORMALTERMINATION) ->
	normalT.setPriority(3) ->
	normalT.connectTransition(trapS, finalS) ->
	
	// halt due to higher trap
	trapS.setIsInitial(true) ->
	// new signal to halt execution if higher trap fires
	haltSig.setName("traphalt" + getNumberOfTraphalts(s)) ->
	haltSig.addSignalToState(s) ->
	haltT.connectTransition(trapS, haltS) ->
	// immediate transition with traphalt signal
	haltT.setIsImmediate(true) ->
	haltT.setPriority(1) ->
	(let vo = new ValuedObjectReference:
	 vo.setValuedObject(haltSig) ->
	 haltT.setTrigger(vo)) ->
	
	// setup exit state
	(let handleState = new State:
	 let handleExpr = new OperatorExpression:
	 let handleT = new Transition:
	 // setup state
	 handleState.setLabel("Trap Handler State") ->
	 handleState.setIsFinal(true) ->
	 r.states.add(handleState) ->
	 // copy all traps as signals
	 t.trapDeclList.trapDecls.addTrapSignalToState(s) ->
	 // transition
	 handleT.setIsImmediate(true) ->
	 handleT.setPriority(2) ->
	 handleT.connectTransition(trapS, handleState) ->
	 // collect traps
	 (t.trapDeclList.trapDecls.size > 1 ? 
	 	(t.trapDeclList.collectTraps(handleExpr) ->
	 	 handleExpr.setOperator(OperatorType::OR) ->
	 	 handleT.setTrigger(handleExpr))
	 : (let valObjRef = new ValuedObjectReference:
	 	valObjRef.setValuedObject(t.trapDeclList.trapDecls.first()) ->
	 	handleT.setTrigger(valObjRef))
	 ) ->
	 // create handler if existing
	 if !t.trapHandler.isEmpty then
	 	handleTrapHandler(handleState, t.trapHandler)
	) ->

	finalizeRule(trapS, t.statement)
;

Void handleTrapHandler(State handleState, List[TrapHandler] handler):
	handleTrapHandlerSingle(handleState, handler.first()) ->
	if(handler.size > 1) then
		handleTrapHandler(handleState, handler.withoutFirst())
;

Void handleTrapHandlerSingle(State handleState, TrapHandler handler):
	let r = new Region:
	let initS = new State:
	let macroS = new State:
	let macroT = new Transition:
	let finalS = new State:
	let finalT = new Transition:
	handleState.regions.add(r) ->
	r.states.add(initS) ->
	r.states.add(macroS) ->
	r.states.add(finalS) ->
	initS.setIsInitial(true) ->
	
	// finalState setup
	finalS.setIsFinal(true) ->
	finalT.setIsImmediate(true) ->
	finalT.setPriority(2) ->
	finalT.connectTransition(initS, finalS) ->
	
	// macroState setup
	macroS.setIsFinal(true) ->
	macroT.setIsImmediate(true) ->
	macroT.setPriority(1) ->
	macroT.connectTransition(initS, macroS) ->
	macroT.setTrigger(convertEsterelExpression((Expression) clone(handler.trapExpr))) ->
	
	// recursive
	macroS.setJavaBodyReference(handler.statement) ->
	macroS.recursiveRule(handler.statement) 
;

/** !-
 * rule 27 (exit) 
 */
Void rule(State s, Exit e):
	let initS = new State:
	let finalS = new State:
	let r = new Region:
	let emitTrans = new Transition:
	let emission = new Emission:
	initializeRule(s, e) ->
	s.regions.add(r) ->
	initS.setIsInitial(true) ->
	// add new states to region
	r.states.add(initS) ->
	r.states.add(finalS) ->
	
	// add the effect
	emitTrans.setIsImmediate(true) ->
	emission.setSignal(e.trap) ->
	emission.setNewValue(convertEsterelExpression((Expression)clone(e.expression))) ->
	emitTrans.effects.add(emission) ->
	// find and add corresponding traphalts
	findAndAddCorrespondingTraphalts(e.trap, s, emitTrans) ->
	// add transition to state
	emitTrans.connectTransition(initS, finalS) ->
	initS
;

/** !-
 * rule 28 (weak abort)
 */
Void rule(State s, WeakAbort wa):
	ruleAbort(s, wa)
;

/** !- 
 * rule (block)
 * omit the block, there's a parallel in it!
 */
Void rule(State s, Block b):
	rule(s, (Parallel) b.statement)
;

Void rule(State s, Exec e):
	initializeRule(s, e) ->
	s.setLabel("Exec was omitted") ->
	informUser("The exec statement cannot be transformed to an equivalent SyncCharts element.")
;

Void rule(State s, Repeat r):
	initializeRule(s, r) ->
	s.setLabel("Repeat was omitted") ->
	informUser("Repeat is currently not supported.")
;

Void rule(State s, Run r):
	initializeRule(s, r) ->
	s.setLabel("Run was omitted") ->
	informUser("The run statement is not yet supported.")
;