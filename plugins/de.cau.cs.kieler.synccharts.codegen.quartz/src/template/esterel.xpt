«IMPORT synccharts»

«EXTENSION template::helper»

«DEFINE main FOR Region-»
«FILE innerStates.first().label + ".strl"-»
module «innerStates.first().label» : 
«FOREACH innerStates.first().signals AS sig -»«IF sig.isInput»input «sig.name»;«ENDIF-»«IF sig.isOutput»output «sig.name»;«ENDIF-» 
«ENDFOREACH-»
«IF !innerStates.first().locals().isEmpty»
signal
 «FOREACH innerStates.first().locals() AS sig  SEPARATOR ","-»«sig.name»«ENDFOREACH»
in
«ENDIF»
  «FOREACH innerStates.first().regions AS region»«EXPAND Constelation FOR region»«ENDFOREACH-»
«IF !innerStates.first().locals().isEmpty»
end signal
«ENDIF»
end module
«ENDFILE-»
«ENDDEFINE»

«DEFINE Constelation FOR Region-»
«IF canTerminate()»trap done in «ENDIF»
  signal T_«innerStates.first().id»«FOREACH this.innerStates AS state-», goto_«state.id»«ENDFOREACH» in
    emit goto_«this.initial().id»;
    loop
      weak abort 
        «FOREACH this.innerStates.sortStates() AS state-»
        present goto_«state.id» then
        «IF state.canBeTransient()»signal start_«state.id» in emit start_«state.id»;«ENDIF»     
            «EXPAND Star FOR state-»                
         «IF state.canBeTransient()»
            present start_«state.id» else
              emit T_«innerStates.first().id»;pause;
            end present   
          end signal
          «ELSE»
            emit T_«innerStates.first().id»;pause;
          «ENDIF»
        end present;
        «ENDFOREACH-»
        halt;
      when T_«innerStates.first().id»;
    end loop;
  end signal;
«IF canTerminate()»end trap«ENDIF»
«ENDDEFINE»

«DEFINE Star FOR synccharts::State-»
 % «id»
 «IF !this.locals().isEmpty»
 signal 
 «FOREACH this.locals() AS s SEPARATOR ", "»
    «s.name»
 «ENDFOREACH»
 in
 «ENDIF»
 «IF this.hasSAborts()»abort«ENDIF»
 «IF this.hasWAborts()»weak abort«ENDIF»
 «IF this.regions.isEmpty-»
   «IF this.isFinal»exit done;«ELSE»halt;«ENDIF»
 «ELSE-»
 [
   «FOREACH this.regions AS region SEPARATOR "||"-»
   «EXPAND Constelation FOR region»
   «ENDFOREACH-»
   ]; 
  «IF this.hasNT()-»
    «FOREACH getNT().effects AS eff-»«EXPAND Effect FOR eff»«ENDFOREACH-»
    emit goto_«getNT().targetState.id»;
  «ENDIF-»
«ENDIF»
  «IF this.hasWAborts()» 
    when
    «FOREACH this.getWAborts() AS trans-»
      case «IF trans.isImmediate»immediate «ENDIF-» «IF trans.trigger==null»tick«ELSE»[«EXPAND Trigger FOR trans.trigger»]«ENDIF» do 
      emit goto_«trans.targetState.id»;
      «FOREACH trans.effects AS eff-»
        «EXPAND Effect FOR eff»
      «ENDFOREACH-»
      «ENDFOREACH»
       end abort;
  «ENDIF»
  «IF this.hasSAborts()» 
    when
    «FOREACH this.getSAborts() AS trans-»
      case «IF trans.isImmediate»immediate «ENDIF-» «IF trans.trigger==null»tick«ELSE»[«EXPAND Trigger FOR trans.trigger»]«ENDIF» do 
      emit goto_«trans.targetState.id»;
      «FOREACH trans.effects AS eff-»
        «EXPAND Effect FOR eff»
      «ENDFOREACH-»
    «ENDFOREACH-»
     end abort;
  «ENDIF» 
«IF !this.locals().isEmpty»
 end signal;
 «ENDIF»
 
«ENDDEFINE»

«DEFINE Effect FOR Emission»emit «signal.name»;«ENDDEFINE»
«DEFINE Effect FOR Assignment»«variable» := «expression»;«ENDDEFINE»
«DEFINE Effect FOR TextualCode»«code»;«ENDDEFINE»
«DEFINE Effect FOR Effect»//ERROR: unknown effect«ENDDEFINE»
«REM» Trigger «ENDREM»
«DEFINE Trigger FOR IntValue»«value»«ENDDEFINE»
«DEFINE Trigger FOR FloatValue»«value»«ENDDEFINE»
«DEFINE Trigger FOR BooleanValue»«IF value»true«ELSE»false«ENDIF»«ENDDEFINE»
«DEFINE Trigger FOR VariableReference»«variable.name»«ENDDEFINE»
«DEFINE Trigger FOR SignalReference»«signal.name»«ENDDEFINE»
«DEFINE Trigger FOR ComplexExpression»
  («FOREACH subExpressions AS sub SEPARATOR " " + operator.toString() + " "» «EXPAND Trigger FOR sub» «ENDFOREACH»)
«ENDDEFINE»
«DEFINE Trigger FOR TextualCode»«code»«ENDDEFINE»
«DEFINE Trigger FOR Expression»//ERROR: unknown expression«ENDDEFINE»





