«IMPORT synccharts»
«IMPORT kexpressions»

«EXTENSION helper»
«EXTENSION templates::helper»

«DEFINE main FOR Region-»
«FILE states.first().label + ".strl"-»
module «states.first().label» : 
«FOREACH states.first().signals AS sig -»«IF sig.isInput»input «sig.name» «EXPAND ValueType FOR sig»;«ENDIF-»«IF sig.isOutput»output «sig.name» «EXPAND ValueType FOR sig»;«ENDIF-» 
«ENDFOREACH-»
«IF !states.first().locals().isEmpty»
signal
 «FOREACH states.first().locals() AS sig  SEPARATOR ","-»«sig.name» «EXPAND ValueType FOR sig»«ENDFOREACH»
in
«ENDIF»
  «FOREACH states.first().regions AS region SEPARATOR " || "»«EXPAND Constelation FOR region»«ENDFOREACH-»
«IF !states.first().locals().isEmpty»
end signal
«ENDIF»
end module
«ENDFILE-»
«ENDDEFINE»

«DEFINE Constelation FOR Region-»
«IF canTerminate()»trap done in «ENDIF»
  signal T_«states.first().id»«FOREACH this.states AS state-», goto_«state.id»«ENDFOREACH» in
    emit goto_«this.initial().id»;
    loop
      weak abort 
        «FOREACH this.states.sortStates() AS state-»
        present goto_«state.id» then
        «IF state.canBeTransient()»signal start_«state.id» in emit start_«state.id»;«ENDIF»     
            «EXPAND Star FOR state-»                
         «IF state.canBeTransient()»
            present start_«state.id» else
              emit T_«states.first().id»;pause;
            end present   
          end signal
          «ELSE»
            emit T_«states.first().id»;pause;
          «ENDIF»
        end present;
        «ENDFOREACH-»
        halt;
      when T_«states.first().id»;
    end loop;
  end signal;
«IF canTerminate()»end trap«ENDIF»
«ENDDEFINE»


«DEFINE ValueType FOR Signal»
«IF type != ValueType::PURE» «IF initialValue.length>0»:= «initialValue.asInteger()»«ENDIF-» : «IF this.combineOperator!=CombineOperator::NONE» combine«ENDIF» integer 
«IF combineOperator!=CombineOperator::NONE» with «EXPAND CombineOperator FOR combineOperator»«ENDIF»
«ENDIF-»
«ENDDEFINE»

«DEFINE Types FOR ValueType»
  «IF this==ValueType::BOOL» boolean
  «ELSEIF  this==ValueType::UNSIGNED-» integer
  «ELSEIF  this==ValueType::INT-» integer
  «ELSEIF  this==ValueType::FLOAT-» float
  «ENDIF-»
«ENDDEFINE»


«DEFINE CombineOperator FOR CombineOperator»
  «IF this==CombineOperator::ADD» +
  «ELSEIF  this==CombineOperator::MULT-» *
  «ELSEIF  this==CombineOperator::MAX-» max
  «ELSEIF  this==CombineOperator::MIN-» min
  «ELSEIF  this==CombineOperator::OR-» or
  «ELSEIF  this==CombineOperator::AND-» and
  «ENDIF-»
«ENDDEFINE»

«DEFINE Star FOR synccharts::State-»
 % «id»
 «IF !this.locals().isEmpty»
 signal 
 «FOREACH this.locals() AS s SEPARATOR ", "»
    «s.name» «EXPAND ValueType FOR s»
 «ENDFOREACH-»
 in
 «ENDIF»
 «IF this.hasSAborts()»abort«ENDIF»
 «IF this.hasWAborts()»weak abort«ENDIF»
 «FOREACH entryActions AS action»«EXPAND Action FOR action»«ENDFOREACH»
 «IF this.regions.isEmpty-»
   «IF this.isFinal-»
     exit done;
   «ELSEIF this.innerActions.isEmpty-»halt;
   «ELSE»
     loop
     pause;
     «FOREACH innerActions AS action»«EXPAND Action FOR action»«ENDFOREACH»
     end loop
   «ENDIF-»
 «ELSE-»
 [
   «FOREACH this.regions AS region SEPARATOR "||"-»
   «EXPAND Constelation FOR region»
   «ENDFOREACH-»
   ]; 
  «IF this.hasNT()-»
    «FOREACH getNT().effects AS eff-»«EXPAND Effect FOR eff»«ENDFOREACH-»
    emit goto_«getNT().targetState.id»;
  «ENDIF-»
«ENDIF»
  «IF this.hasWAborts()» 
    when
    «FOREACH this.getWAborts() AS trans-»
      case «IF trans.isImmediate»immediate «ELSEIF trans.delay>1»«trans.delay»«ENDIF-» «IF trans.trigger==null»tick«ELSE»[«EXPAND Trigger FOR trans.trigger»]«ENDIF» do 
      emit goto_«trans.targetState.id»;
      «FOREACH trans.effects AS eff-»
        «EXPAND Effect FOR eff»
      «ENDFOREACH-»
      «ENDFOREACH»
       end abort;
  «ENDIF»
  «IF this.hasSAborts()» 
    when
    «FOREACH this.getSAborts() AS trans-»
      case «IF trans.isImmediate»immediate «ENDIF-» «IF trans.trigger==null»tick«ELSE»[«EXPAND Trigger FOR trans.trigger»]«ENDIF» do 
      emit goto_«trans.targetState.id»;
      «FOREACH trans.effects AS eff-»
        «EXPAND Effect FOR eff»
      «ENDFOREACH-»
    «ENDFOREACH-»
     end abort;
  «ENDIF» 
«IF !this.locals().isEmpty»
 end signal;
 «ENDIF»
«ENDDEFINE»


«DEFINE Trigger FOR OperatorExpression»
  «IF operator==OperatorType::PRE»
  pre(«EXPAND Trigger FOR subExpressions.first()»)
  «ELSEIF operator==OperatorType::VAL»
  ?«EXPAND Trigger FOR subExpressions.first()»
  «ELSEIF operator==OperatorType::NOT»
  (not «EXPAND Trigger FOR subExpressions.first()»)
  «ELSE»
  («FOREACH subExpressions AS sub SEPARATOR " " + operator.toString() + " "» «EXPAND Trigger FOR sub» «ENDFOREACH»)
  «ENDIF»
«ENDDEFINE»
«DEFINE Trigger FOR IntValue»«value»«ENDDEFINE»
«DEFINE Trigger FOR FloatValue»«value»«ENDDEFINE»
«DEFINE Trigger FOR BooleanValue»«IF value»true«ELSE»false«ENDIF»«ENDDEFINE»
«REM»«DEFINE Trigger FOR VariableReference»«variable.name»«ENDDEFINE»«ENDREM»
«DEFINE Trigger FOR ValuedObjectReference»«valuedObject.name»«ENDDEFINE»
«DEFINE Trigger FOR TextualCode»«code»«ENDDEFINE»
«DEFINE Trigger FOR kexpressions::Expression»//ERROR: unknown expression«ENDDEFINE»


«DEFINE Effect FOR Emission»emit «signal.name»«IF newValue!=null»(«EXPAND Trigger FOR newValue»)«ENDIF»;«ENDDEFINE»
«DEFINE Effect FOR Assignment»«variable» := «expression»;«ENDDEFINE»
«DEFINE Effect FOR TextualCode»«code»;«ENDDEFINE»
«DEFINE Effect FOR Effect»//ERROR: unknown effect«ENDDEFINE»
«REM» Trigger «ENDREM»


«DEFINE Action FOR Action»
  «IF this.trigger!=null»
  present «EXPAND Trigger FOR trigger» then
  «ENDIF»
  «FOREACH this.effects AS eff»«EXPAND Effect FOR eff»«ENDFOREACH»
  «IF this.trigger!=null»
  end present;
  «ENDIF»
«ENDDEFINE»



