import synccharts;
import annotations;
import kexpressions;
import utilities;
import esterel;
import ecore;

extension KiesUtil;
extension org::eclipse::xtend::util::stdlib::cloning;
extension org::eclipse::xtend::util::stdlib::io; // provides clone functionality

/**
 * 
 * Global Variables:
 *		* recursive : should the rules be applied recursively?
 * 		* rule1-8 : should ruleX be considered?
 * ALL of these have to be provided by the calling facade!
 *
 */ 

/** 
 *	Main algorithm
 *	
 *	rule 2 & 3 just need to be applied to simple states
 *	rule 7 & 8 can just be applied if the state still exists
 */
Integer ruleAll(List[State] states):

	if states.size > 0 then 
	(
		let s = states.first():
		switch{
			case ((boolean) GLOBALVAR rule1) && rule1applies(s) : 
				rule1(s)
			case ((boolean) GLOBALVAR rule2) && s.isSimpleState() && rule2applies(s) :
				rule2(s)
			case ((boolean) GLOBALVAR rule3) && s.isSimpleState() && rule3applies(s) :
				rule3(s)
			case ((boolean) GLOBALVAR rule4) && rule4applies(s):
				rule4(s)
			case ((boolean) GLOBALVAR rule5) && rule5applies(s) : 
				rule5(s)
			case ((boolean) GLOBALVAR rule6) && rule6applies(s) :
				rule6(s, states)
			case s.parentRegion != null && ((boolean) GLOBALVAR rule7) && rule7applies(s) :
				rule7(s)
			case s.parentRegion != null && ((boolean) GLOBALVAR rule8) && rule8applies(s) :
				rule8(s)
			default :
			// this state is finished remove state
			(states.remove(states.first()) -> ruleAll(states))
		} 		
	) ->
	
	recursiveRule(states)
	-> states.size
;

/**
 * Recursive rule used to specify whether the control flow should be passed
 * back to the java implementation or if xtend should keep on transforming
 */
Void recursiveRule(List[State] states):
	 if ((boolean) GLOBALVAR recursive) && states.size > 0 then
		ruleAll(states)
;


/** !- 
	(rule1) : Remove unnecessary conditional state
		if conditional, one plain outgoing transition
*/
Boolean rule1applies(State s):
	switch {
		case isConditional(s) && hasNumberOfOutgoingTrans(s, 1) : 
			(isTransitionWithoutTaE(s.outgoingTransitions.get(0)) ? true : false)
		default : false
	}
;

Void rule1(State s):
	let targetState = s.outgoingTransitions.get(0).targetState:
	let incomingTrans = s.incomingTransitions.copyListTrans():
	// bend transition to new target
	incomingTrans.setTargetState(targetState) ->
	s.outgoingTransitions.get(0).removeTransition() ->
	// remove conditional state
	s.removeStateFromRegion()
;

/** !- 
	(rule2) : Remove unnecessary plain states
		if simplestate, is not final nor initial, has only one outgoing transition
		with trigger = #tick
*/
Boolean rule2applies(State s):
	switch {
		case isSimpleState(s) && !s.isFinal && !s.isInitial &&
			hasNumberOfOutgoingTrans(s, 1) && isImmediateTransition(s.outgoingTransitions.get(0)) && 
			isTransitionWithoutT(s.outgoingTransitions.get(0)):
				true
		default : false
	}
;

Void rule2(State s):
	let incomingTrans = s.incomingTransitions.copyListTrans():
	let outgoingTrans = s.outgoingTransitions.first():
	let effects = outgoingTrans.effects:
	// bend transitions
	incomingTrans.setTargetState(outgoingTrans.targetState) ->
	// append effects
	incomingTrans.addEffects(effects) ->
	
	// if s is initial .. the new target needs to be initial
	if s.isInitial then
		outgoingTrans.targetState.setIsInitial(true) ->

	// remove state and outgoing transition
	outgoingTrans.removeTransition() ->
	s.parentRegion.states.remove(s)
;

/** !- 
 *	(rule3) : remove unnecessary plain states 
 *		if incoming and outgoing transitions have the same trigger (not immediate)
 */
Boolean rule3applies(State s):
	switch {
		case isSimpleState(s) && s.hasNumberOfIncomingTrans(1) && s.hasNumberOfOutgoingTrans(1) 
		&& s.hasOnlyMatchingTriggerTrans() : 
			 true
		default : false
	}
;

Void rule3(State s):
	let in = s.incomingTransitions.get(0):
	let out = s.outgoingTransitions.get(0):
	out.setSourceState(in.sourceState) ->
	out.setDelay(in.delay + out.delay) ->
	if s.isInitial then
		out.targetState.setIsInitial(true) ->
	removeTransition(in) ->
	s.removeStateFromRegion()
;


/** !- 
	(rule4) : Remove simple final states if there is more than one and bend their transitions
		to one simple final state
*/
Boolean rule4applies(State s):
	switch {
		case hasMultipleSimpleFinalSubStates(s) : 
			true
		default: false
	}
;

Void rule4(State s):
	let regions = (List[Region]) s.regions.select(e | e.states.select(e|e.isSimpleState() && e.isFinal).size > 1):
	regions.handleRule4()	
;

Void handleRule4(Region r):
	let simpleFinals = r.states.select(e|e.isSimpleState() && e.isFinal):
	// keep the first one and bend transitions there
	let firstFinal = simpleFinals.first():
	let simpleWithoutFirst = simpleFinals.withoutFirst():
	simpleWithoutFirst.handleRule4rec(firstFinal)
;

Void handleRule4rec(State s, State to):
	let incomings = s.incomingTransitions.copyListTrans():
	incomings.bendAndRemove(to)
;

Void bendAndRemove(Transition t, State to):
	let oldTarget = t.targetState:
	t.setTargetState(to) ->
	oldTarget.removeStateFromRegion()
;

/** !- 
	(rule5) : Remove unnecessary normal terminations
		macro state with no final states and outgoing transition
		care: do not remove loopstates
*/
Boolean rule5applies(State s):
	switch {
		case !isSimpleState(s) && hasOutNormalTransitions(s) && !hasFinalSubState(s) && !hasOnlySelfLoop(s):
				true
		default: false
	}
;

Void rule5(State s):
	let outTrans = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION
		&& (s.isInitial || e.sourceState != e.targetState)).copyListTrans():
	outTrans.removeTransAndPossiblyState()
;

Void removeTransAndPossiblyState(Transition t):
	let target = t.targetState:
	t.removeTransition() ->
	if(target.incomingTransitions.isEmpty) then
		removeStateFromRegion(target)
;

/** !-
	(rule6) : remove unnecessary macro states
		if no outgoing weak/strong abortions, no signals or variables, 
		is no parallel macro state, has a parent macro state 
*/
Boolean rule6applies(State s):
	switch {
		// TODO check if just test for interfaceDecls or signals and vars is enough
		case !hasOutWeakTransitions(s) && !hasOutStrongTransitions(s) && !isSimpleState(s) &&
			!hasSignalsVariables(s) && hasParentMacroState(s) && !isParallelMacroState(s): (
                    let p = s.parentRegion.parentState:
					// check now if suspension actions can be combined
					(if (s.suspensionTrigger != null && p.suspensionTrigger != null) then (
  	                       (if (s.suspensionTrigger.delay == p.suspensionTrigger.delay
  	                           && s.suspensionTrigger.isImmediate == p.suspensionTrigger.isImmediate) then (
  	                             true
  	                          )
  	                          else 
  	                             false)
  	                )
  	                else
  	                  true)
	    )
		default: false
	}
;

Void rule6(State s, List[State] states):
	let r = s.regions.first():
	let initial = findInitialState(r):
	let finalMacros = r.states.select(e|!isSimpleState(e) && e.isFinal):
	let finalSimples = r.states.select(e|isSimpleState(e) && e.isFinal):
	let incomingTrans = s.incomingTransitions.copyListTrans():
	let normalTerms = s.outgoingTransitions.select(e|e.type == TransitionType::NORMALTERMINATION):
	
	// do not make states without incoming transitions or only one selfloop noninitial
	if (!incomingTrans.isEmpty) then
		(if (!s.hasOnlySelfLoop()) then
			initial.setIsInitial(false)) ->
			
	// reroute all incoming transitions to the initial state
	incomingTrans.setTargetState(initial) ->
	initial.incomingTransitions.addAll(incomingTrans) ->
		
	// if normal termination exist 
	(s.outgoingTransitions.size == 1) ?
	(
	// final macros become nonfinal 
	finalMacros.setIsFinal(false) ->
	// final simples become nonfinal
	finalSimples.setIsFinal(false) ->
	
	finalSimples.createImmediateWeakAbortTo(s.outgoingTransitions.get(0).targetState, 
		s.outgoingTransitions.get(0)) ->
	if !normalTerms.isEmpty then
		finalMacros.copyNormalTransitionFrom(normalTerms.get(0))
	)
	: s

	
	// copy whole stuff 
	->
	(let copyStates = r.states.copyListTrans():
	s.parentRegion.states.addAll(copyStates) ->
	// add the inner states to the list, as there might be new optimization potential
	states.addToFrontOfList(copyStates)
	) 
	
	->
	
	// remove old normal termination and old state
	if (!normalTerms.isEmpty) then
		normalTerms.removeTransition() ->
		
	// combine any suspension triggers
	(
	if (s.suspensionTrigger != null) then (
   	  let p = s.parentRegion.parentState:
	  if (p.suspensionTrigger != null) then (
	     // combine both actions to one
	     let action = new Action:
	     let expression = new OperatorExpression:
	     action.effects.addAll(p.suspensionTrigger.effects) ->
	     action.effects.addAll(s.suspensionTrigger.effects) ->
	     action.setDelay(initial.suspensionTrigger.delay) -> // must be equal
	     action.setIsImmediate(s.suspensionTrigger.isImmediate) -> //must be equal  
	     expression.subExpressions.add(p.suspensionTrigger.trigger) ->
	     expression.subExpressions.add(s.suspensionTrigger.trigger) ->
	     expression.setOperator(OperatorType::OR) ->
	     action.setTrigger(expression) ->
	     r.setSuspensionTrigger(action)
	  )
	  else (
	     p.setSuspensionTrigger(s.suspensionTrigger)
	  )
	)
	) ->

	// remove unnecessary state			
	s.removeStateFromRegion()
;

/** !- 
	(rule7) : remove macrostates which have only two substates
*/
Boolean rule7applies(State s):
	switch {
		case !isSimpleState(s) && s.hasParentMacroState() && s.hasNumberOfSubStates(1) 
			&& !hasSignalsVariables(s):
				true
		default: false
	}
;

Void rule7(State s):
	// make sure in case of multiple regions no nullpointer is thrown
	let parentReg = s.parentRegion:
	let incomingT = s.incomingTransitions.copyListTrans():
	let outgoingT = s.outgoingTransitions.copyListTrans():
	let states = (List[State]) {}:
	s.regions.collectStates(states) ->
	(let found = states.get(0):
	 parentReg.states.add(found) ->
	 incomingT.setTargetState(found) ->
	 outgoingT.setSourceState(found)
	) ->
	s.removeStateFromRegion()
; 

/** !- 
	(rule8) : test the final character of a macrostate
		if final, is macrostate, has no final states as children 
*/
Boolean rule8applies(State s):
	switch {
		case !isSimpleState(s) && s.isFinal && !s.hasFinalSubState():
				true
		default: false
	}
;

Void rule8(State s):
	s.setIsFinal(false)
;
