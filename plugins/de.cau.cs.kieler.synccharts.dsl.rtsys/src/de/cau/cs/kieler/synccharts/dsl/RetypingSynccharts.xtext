/******************************************************************************
 * KIELER - Kiel Integrated Environment for Layout for the Eclipse RCP
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright ${year} by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 ******************************************************************************//******************************************************************************
 * Namenueberlegungen fuer die neue Sprache:
 * RTSYS - ReTyped Synccharts
 * RTSYS - ReTouched Synccharts
 * RTSYS - ReTentive Language for Synccharts
 * RTSYS - RevisiTing Synccharts
 * RTSYS - Rational Text for Synccharts // alle anderen waren irrational:p
 * RTSYS - Recasting Synccharts (ReKasting fuer KIEL?) //unsmypatisch
 * RTSYS - Recapulated Synccharts (ReKapulated fuer KIEL?) //uebertrieben
 * RVH - Rational and Visionary Handling of Synccharts //Vision find ich passend:) 
 * SEWINCH -Simple Way of Editing Synccharts // Sevinc halam -- DA Name?
 * KITTY - KIeler TexTual sYnccharts // ssssuessss 
 ******************************************************************************/grammar
de.cau.cs.kieler.synccharts.dsl.RetypingSynccharts with org.eclipse.xtext.common.
Terminals

generate retypingSynccharts
"http://www.cau.de/cs/kieler/synccharts/dsl/RetypingSynccharts" //import "platform:/resource/de.cau.cs.kieler.synccharts.labelparser/src-gen/de/cau/cs/kieler/synccharts/TransitionLabel.ecore" as transitionlabel


import "http://www.eclipse.org/emf/2002/Ecore" as ecore
//StateList:
//	(states+=State)*
//;

State:
//!!!!!!!!!! DO NOT USE THE FOLLOWING RULE !!!!!!!!!! //
  //((isInitial?='init')|(isFinal?='final')|(stateKind=StateType)?)*
  // you have to list all possible combinations seperately 
  // arbitrary positions for optional alternatives is not possible
  // or you have to use ((..)?(..)?)* and then validate them manually   
  (	(isInitial?='init')
  | (isInitial?='init' isFinal?='final') 
  | (isInitial?='init' stateKind=StateType)
  | (stateKind=StateType)
  | (stateKind=StateType isInitial?='init') 
  | (stateKind=StateType isFinal?='final') 
  | (isFinal?='final')
  | (isFinal?='final' isInitial?='init') 
  | (isFinal?='final' stateKind=StateType) 
  | (stateKind=StateType isFinal?='final' isInitial?='init') 
  | (isInitial?='init' isFinal?='final' (stateKind=StateType))
  | (isInitial?='init' isFinal?='final' (stateKind=StateType))
  | (isInitial?='init' (stateKind=StateType) isFinal?='final')
  | (isFinal?='final' isInitial?='init' (stateKind=StateType))
  | (isFinal?='final' (stateKind=StateType) isInitial?='init') 
  | ((stateKind=StateType) isInitial?='init' isFinal?='final') 
  | ((stateKind=StateType)  isFinal?='final' isInitial?='init')
  )?
  
  ('state')? // optional keyword, cf.Meeting_TextualSyntax-II
  (stateName=ID)? //optionale ID (Remember: "Kein ID ist auch ein eindeutiges ID!!")
  (label=STRING)? 
//  (stateContent=StateContent)?
  //	(outgoingTransitions+=Transition)*
; 
//StateContent:
//	'{'
////	(regions+=Region)*
//	(		(exitActions+=ExitAction )
//		| 	(entryActions+=EntryAction)
//		| 	(innerAction+=InnerAction)
////		| 	(signalsAndVariables+=ValuedObject)?
//		|	(innerStates+=State	('||' parallelStates+=State)*)
//	)+	
//	'}'
//;


enum StateType:
  NORMAL | PSEUDO='cond' | REFERENCE='reference' | TEXTUAL='textual'; 
//////Effect:
//////	effectID=STRING
//////;
EntryAction returns Action:// transitionlabel::Action :
	'onentry' entryAction=STRING;//(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;  //do we need both in one list: triggersAndEffects?

ExitAction returns Action :
	'onexit' exit=STRING;//(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 

InnerAction returns Action :
	'oninner' inner=STRING;//(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 

//ValuedObject:
//	Signal | Variable
//;
////Signal:
////	(isLocal?='local')? (isInput?='input')? (isOutput?='output')?
////	type=ValueType name=ID (':=' initialValue=ID)? 
////	//combineOperator=CombineOperator 
////;
//////enum CombineOperator :
//////NONE='none' | ADD='add' | MULT='mult' | HOST='host'
//////;
////Variable:
////	type=ValueType name=ID (':=' initialValue=ID)? 
////;
////enum ValueType:
////	PURE | BOOL | UNSIGNED | INTEGER | DOUBLE | HOST
////;	
//Transition:
//	(sourceStateName=ID)? 
//	transitionType=TransitionType 
//	(targetStateName=ID | declaredTargetState=declaredTargetState)  
//	('with' transitionLabel=[Action])?
////			(isHistory?='history')?
////			
////		( 	(delay=INT) (trigger=ID)
//////		|	(delay=INT) ('/'effects+=ID)				
////		| 	(delay=INT) (trigger=ID)('/'effects+=ID)
////		|	(isImmediate?='#') (trigger=ID)? ('/'effects+=ID)?
////		|   ((trigger=ID) | ('/'effects+=ID))
////		| 	(trigger=ID) ('/'effects+=ID)
////		)	
////)?
//;
//enum TransitionType :
//	STRONGABORT='o->' | WEAKABORT='-->' | NORMALTERMINATION='>->'
//;	
//declaredTargetState returns State:
//	(isInitial?='init')? (isFinal?='final')? 'state' 
//	(declaredStateType=StateType)? declaredStateName=ID
//;
//
////=======================================================================================================//
//Action :
//	//(isImmediate?='#' | delay=INT)? (trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?;
//	(trigger=PrimaryExpression)? ("/" (effects+=Effect)*)?; 		
//
//Effect : 
//	Emission | Assignment | HostCode;
//
//Emission :
//	signal=[Signal] ("(" newValue=PrimaryExpression ")")?;
//
//Assignment :
//	variable=[Variable] ":=" expression=PrimaryExpression;
//
//SignalReference:
//	reference = [Signal];
//	
//VariableReference:
//	reference = [Variable];
//ValuedObject:
//	Signal | Variable
//;
//Signal:
//	"input" name = ID (':=' initialValue=ID)?";";
//
//Variable:
//	"var" name = ID (':=' initialValue=ID)?";";
//
//IntValue: 
//	value=INT;
//FloatValue:
//    value=Float;
//BooleanValue:
//    value=Boolean;
//Value:
//	IntValue | FloatValue | BooleanValue;
//
//// make sure the Float rule does not shadow the built-in INT rule
//terminal Float returns ecore::EDouble : ((INT"."INT | INT("."INT)?("e"|"E")("-"|"+")?INT))"f"? | INT"f";
//terminal Boolean returns ecore::EBoolean : "true" | "false";
//
//HostCode:
//	//"'"code=STRING"'";
//	//("(" type=ID ")")? 
//	code=STRING; 	
//	
//Operator :
//	operatorKind=OperatorKind;
//
//ValOperation returns Expression:
//	operator=ValOperator subExpressions+=SignalReference;
//
//ValueExpression returns Expression:
//	IntValue | FloatValue | ValOperation | VariableReference;
//
//CompareOperation returns Expression:
//	ValueExpression ({Operation.subExpressions+=current} operator=CompareOperator subExpressions+=ValueExpression);  	
//
//NotOperation returns Operations:
//	operators=NotOperator subExpressions+=BooleanExpression;
//
//NotOrNormalExpression returns Expression:
//	NotOperation | BooleanExpression;
//
//AndOperation returns Expression:
//	NotOrNormalExpression ({Operation.subExpression+=current} operator=OperatorAnd subExpression+=NotOrNormalExpression)*;
//
//OrOperation returns Expression:
//	AndOperation ({Operation.subExpressions+=current} operator=OperatorOr subExpressions+=AndOperation)*;
//
//// TODO: get rid of parentheses
//BooleanExpression returns Expression:
//	BooleanValue | SignalReference | CompareOperation | "("OrOperation")" ;
//
//PrimaryExpression returns Expression:
//	//ValueExpression | BooleanExpression;
//	BooleanExpression;
//	
//enum OperatorKind :
//	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NOT="not"| AND="and" | OR="or" | ADD="+" | SUB="-" | MULT="*" | DIV="div" | MOD="mod" | VAL="?" | PRE="pre";
//
//enum ValOperator returns OperatorKind:
//	VAL="?";
//
//enum CompareOperator returns OperatorKind:
//	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=";
//	
//enum NotOperator returns OperatorKind:
//	NOT="not";
//
//enum OperatorOr returns OperatorKind:
//	OR="or";
//
//enum OperatorAnd returns OperatorKind:
//	AND="and";
