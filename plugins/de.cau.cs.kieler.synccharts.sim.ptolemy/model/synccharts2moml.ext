import synccharts;
import Moml;

//-----------------------------------------------------------------------------
//--            S S M - 2 - P T O       T R A N S F O R M A T I O N          --
//-----------------------------------------------------------------------------

//Start Model Transformation here
create DocumentRoot this transform(synccharts::Region sc):
 	this.setEntity(createBaseEntity(sc))
;   
	
	
//-----------------------------------------------------------------------------
//--       B A S I C   M O M L - E N T I T I E S   C R E A T I O N           --
//-----------------------------------------------------------------------------


Void addLink(EntityType baseEntity, String port, String relation) :
	let l = new LinkType:
	l.setPort(port) ->
	l.setRelation(relation) ->
   //if not already exists
   (baseEntity.link.select(ee|ee.port.matches(l.port)
   						   && ee.relation.matches(l.relation)).size == 0) ?
		baseEntity.link.add(l) : null
;

Void addRelation(EntityType baseEntity, String name, String property) :
	let r = new RelationType:
    let p1 = new PropertyType:
    let p2 = new PropertyType:
    let v = new VertexType:
	r.setName(name) ->
    r.setClass("ptolemy.actor.TypedIORelation") ->
   		p1.setName("width") ->
   		p2.setName(property) ->
   		p1.setClass("ptolemy.data.expr.Parameter") ->
   		p1.setValue("-1") ->
   	r.property.add(p1) ->
   //if not already exists
   (baseEntity.relation.select(ee|ee.name.matches(r.name)).size == 0) ?
		   baseEntity.relation.add(r) : null
;


Void addVertexRelation(EntityType baseEntity, String name, String property) :
	let r = new RelationType:
    let p1 = new PropertyType:
    let p2 = new PropertyType:
    let v = new VertexType:
	r.setName(name) ->
    r.setClass("ptolemy.actor.TypedIORelation") ->
   		p1.setName("width") ->
   		p2.setName(property) ->
   		p1.setClass("ptolemy.data.expr.Parameter") ->
   		p1.setValue("-1") ->
   		v.setName(name+"VERTEX") ->
   		v.setValue("{0.0, 0.0}") ->
   	r.property.add(p1) ->
   	//r.property.add(p2) ->
   	r.vertex.add(v) ->
   //if not already exists
   (baseEntity.relation.select(ee|ee.name.matches(r.name)).size == 0) ?
	   baseEntity.relation.add(r) : null 
;


Void addLocigalFunction(EntityType baseEntity, String name, String function) :
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   let p3 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.lib.logic.LogicFunction") ->
   	p1.setName("function") ->
   	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
   	p1.setValue(function) ->
   	p2.setName("_icon") ->
   	p2.setClass("ptolemy.vergil.icon.AttributeValueIcon") ->
   		p3.setName("attributeName") ->
   		p3.setClass("ptolemy.kernel.util.StringAttribute") ->
   		p3.setValue("function") ->
    p2.property.add(p3) ->
   e.property.add(p1) ->
   e.property.add(p2) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
		  baseEntity.entity.add(e) : null
; 


Void addIntCombineFunction(EntityType baseEntity, String name) :
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   let p3 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.lib.AddSubtract") ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   


Void addEnvironmentIntCombineFunction(EntityType baseEntity, String name, String signalID) :
   let e = new EntityType:
   let p1 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.lib.AddSubtract") ->
   	p1.setName("signal name") ->
   	p1.setClass("ptolemy.data.expr.Parameter") ->
   	p1.setValue("'"+signalID+"'") ->
   e.property.add(p1) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   
  

Void addKielerNormalTermination(EntityType baseEntity) :
   let e = new EntityType:
   e.setName("KielerNormalTermination") ->
   e.setClass1("ptolemy.actor.kiel.KielerNormalTermination") ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   
  
Void addKielerIO(EntityType baseEntity, String name, String signalID) :
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   let p3 = new PropertyType:
   let port = new PortType:
    let p4 = new PropertyType:
    let p5 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.kiel.KielerIO") ->
   	p1.setName("signal name") ->
   	p1.setClass("ptolemy.data.expr.Parameter") ->
   	p1.setValue("'"+signalID+"'") ->
   	port.setName("signal") ->
   	port.setClass("ptolemy.actor.TypedIOPort") ->
 	  	p4.setName("output") ->
 	  	p5.setName("_type") ->
 	  	p5.setClass("ptolemy.actor.TypeAttribute") ->
 	  	p5.setValue("int") ->
 	port.property.add(p4) ->
 	port.property.add(p5) ->
   e.port.add(port) ->	
   e.property.add(p1) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
		  baseEntity.entity.add(e) : null
;

Void addConstant(EntityType baseEntity, String value):
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   let p3 = new PropertyType:
   let p4 = new PropertyType:
   let p5 = new PropertyType:
   p1.setName("Const") ->
   p1.setClass("ptolemy.actor.lib.Const") ->
   	p2.setName("value") ->
   	p2.setClass("ptolemy.data.expr.Parameter") ->
   	p2.setValue(value) ->
   		p3.setName("_icon") ->
   		p3.setClass("ptolemy.vergil.icon.BoxedValueIcon") ->
   			p4.setName("attributeName") ->
   			p4.setClass("ptolemy.kernel.util.StringAttribute") ->
   			p4.setValue("value") ->
   			p5.setName("displayWidth") ->
   			p5.setClass("ptolemy.data.expr.Parameter") ->
   			p5.setValue("60") ->
   		p3.property.add(p4) ->
   		p3.property.add(p5) ->
   	p2.property.add(p3) ->
   e.property.add(p1) ->
   e.property.add(p2) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
   			baseEntity.entity.add(e) : null
;


//create basic / outer most enclosing entity	
create EntityType this createBaseEntity(synccharts::Region mainRegion):
   	this.setName(hash(getURIFragment(mainRegion.innerStates.get(0))) + "_simulation") ->
  	this.setClass1("ptolemy.actor.TypedCompositeActor") ->
   	this.property.add(createMainSRDirector()) ->
   	//mainRegion has exactly ONE top most state
   	//iterate over all regions within this top most state
   	//the  of this containing Entity is derived from this
   	//   top most state, w/ " simulation" added
    IterateRegions(mainRegion.innerStates.get(0).regions, this, mainRegion.innerStates.get(0).signals) ->
    //add "this" EntityType so that IterateRegions is able to add 
    //new entities or properties
    
    //connect most top input signals
    ConnectTopmostInputSignals(this, this.entity)
;

//-----------------------------------------------------------------------------


//connect top most input signals
Void ConnectTopmostInputSignals(EntityType baseEntity, List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectTopmostInputSignalsHelper(baseEntity, firstEntity.name, firstEntity.port) : null ->
	(entityList.size > 0) ?
		ConnectTopmostInputSignals(baseEntity, entityList.withoutFirst()) : null
;
Void ConnectTopmostInputSignalsHelper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	//for only input ports (that have a property with the name "*_input")
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addVertexRelation(baseEntity, firstPort.name + "_RELATION", "environment_input") : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + "_RELATION") : null ->
		
	//create kielerIO for every environment input and connect it	
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addKielerIO(baseEntity, firstPort.name + "_KIELERIO", firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_KIELERIO.signal", firstPort.name + "_RELATION") : null ->

	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addVertexRelation(baseEntity, firstPort.name + "_RELATION", "local_input") : null ->
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + "_RELATION") : null ->
 
	//generate ADD-functions and connect local outputs to it
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addIntCombineFunction(baseEntity, firstPort.name + "_COMBINE") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addRelation(baseEntity, firstPort.name + "_COMBINERELATION", "local_output") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_COMBINE.plus", firstPort.name + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + "_COMBINERELATION") : null ->

	//connect local input vertex with output combine OR function operators
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_COMBINE.output", firstPort.name + "_RELATION") : null ->
	
	//generate ADD-functions and connect environment outputs to it
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addEnvironmentIntCombineFunction(baseEntity, firstPort.name + "_COMBINE", firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addRelation(baseEntity, firstPort.name + modalModelName + "_COMBINERELATION", "environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_COMBINE.plus", firstPort.name + modalModelName + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + modalModelName + "_COMBINERELATION") : null ->


	(portList.size > 0) ?
		ConnectTopmostInputSignalsHelper(baseEntity, modalModelName, portList.withoutFirst()) : null
;


//-----------------------------------------------------------------------------

//connect nested input signals
Void ConnectNestedInputSignals(EntityType baseEntity, List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectNestedInputSignalsHelper(baseEntity, firstEntity.name, firstEntity.port) : null ->
	(entityList.size > 0) ?
		ConnectNestedInputSignals(baseEntity, entityList.withoutFirst()) : null
;
Void ConnectNestedInputSignalsHelper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	//for termination ports
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addRelation(baseEntity, firstPort.name + "_COMBINERELATION", "termination") : null ->
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addLink(baseEntity, "KielerNormalTermination.state terminated", firstPort.name + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + "_COMBINERELATION") : null ->
	
	//for only input ports (that have a property with the name "*_input")
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addVertexRelation(baseEntity, firstPort.name + "_RELATION", "environment_input") : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + "_RELATION") : null ->
		
	//connect every environment input to relation	
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, firstPort.name, firstPort.name + "_RELATION") : null ->

	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addVertexRelation(baseEntity, firstPort.name + "_RELATION", "local_input") : null ->
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + "_RELATION") : null ->
 
	//generate ADD-functions and connect local outputs to it
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addIntCombineFunction(baseEntity, firstPort.name + "_COMBINE") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addRelation(baseEntity, firstPort.name + "_COMBINERELATION", "local_output") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_COMBINE.plus", firstPort.name + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + "_COMBINERELATION") : null ->

	//connect local input vertex with output combine OR function operators
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_COMBINE.output", firstPort.name + "_RELATION") : null ->

	//generate ADD-functions and connect environment outputs to it
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addEnvironmentIntCombineFunction(baseEntity, firstPort.name + "_COMBINE", firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addRelation(baseEntity, firstPort.name + modalModelName + "_COMBINERELATION", "environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_COMBINE.plus", firstPort.name + modalModelName + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, modalModelName + "." + firstPort.name, firstPort.name + modalModelName + "_COMBINERELATION") : null ->

	//connect combine function w/ output ports
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addVertexRelation(baseEntity, firstPort.name + "_RELATION", "environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, firstPort.name, firstPort.name + "_RELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, firstPort.name + "_COMBINE.output", firstPort.name + "_RELATION") : null ->
	
	

	(portList.size > 0) ?
		ConnectNestedInputSignalsHelper(baseEntity, modalModelName, portList.withoutFirst()) : null
;

//-----------------------------------------------------------------------------


//create ModalModel == Region-Component 
create EntityType this createModalModelEntity(synccharts::Region region, 
											  int number, 
											  List[synccharts::Signal] signalList):
	let p1 = new PropertyType:
		p1.setName("_tableauFactory") ->
		//p1.setClass("ptolemy.vergil.fsm.modal.ModalTableauFactory") -> //CHANGED 16.09.2009
		p1.setClass("ptolemy.vergil.modal.modal.ModalTableauFactory") ->
	this.property.add(p1) ->
   	this.setName(hash(getURIFragment(region.parentState)) + "_region_" + number) ->
  	//this.setClass1("ptolemy.domains.fsm.modal.ModalModel") -> // CHANGED 16.09.2009
  	this.setClass1("ptolemy.domains.modal.modal.ModalModel") ->
  	//first add signals
  	addSignalsToModalModel(this, signalList, region) ->
  	//then add termination signal (outer)
  	addTerminationSignalToModalModel(this, region) ->
  	//then add termination signals (inner)
  	addTerminationSignalsToModalModel(this, region.innerStates) ->
  	//then create simple states and macro state declarations
   	this.entity.add(createModalControllerEntity(region, signalList)) ->
   	//then add macro state refinements (for all macro states)
   	IterateStatesRefinement(region.innerStates, this, signalList)
;
//create ModalController == Region-Declaration (simple states and macro states declarations)
create EntityType this createModalControllerEntity(synccharts::Region region,
												   List[synccharts::Signal] signalList):
   	this.setName("_Controller") ->
  	//this.setClass1("ptolemy.domains.fsm.modal.ModalController") -> //CHANGED 16.09.2009
  	this.setClass1("ptolemy.domains.modal.modal.ModalController") ->
  	//first add signals 
	addSignalsToModalController(this, null, signalList, region) ->
  	//add termination signal
	this.addTerminationSignalToModalController(null, region.parentState) ->
  	//add termination signals 
	this.addTerminationSignalsToModalController(null, region.innerStates) ->
  	//then iterated all states (if any in this region)
	(region.innerStates.size > 0) ? IterateStates(region.innerStates, this) : null
;


//create MacroState == State-Component (of a macro state)
create EntityType this createMacroStateEntity(synccharts::State state):
	let p1 = new PropertyType:
		p1.setName("refinementName") ->
		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
		p1.setValue(hash(getURIFragment(state))) ->
   	this.setName(hash(getURIFragment(state))) ->
  	//this.setClass1("ptolemy.domains.fsm.kernel.State") -> //CHANGED 16.09.2009
  	this.setClass1("ptolemy.domains.modal.kernel.State") ->
	this.property.add(p1) ->
  	SetStateInitialFinalFlag(state, this)
;
//create ModalRefinement == State-Definition (of a macro state /w regions)
create EntityType this createMacroStateRefinementEntity(synccharts::State state, EntityType modalModel,
														List[synccharts::Signal] signalList):
   	this.setName(hash(getURIFragment(state))) ->
  	//this.setClass1("ptolemy.domains.fsm.modal.Refinement") -> //CHANGED 16.09.2009
  	this.setClass1("ptolemy.domains.modal.modal.Refinement") ->
   	this.property.add(createSRDirector()) ->
   	signalList.addAll(state.signals) ->
   	//add signals to refinement (so that outer signals are visible inside)
   	this.addSignalsToModalController(modalModel, signalList, state.parentRegion) ->
   	//add termination signal
   	this.addTerminationSignalToModalController(modalModel, state) ->
   	//add KielerNormalTermination
   	this.addKielerNormalTermination() ->
   	
   	IterateRegions(state.regions, this, signalList) ->
    //connect nested input signals
    ConnectNestedInputSignals(this, this.entity)
;
//create SimpleState == State-Component 
create EntityType this createSimpleStateEntity(synccharts::State state):
   	this.setName(hash(getURIFragment(state))) ->
  	//this.setClass1("ptolemy.domains.fsm.kernel.State") -> //CHANGED 16.09.2009
  	this.setClass1("ptolemy.domains.modal.kernel.State") ->
  	SetStateInitialFinalFlag(state, this)
;


//-----------------------------------------------------------------------------
//--                   H E L P E R    F U N C T I O N S                      --
//-----------------------------------------------------------------------------

//do some java console output for debugging purpose 
Void dump(String s) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.dump(java.lang.String)
;

//get URIFragment of an model element to identify it 
String getURIFragment(synccharts::State state) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			getURIFragment(de.cau.cs.kieler.synccharts.State)
;

//get hash value of a string 
String hash(String s) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			hash(java.lang.String)
;


//get URIFragment of an model element to identify it 
int getPortType(synccharts::Signal signal, synccharts::Region region) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			getPortType(de.cau.cs.kieler.synccharts.Signal,
						de.cau.cs.kieler.synccharts.Region)
;


//decide whether a states is initial or final and add the appropriate
//property to the entity
Void SetStateInitialFinalFlag(synccharts::State state, EntityType entity) :
	let p1a = new PropertyType:
	let p1b = new PropertyType:
	let p2 = new PropertyType:
		p1a.setName("isInitialState") ->
		p1a.setClass("ptolemy.data.expr.Parameter") ->
		p1a.setValue("true") ->
		p1b.setName("isInitialState") ->
		p1b.setClass("ptolemy.data.expr.Parameter") ->
		p1b.setValue("false") ->
		p2.setName("isFinalState") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
  	state.isInitial ? entity.property.add(p1a) : entity.property.add(p1b)
  	//do not set it to final, otherwise it can't even being reset! 
  	//state.stateFlag.toString().matches("FINAL") ? entity.property.add(p2) : null
;

//test whether a state is a macro state or a simple state
boolean isMacroState(synccharts::State state) :
 	state.regions.size > 0
; 


//-----------------------------------------------------------------------------
//--                       I T E R A T I O N S                               --
//-----------------------------------------------------------------------------

//iteratate over all states (in a region)
//for  macro states : add states entity AND list them as a refinement property
//for simple states : add states
Void IterateTransitions(List[synccharts::Transition] transitionList,
							 EntityType entity):
 	let transition = transitionList.last():
 	(transitionList.size > 0) ? dump(hash(getURIFragment(transition.sourceState)) + " -> " + hash(getURIFragment(transition.targetState))) : null ->
	(transitionList.size > 0) ? addTransition(transition,
				  							  entity,
				  							  hash(getURIFragment(transition.sourceState)) + "_transition_" + transitionList.size) :null -> 	
    (transitionList.size > 1) ? IterateTransitions(transitionList.withoutLast(), entity) : null
;


//iteratate over all states (in a region)
//for  macro states : add states entity AND list them as a refinement property
//for simple states : add states
Void IterateStates(List[synccharts::State] stateList, 
						EntityType entity):
 	let state = stateList.last():
 	state.isMacroState() ? entity.entity.add(createMacroStateEntity(state)) 
 					    : entity.entity.add(createSimpleStateEntity(state)) ->
 	IterateTransitions(state.outgoingTransitions, entity) ->
    (stateList.size > 1) ? IterateStates(stateList.withoutLast(), entity) : null
;

//iteratate over all states (in a region)
//for  macro states : define the refinement (and recursively add regions!)
//for simple states : do nothing
Void IterateStatesRefinement(List[synccharts::State] stateList, 
								  EntityType entity, 
								  List[synccharts::Signal] signalList):
 	let state = stateList.last():
 	state.isMacroState() ? entity.entity.add(
 							createMacroStateRefinementEntity(state, entity, signalList)) 
 						: null ->
    (stateList.size > 1) ? IterateStatesRefinement(stateList.withoutLast(), entity, signalList) : null
;


//iterate over all regions (in a state)
//add an own modal model for each region
//define all signals that are defined until now!
Void IterateRegions(List[synccharts::Region] regionList, 
						EntityType entity, 
						List[synccharts::Signal] signalList):
 	let region = regionList.last():
 	entity.entity.add(createModalModelEntity(region, regionList.size, signalList)) ->
    (regionList.size > 1) ? IterateRegions(regionList.withoutLast(), entity, signalList) : null 
; 


//-----------------------------------------------------------------------------
//--                 C R E A T E     D I R E C T O R S                       --
//-----------------------------------------------------------------------------

//create a "SR Director" (for macro state definition)
create PropertyType this createSRDirector():
    this.setName("SR Director") ->
	this.setClass("ptolemy.domains.sr.kernel.SRDirector")
;

//create outer most "SR Director" (ticks every seconds)
create PropertyType this createMainSRDirector():
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4 = new PropertyType:
		p1.setName("iterations") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("100") ->
		p2.setName("synchronizeToRealTime") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
		p3.setName("timeResolution") ->
		p3.setClass("ptolemy.data.expr.Parameter") ->
		p3.setValue("1.0E-10") ->
		p4.setName("period") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		p4.setValue("1") ->
    this.setName("SR Director") ->
	this.setClass("ptolemy.domains.sr.kernel.SRDirector") ->
	this.property.add(p1) ->
	this.property.add(p2) ->
	this.property.add(p3) ->
	this.property.add(p4)
;


//create a "FSM Director" (for a region component)
//create PropertyType this createFSMDirector():
//    this.setName("directorClass") ->
//    this.setValue("ptolemy.domains.fsm.kernel.FSMDirector") ->
//	this.setClass("ptolemy.data.expr.StringParameter")
//;

//create a "DE Director" (for the outer most entity)
create PropertyType this createDEDirector():
	let p1 = new PropertyType:
	let p2 = new PropertyType:
		p1.setName("stopTime") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("Infinity") ->
		p2.setName("synchronizeToRealTime") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
    this.setName("DE Director") ->
	this.setClass("ptolemy.domains.de.kernel.DEDirector") ->
	this.property.add(p1) ->
	this.property.add(p2)
;

//-----------------------------------------------------------------------------
//--         C R E A T E     R E L A T I O N S   &   L I N K S               --
//-----------------------------------------------------------------------------

Void addTransition(	synccharts::Transition transition, 
					EntityType entity,
					String name) :
	let link1 = new LinkType:
	let link2 = new LinkType:
	link1.setPort(hash(getURIFragment(transition.sourceState)) + ".outgoingPort") ->
	link1.setRelation(name) ->
	link2.setPort(hash(getURIFragment(transition.targetState)) + ".incomingPort") ->
	link2.setRelation(name) ->
	entity.relation.add(createRelation(name, transition)) ->
	entity.link.add(link1) ->
	entity.link.add(link2) 
;

//create a Relation Type for a Port connection to a ModalController or ModalModel
Void addPortRelationAndLinks(EntityType entity, String portName):
    let relation = new RelationType:
	let p1 = new PropertyType:
	let link1 = new LinkType:
	let link2 = new LinkType: 
		p1.setName("width") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("Auto") ->
    relation.setName(portName + "Relation") ->
    relation.setClass("ptolemy.actor.TypedIORelation") ->
	relation.property.add(p1) ->
	link1.setPort(portName) ->
	link1.setRelation(portName + "Relation") ->
	link2.setPort("_Controller." + portName) ->
	link2.setRelation(portName + "Relation") ->
	entity.relation.add(relation) ->
	entity.link.add(link1) ->
	entity.link.add(link2)
;


//create a Relation Type for State2State transitions
create RelationType this createRelation(String name,
										synccharts::Transition transition):
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4 = new PropertyType:
	let p5 = new PropertyType:
	let p6 = new PropertyType:
	let p7 = new PropertyType:
	let p8 = new PropertyType:
		p1.setName("guardExpression") ->
		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
		p2.setName("outputActions") ->
		//p2.setClass("ptolemy.domains.fsm.kernel.OutputActionsAttribute") -> //CHANGED 16.09.2009
		p2.setClass("ptolemy.domains.modal.kernel.OutputActionsAttribute") ->
		p3.setName("setActions") ->
		//p3.setClass("ptolemy.domains.fsm.kernel.CommitActionsAttribute") -> //CHANGED 16.09.2009
		p3.setClass("ptolemy.domains.modal.kernel.CommitActionsAttribute") ->
		p4.setName("reset") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		//by default in SyncCharts we have a reset behavior unless its 
		//a history transition
		(!transition.isHistory) ? p4.setValue("true") : p4.setValue("false") ->
		p5.setName("preemptive") ->
		p5.setClass("ptolemy.data.expr.Parameter") ->
		transition.type.toString().matches("STRONGABORT") ? 
								p5.setValue("true") : p5.setValue("false") ->
		p6.setName("defaultTransition") ->
		p6.setClass("ptolemy.data.expr.Parameter") ->
		p6.setValue("false") -> //defaultTransition is NOT "normal termination" !!!
		//transition.transitionKind.toString().matches("NORMALTERMINATION") ? 
		//						p6.setValue("true") : p6.setValue("false") ->
		p7.setName("nondeterministic") ->
		p7.setClass("ptolemy.data.expr.Parameter") ->
		p7.setValue("false") ->
		p8.setName("refinementName") ->
		p8.setClass("ptolemy.kernel.util.StringAttribute") ->
    this.setName(name) ->
	this.property.add(p1) ->
	this.property.add(p2) ->
	this.property.add(p3) ->
	this.property.add(p4) ->
	this.property.add(p5) ->
	this.property.add(p6) ->
	this.property.add(p7) ->
	this.property.add(p8) ->
	addTrigger(this, transition) ->
	addEmission(this, transition)
;

//-----------------------------------------------------------------------------
//--                    C R E A T E     S I G N A L S                        --
//-----------------------------------------------------------------------------

Void addTerminationSignalToModalController(EntityType entity, 
										   EntityType parent, 
										   synccharts::State state) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:

	let stateName = parent.name:
	let l = new LinkType:

	port.setName("terminated" + hash(getURIFragment(state))) ->
	port.setClass("ptolemy.domains.modal.modal.RefinementPort") ->
	p1.setName("output") ->
	p2.setName("_type") ->
	p2.setClass("ptolemy.actor.TypeAttribute") ->
	p2.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF KIELER-IO-ACTOR
	p3.setName("termination") ->
   	p3.setClass("ptolemy.kernel.util.StringAttribute") ->
	port.property.add(p1) ->
	port.property.add(p2) ->
	port.property.add(p3) ->
	entity.port.add(port) ->
	
	//link relation
	l.setPort(stateName + "." + port.name) ->
	l.setRelation(port.name + "Relation") ->
	parent.link.add(l)
	//TODO: linkSignalRelationToState(entity, parent, "terminated")
;

Void addTerminationSignalsToModalController(EntityType entity, 
										   EntityType parent, 
										   List[synccharts::State] stateList) :
	let state = stateList.last():
	//only for macro states
	(state.isMacroState()) ?
			addTerminationSignalToModalController(entity, 
												  parent, 
												  state) : null ->
	(stateList.size > 1)?
		addTerminationSignalsToModalController(entity, parent, 
										  	  stateList.withoutLast()) : null
;


Void addTerminationSignalToModalModel(EntityType entity, synccharts::Region region) :
 	addTerminationSignalToModalModel(entity, region.parentState)
;

 
Void addTerminationSignalToModalModel(EntityType entity, synccharts::State state) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	port.setName("terminated" + hash(getURIFragment(state))) ->
	port.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	p1.setName("output") ->
	p2.setName("_type") ->
	p2.setClass("ptolemy.actor.TypeAttribute") ->
	p2.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF KIELER-IO-ACTOR
	p3.setName("termination") ->
   	p3.setClass("ptolemy.kernel.util.StringAttribute") ->
	port.property.add(p1) ->
	port.property.add(p2) ->
	port.property.add(p3) ->
	entity.port.add(port) ->  
	addPortRelationAndLinks(entity, port.name)
;

Void addTerminationSignalsToModalModel(EntityType entity, List[synccharts::State] stateList) :
	let state = stateList.last():
	//only for macro states
	(state.isMacroState()) ?
		addTerminationSignalToModalModel(entity, state) : null ->  
	(stateList.size > 1)?
		addTerminationSignalsToModalModel(entity, 
										  stateList.withoutLast()) : null
;

Void addSignalsToModalModel(EntityType entity, 
							List[synccharts::Signal] signalList,
							synccharts::Region region) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4a = new PropertyType:
	let p4b = new PropertyType:
	let p4c = new PropertyType:
	let p4d = new PropertyType:
	let portType = new PropertyType:
	let signal = signalList.last():
	//port.setClass("ptolemy.domains.fsm.modal.ModalPort") -> //CHANGED 16.09.2009
	port.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	port.setName(signal.name) ->
	p4a.setName("environment_input") ->
	p4b.setName("environment_output") ->
	p4c.setName("local_input") ->
	p4d.setName("local_output") ->
	p4a.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4b.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4c.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4d.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setName((getPortType(signal, region)).toString()) ->
	//denote environmental and local input/output signals
	(signal.isInput) ? port.property.add(p4a) : null ->
	(signal.isOutput) ? port.property.add(p4b) : null ->
	(portType.name.matches("1") && signal.isLocal) ? port.property.add(p4c) : null ->
	(portType.name.matches("2") && signal.isLocal) ? port.property.add(p4d) : null ->
	p1.setName("input") ->
	p2.setName("output") ->
	(portType.name.matches("1") || signal.isInput) ? port.property.add(p1) : null ->
	(portType.name.matches("2") || signal.isOutput) ? port.property.add(p2) : null ->
	p3.setName("_type") ->
	p3.setClass("ptolemy.actor.TypeAttribute") ->
	//(signal.type.toString().matches("INTEGER")) ? p3.setValue("int") : p3.setValue("boolean") ->
	p3.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF KIELER-IO-ACTOR
	port.property.add(p3) ->
	port.property.add(portType) ->
	
	//only add ports that are used ( w/ type != 0 or -1)
	(!(portType.name.matches("0") || portType.name.matches("-1")))  ?
			entity.port.add(port) : null ->
	
	//also add necessary relation that connect above ports with the controller
	(!(portType.name.matches("0") || portType.name.matches("-1")))  ?
			addPortRelationAndLinks(entity, port.name) : null ->
	
	//if still signals remain, continue
	(signalList.size > 1) ? addSignalsToModalModel(entity,
												   signalList.withoutLast(), 
												   region) : null
;

Void addSignalsToModalController(EntityType entity, EntityType parent,
								 List[synccharts::Signal] signalList,
								 synccharts::Region region) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4a = new PropertyType:
	let p4b = new PropertyType:
	let p4c = new PropertyType:
	let p4d = new PropertyType:
	let portType = new PropertyType:
	let signal = signalList.last():
	//port.setClass("ptolemy.domains.fsm.modal.RefinementPort") -> //CHANGED 16.09.2009
	port.setClass("ptolemy.domains.modal.modal.RefinementPort") ->
	port.setName(signal.name) ->
//	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
//	p2.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4a.setName("environment_input") ->
	p4b.setName("environment_output") ->
	p4c.setName("local_input") ->
	p4d.setName("local_output") ->
	p4a.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4b.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4c.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4d.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setClass("ptolemy.kernel.util.StringAttribute") ->
	p1.setName("input") ->
	p2.setName("output") ->
	portType.setName((getPortType(signal, region)).toString()) ->
	//denote environmental and local input/output signals
	(signal.isInput) ? port.property.add(p4a) : null ->
	(signal.isOutput) ? port.property.add(p4b) : null ->
	(portType.name.matches("1") && signal.isLocal) ? port.property.add(p4c) : null ->
	(portType.name.matches("2") && signal.isLocal) ? port.property.add(p4d) : null ->
	(portType.name.matches("1") || signal.isInput) ? port.property.add(p1) : null ->
	(portType.name.matches("2") || signal.isOutput) ? port.property.add(p2) : null ->
	p3.setName("_type") ->
	p3.setClass("ptolemy.actor.TypeAttribute") ->
	//(signal.type.toString().matches("INTEGER")) ? p3.setValue("int") : p3.setValue("boolean") ->
	p3.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF KIELER-IO-ACTOR
	port.property.add(p3) ->
	port.property.add(portType) ->
	
	//only add ports that are used ( w/ type != 0 or -1)
	(!(portType.name.matches("0") || portType.name.matches("-1")))  ?
			entity.port.add(port) : null ->

	//only link ports that are used ( w/ type != 0 or -1)
	(!(portType.name.matches("0") || portType.name.matches("-1")))  ?
			linkSignalRelationToState(entity, parent, signal.name) : null ->
	
	//if still signals remain, continue
	(signalList.size > 1) ? addSignalsToModalController(entity, parent,
														signalList.withoutLast(),
														region) : null	
;

linkSignalRelationToState(EntityType modalController, EntityType parent, String signalName) :
	let stateName = modalController.name:
	let l = new LinkType:
	l.setPort(stateName + "." + signalName) ->
	dump(parent.name) ->
	dump(stateName + "." + signalName) ->
	l.setRelation(signalName + "Relation") ->
	parent.link.add(l)
;

//-----------------------------------------------------------------------------
//--         C R E A T E     T R I G G E R   /   E M I S S I O N S           --
//-----------------------------------------------------------------------------

//create guardExpression
Void addTrigger(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	//terminated source state triggers the normal termination
	let terminatedURIHash = hash(getURIFragment(transition.sourceState)):
	p1.setName("guardExpression") ->
	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
	//if normal termination, replace trigger by termination-trigger
	(transition.type.toString().matches("NORMALTERMINATION")) ? 
		p1.setValue(buildTrigger(transition.trigger, terminatedURIHash)) :
		p1.setValue(buildTrigger(transition.trigger, "")) ->
	relation.property.add(p1)
;

//create outputActions
Void addEmission(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	let terminatedURIHash = hash(getURIFragment(transition.targetState.parentRegion.parentState)):
	p1.setName("outputActions") ->
	//p1.setClass("ptolemy.domains.fsm.kernel.OutputActionsAttribute") -> CHANGED 16.09.2009
	p1.setClass("ptolemy.domains.modal.kernel.OutputActionsAttribute") ->
	//if target state is final state, then add termination-effect
	(transition.targetState.isFinal) ?
		p1.setValue(buildEffect(transition.effects, terminatedURIHash)) :
		p1.setValue(buildEffect(transition.effects, "")) ->
	relation.property.add(p1) 
;


String buildTrigger(synccharts::Expression expression, String terminatedURIHash) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			buildTrigger(de.cau.cs.kieler.synccharts.Expression, java.lang.String)
;

String buildEffect(List[synccharts::Effect] effectList, String terminatedURIHash) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			buildEffect(org.eclipse.emf.common.util.EList, java.lang.String)
;
