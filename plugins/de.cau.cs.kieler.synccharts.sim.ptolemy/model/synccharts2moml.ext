import synccharts;
import Moml;

//-----------------------------------------------------------------------------
//--     S Y N C C H A R T S - 2 - P T O     T R A N S F O R M A T I O N     --
//-----------------------------------------------------------------------------

//Start Model Transformation here.
create DocumentRoot this transform(synccharts::Region sc):
 	this.setEntity(createBaseEntity(sc))
;   
	
	
//-----------------------------------------------------------------------------
//--       B A S I C   M O M L - E N T I T I E S   C R E A T I O N           --
//-----------------------------------------------------------------------------

//Add a link between port and relation (within baseEntity).
//Only iff this link does not already exist. 
Void addLink(EntityType baseEntity, String port, String relation) :
	let l = new LinkType:
	l.setPort(port) ->
	l.setRelation(relation) ->
   //if not already exists
   (baseEntity.link.select(ee|ee.port.matches(l.port)
   						   && ee.relation.matches(l.relation)).size == 0) ?
		baseEntity.link.add(l) : null
;


//Add a relation (within baseEntity).
//Only iff this relation does not already exist. 
Void addRelation(EntityType baseEntity, String name, String property) :
	let r = new RelationType:
    let p1 = new PropertyType:
    let p2 = new PropertyType:
    let v = new VertexType:
	r.setName(name) ->
    r.setClass("ptolemy.actor.TypedIORelation") ->
   		p1.setName("width") ->
   		p2.setName(property) ->
   		p1.setClass("ptolemy.data.expr.Parameter") ->
   		p1.setValue("-1") ->
   	r.property.add(p1) ->
   //if not already exists
   (baseEntity.relation.select(ee|ee.name.matches(r.name)).size == 0) ?
		   baseEntity.relation.add(r) : null
;


//Add a vertex relation (within baseEntity).
//Only iff this vertex relation does not already exist. 
Void addVertexRelation(EntityType baseEntity, String name, String property) :
	let r = new RelationType:
    let p1 = new PropertyType:
    let p2 = new PropertyType:
    let v = new VertexType:
	r.setName(name) ->
    r.setClass("ptolemy.actor.TypedIORelation") ->
   		p1.setName("width") ->
   		p2.setName(property) ->
   		p1.setClass("ptolemy.data.expr.Parameter") ->
   		p1.setValue("-1") ->
   		v.setName(name+"VERTEX") ->
   		v.setValue("{0.0, 0.0}") ->
   	r.property.add(p1) ->
   	//r.property.add(p2) ->
   	r.vertex.add(v) ->
   //if not already exists
   (baseEntity.relation.select(ee|ee.name.matches(r.name)).size == 0) ?
	   baseEntity.relation.add(r) : null 
;


//Add a KIELER combine function for local signals (within baseEntity).
//Only iff this actor does not already exist. 
Void addCombineFunction(EntityType baseEntity, String name) :
   let e = new EntityType:
   let p1 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.kiel.KielerCombine") ->
   	p1.setName("combine function") ->
   	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
   	p1.setValue("1") ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   


//Add a KIELER combine function for environment signals (within baseEntity).
//Only iff this actor does not already exist. 
Void addEnvironmentCombineFunction(EntityType baseEntity, 
								   String name, 
								   String signalID) :
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.kiel.KielerCombine") ->
   	p2.setName("combine function") ->
   	p2.setClass("ptolemy.kernel.util.StringAttribute") ->
   	p2.setValue("1") ->
   	p1.setName("signal name") ->
   	p1.setClass("ptolemy.data.expr.Parameter") ->
   	p1.setValue("'"+signalID+"'") ->
   e.property.add(p1) ->
   e.property.add(p2) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   
  

//Add a KIELER normal termination actor (within baseEntity).
//Only iff this actors does not already exist. 
Void addKielerNormalTermination(EntityType baseEntity) :
   let e = new EntityType:
   e.setName("KielerNormalTermination") ->
   e.setClass1("ptolemy.actor.kiel.KielerNormalTermination") ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
	   baseEntity.entity.add(e) : null
;   
  

//Add a KIELER IO actor (within baseEntity).
//Only iff this actors does not already exist. 
Void addKielerIO(EntityType baseEntity, String name, String signalID) :
   let e = new EntityType:
   let p1 = new PropertyType:
   let p2 = new PropertyType:
   let p3 = new PropertyType:
   let port = new PortType:
    let p4 = new PropertyType:
    let p5 = new PropertyType:
   e.setName(name) ->
   e.setClass1("ptolemy.actor.kiel.KielerIO") ->
   	p1.setName("signal name") ->
   	p1.setClass("ptolemy.data.expr.Parameter") ->
   	p1.setValue("'"+signalID+"'") ->
   	port.setName("signal") ->
   	port.setClass("ptolemy.actor.TypedIOPort") ->
 	  	p4.setName("output") ->
 	  	p5.setName("_type") ->
 	  	p5.setClass("ptolemy.actor.TypeAttribute") ->
 	  	p5.setValue("int") ->
 	port.property.add(p4) ->
 	port.property.add(p5) ->
   e.port.add(port) ->	
   e.property.add(p1) ->
   //if not already exists
   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
		  baseEntity.entity.add(e) : null
;


//Void addConstant(EntityType baseEntity, String value):
//   let e = new EntityType:
//   let p1 = new PropertyType:
//   let p2 = new PropertyType:
//   let p3 = new PropertyType:
//   let p4 = new PropertyType:
//   let p5 = new PropertyType:
//   p1.setName("Const") ->
//  p1.setClass("ptolemy.actor.lib.Const") ->
//   	p2.setName("value") ->
//   	p2.setClass("ptolemy.data.expr.Parameter") ->
// 		p2.setValue(value) ->
//   		p3.setName("_icon") ->
//   		p3.setClass("ptolemy.vergil.icon.BoxedValueIcon") ->
//   			p4.setName("attributeName") ->
//   			p4.setClass("ptolemy.kernel.util.StringAttribute") ->
//   			p4.setValue("value") ->
//   			p5.setName("displayWidth") ->
//   			p5.setClass("ptolemy.data.expr.Parameter") ->
//   			p5.setValue("60") ->
//   		p3.property.add(p4) ->
//   		p3.property.add(p5) ->
//   	p2.property.add(p3) ->
//   e.property.add(p1) ->
//   e.property.add(p2) ->
//   //if not already exists
//   (baseEntity.entity.select(ee|ee.name.matches(e.name)).size == 0) ?
//   			baseEntity.entity.add(e) : null
//;

//-----------------------------------------------------------------------------
//--                   T O P L E V E L    E N T I T I E S                    --
//-----------------------------------------------------------------------------

//Create basic / outer most enclosing entity.	
create EntityType this createBaseEntity(synccharts::Region mainRegion):
	let outerStateURIHash = hash(getURIFragment(mainRegion.innerStates.get(0))):
   	this.setName(outerStateURIHash + "_simulation") ->
  	this.setClass1("ptolemy.actor.TypedCompositeActor") ->
  	//TODO: fix outer most local signal declarations
   	this.createMainSyncChartDirector(mainRegion.innerStates.get(0).signals
   												.select(e|e.isLocal()).name) ->
   	//mainRegion has exactly ONE top most state
   	//iterate over all regions within this top most state
   	//the  of this containing Entity is derived from this
   	//   top most state, w/ " simulation" added
    IterateRegions(mainRegion.innerStates.get(0).regions, this, mainRegion
    											.innerStates.get(0).signals) ->
    //add "this" EntityType so that IterateRegions is able to add 
    //new entities or properties
    
    //connect most top input signals
    ConnectTopmostInputSignals(this, this.entity) ->

    //delete termination output port that corrupts operation
    deleteModalModelPorts((List[EntityType])
   				(this.entity.select(e|e.name.startsWith(outerStateURIHash))),
   				"terminated"+outerStateURIHash) -> 
   				
   //post processing: reconsider priorities
   ConsiderTransitionPriorities(this.entity)   
;


// Termination ports are not needed on the toplevel, so these can be deleted.
// This is done by iterating thru the list of all modalmodels (and their
// controller).
Void deleteModalModelPorts(List[EntityType] entityList, String portName) :
 	let modalmodel = entityList.last() :
 	let controller = (EntityType) modalmodel.entity.select
 									(e|e.name.matches("_Controller")).first():
	//debug output
 	dump("DELETE "+portName +" IN " + modalmodel.name) ->

	//delete port and links in modal model
	modalmodel.port.remove(modalmodel.port.select(e|e.name.matches(portName))
			  .first()) ->
	modalmodel.relation.remove(modalmodel.relation
			  .select(e|e.name.matches(portName+"Relation")).first()) ->
	modalmodel.link.remove(modalmodel.link
			  .select(e|e.relation.matches(portName+"Relation")).first()) ->
	modalmodel.link.remove(modalmodel.link
			  .select(e|e.relation.matches(portName+"Relation")).first()) ->
 	
 	//delete port in controller
 	controller.port.remove(controller.port
 			  .select(e|e.name.matches(portName)).first()) ->

	//go thru the rest of the list, if any
 	(entityList.size > 1) ?
 		deleteModalModelPorts(entityList.withoutLast(), portName) : null	
;	


//-----------------------------------------------------------------------------
//--     A U T O M A T I C   R E C O N S I D E R   P R I O R I T I E S       --
//-----------------------------------------------------------------------------

//Go thru each hierarchy stage
//Go thru all ModalModels
//Go thru all States
//Go thru all outgoing transitions
//For all (OTHER) outgoing transitions with higher priority:
//    Add negated trigger with AND operator

//Go thru all ModalModels
Void ConsiderTransitionPriorities(List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConsiderTransitionPriorities_ModalModel(firstEntity,
										        firstEntity.entity) : null ->
	(entityList.size > 1) ?
		ConsiderTransitionPriorities(entityList.withoutFirst()) : null
;

//Use ModalModel to go to deeper hierarchies (refinements!)
Void ConsiderTransitionPriorities_ModalModel(EntityType modalModel,
											 List[EntityType] entityList):
   let firstEntity = entityList.first():
   //if this is a ModalController => Check all states
   (firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalController")
    && firstEntity.link != null) ?
   			ConsiderTransitionPriorities_ModalController(firstEntity,
   														 firstEntity.entity)
	: null ->   											
		 
	//if this is a Refinement => Recursively go into it		 
   (firstEntity.class1.matches("ptolemy.domains.modal.modal.Refinement")) ?
   			ConsiderTransitionPriorities(firstEntity.entity)
	: null ->   											
		 
//   dump("[Priorities - MM] ModalModel:"+ modalModel.name + 
//   		      ", State:"+ firstEntity.name + "(" + firstEntity.class1 + ")") ->
   
   (entityList.size > 1) ?
		ConsiderTransitionPriorities_ModalModel(modalModel, 
												entityList.withoutFirst()) 
		: null
;

//Use ModalController (of ModalModel) to go thru kernel.states
Void ConsiderTransitionPriorities_ModalController(EntityType modalController,
												  List[EntityType] entityList):
   let firstEntity = entityList.first():
   let linkList = modalController.link
   						.select(e|e.port.matches(firstEntity.name + ".outgoingPort")):
   let relationList = modalController.relation
   						.select(e|RelationContainedInLinkList(e,linkList)):
   
//   dump(" [Priorities - MC] ModalController:"+ modalController.name + 
//   		      ", State:"+ firstEntity.name + "(" + firstEntity.class1 + ")") ->
   				   
   (firstEntity.class1.matches("ptolemy.domains.modal.kernel.State")) ?
   			ConsiderTransitionPriorities_State(
   				modalController,
   				firstEntity,
   				relationList,
   				relationList) 
   	: null ->

   	(entityList.size > 1) ?
		ConsiderTransitionPriorities_ModalController(modalController, 
													 entityList.withoutFirst()) 
		: null
;

//Helper function
Boolean RelationContainedInLinkList(RelationType relation, 
									List[LinkType] linkList) :
	let firstLink = linkList.first():
	let match = firstLink.relation.matches(relation.name):
    (linkList.size > 1) ?
		 match || RelationContainedInLinkList(relation, linkList.withoutFirst())
     :
		 match
;


//Use Kernel.State to go thru all transitions
Void ConsiderTransitionPriorities_State(EntityType modalController,
										EntityType kernelState,
										List[RelationType] outgoingRelations,
										List[RelationType] relationList) :
	let firstRelation = relationList.first():
	let outgoingRelationsCopy = outgoingRelations.select(e|true):
//   	dump("  [Priorities - ST] State:"+ kernelState.name + 
//   		      ", Relation:"+ firstRelation.getTrigger() + " [" +firstRelation.getPriority()+"] --> " + relationList.size) ->
   		      
	ConsiderTransitionPriorities_Relation(firstRelation, outgoingRelationsCopy) ->
   		      
    (relationList.size > 1) ?
    	ConsiderTransitionPriorities_State(modalController,
										kernelState,
										outgoingRelations,
										relationList.withoutFirst())
     	: null										
;


String getTrigger(Moml::RelationType relation) :
	relation.property.select(e|e.name.matches("guardExpression")).get(0).value
;

Void setTrigger(RelationType relation, String trigger) :
	dump("  SET TRIGGER:"+trigger) ->
	relation.property.select(e|e.name.matches("guardExpression")).get(0)
		.setValue(trigger)
;

int getPriority(RelationType relation) :
	(relation.property.select(e|e.name.matches("priority")).get(0).value).asInteger()
;

Boolean isEmptyTrigger(RelationType relation) :
	((relation == null) 
	||
	(relation.getTrigger() == null)
	|| 
	(relation.getTrigger().length == 0)) ?
	 		true
	 : false	
;

//For each transition (relation), add negated trigger of transition w/ 
//lower priority value
Void ConsiderTransitionPriorities_Relation(RelationType relation,
										   List[RelationType] otherRelations):
    let firstOtherRelation = otherRelations.first():

   	dump("   [Priorities - RE] Compare:"+ relation.getTrigger() + "[" + relation.getPriority() + "] > " 
   		      + firstOtherRelation.getTrigger() + " [" +firstOtherRelation.getPriority()+"] ---> " + otherRelations.size) ->
    
    //if other relation has higher priority - both triggers != null
    (firstOtherRelation.getPriority() < relation.getPriority()
      && (!firstOtherRelation.isEmptyTrigger())
       && (!relation.isEmptyTrigger())) ?
       relation.setTrigger("(!("+firstOtherRelation.getTrigger()+")) && "+relation.getTrigger())
       : null ->

    //if other relation has higher priority - relation.trigger = null
    (firstOtherRelation.getPriority() < relation.getPriority()
      && (!firstOtherRelation.isEmptyTrigger())
       && (relation.isEmptyTrigger())) ?
       relation.setTrigger("(!("+firstOtherRelation.getTrigger()+"))")
       : null ->

    //if other relation has higher priority - otherRelation.trigger = null
    (firstOtherRelation.getPriority() < relation.getPriority()
      && (firstOtherRelation.isEmptyTrigger())
       && (!relation.isEmptyTrigger())) ?
       relation.setTrigger("(false) && "+relation.getTrigger())
       : null ->
    
    (otherRelations.size > 1) ?   
     			ConsiderTransitionPriorities_Relation(relation, otherRelations.withoutFirst())
				: null 								    										   	
;										   


//-----------------------------------------------------------------------------
//--                 A U T O M A T I C - C O N N E N T I O N                 --
//-----------------------------------------------------------------------------

//Connect top most input signals.
Void ConnectTopmostInputSignals(EntityType baseEntity, 
							    List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectTopmostInputSignalsHelper(baseEntity, 
										 firstEntity.name, 
										 firstEntity.port) : null ->
	(entityList.size > 0) ?
		ConnectTopmostInputSignals(baseEntity, entityList.withoutFirst()) : null
;
Void ConnectTopmostInputSignalsHelper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	//for only input ports (that have a property with the name "*_input")
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "environment_input") : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
			    modalModelName + "." + firstPort.name, 
			    firstPort.name + "_RELATION") : null ->
		
	//create kielerIO for every environment input and connect it	
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addKielerIO(baseEntity, 
					firstPort.name + "_KIELERIO", 
					firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
		        firstPort.name + "_KIELERIO.signal", 
		        firstPort.name + "_RELATION") : null ->

	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addVertexRelation(baseEntity, 
		                  firstPort.name + "_RELATION", 
		                  "local_input") : null ->
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
		        modalModelName + "." + firstPort.name, 
		        firstPort.name + "_RELATION") : null ->
 
	//generate KielerCombine-functions and connect local outputs to it
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addCombineFunction(baseEntity, 
		                   firstPort.name + "_COMBINE") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addRelation(baseEntity, 
		            firstPort.name + modalModelName + "_COMBINERELATION", 
		            "local_output") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
		        firstPort.name + "_COMBINE.input", 
		        firstPort.name + modalModelName + "_COMBINERELATION" ) : null->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
		        modalModelName + "." + firstPort.name, 
		        firstPort.name + modalModelName + "_COMBINERELATION") : null ->

	//connect local input vertex with output combine OR function operators
	//be careful: local signals end with o or i now, oCombine must be 
	//linked with iVertex!!!
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
		        firstPort.name.subString(0,firstPort.name.length-1) 
		         										+ "o_COMBINE.output",
		        firstPort.name + "_RELATION") : null ->
	
	//generate ADD-functions and connect environment outputs to it
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addEnvironmentCombineFunction(baseEntity, 
									  firstPort.name + "_COMBINE", 
									  firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addRelation(baseEntity, 
					firstPort.name + modalModelName + "_COMBINERELATION", 
					"environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.input", 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->

	(portList.size > 0) ?
		ConnectTopmostInputSignalsHelper(baseEntity, 
										 modalModelName, 
										 portList.withoutFirst()) : null
;


//Connect nested input signals.
Void ConnectNestedInputSignals(EntityType baseEntity, 
							   List[EntityType] entityList) :
	let firstEntity = entityList.first():
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectNestedInputSignals_LocalToEnvironment_Helper
										(baseEntity,
					 					firstEntity.name,
					 					firstEntity.port) : null ->
	(firstEntity.class1.matches("ptolemy.domains.modal.modal.ModalModel")) ? 
		ConnectNestedInputSignalsHelper(baseEntity, 
										firstEntity.name, 
										firstEntity.port) : null ->
	(entityList.size > 0) ?
		ConnectNestedInputSignals(baseEntity, 
								  entityList.withoutFirst()) : null
;
//Local signals for which exist input and output ports are treated as 
//environment signals.
//Because they are defined in an outer layer, so rename their type accordingly!
Void ConnectNestedInputSignals_LocalToEnvironment_Helper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	
	//the portlist is the one of the inspected modalModel that we compare
	//the base entity is the one we check for the ports

	((firstPort.property.select(e|e.name.matches("local_input")).size > 0)
	  && (baseEntity.port.select(e|e.name.matches(firstPort.name)).size > 0)) ?
	firstPort.property.select(e|e.name.matches("local_input"))
				.setName("environment_input") 
	: null ->
			
	((firstPort.property.select(e|e.name.matches("local_output")).size > 0) 
	  && (baseEntity.port.select(e|e.name.matches(firstPort.name)).size > 0)) ?
	firstPort.property.select(e|e.name.matches("local_output"))
				.setName("environment_output") 
	: null ->

	(portList.size > 0) ?
		ConnectNestedInputSignals_LocalToEnvironment_Helper(
										baseEntity,
									 	modalModelName, 
									 	portList.withoutFirst()) : null
;

Void ConnectNestedInputSignalsHelper(EntityType baseEntity, 
									  String modalModelName,
						 			  List[PortType] portList) :
	let firstPort = portList.first():
	//for termination ports
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		dump("Connect Termination for Port :"
			 +firstPort.name+" in " + baseEntity.name) : null ->
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addRelation(baseEntity, 
					modalModelName + "_COMBINERELATION", 
					"termination") : null ->
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addLink(baseEntity, 
				"KielerNormalTermination.state terminated", 
				modalModelName  + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + ".terminated" + baseEntity.name, 
				modalModelName  + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addRelation(baseEntity, 
					"TERMINATION_RELATION", 
					"termination") : null ->
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addLink(baseEntity, 
				"KielerNormalTermination.all states terminated", 
				"TERMINATION_RELATION") : null ->
	//only (!!!) connect termination signals for abortion of outer/current state!
	// (not INNER states)
	(firstPort.property.select(e|e.name.matches("termination")).size > 0) ?
		addLink(baseEntity, 
				"terminated" + baseEntity.name, 
				"TERMINATION_RELATION") : null ->
	
	//for only input ports (that have a property with the name "*_input")
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "environment_input") : null ->
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + 
				firstPort.name, 
				firstPort.name + "_RELATION") : null ->
		
	//connect every environment input to relation	
	(firstPort.property.select(e|e.name.matches("environment_input")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name, 
				firstPort.name + "_RELATION") : null ->

	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "local_input") : null ->
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + "_RELATION") : null ->
 
	//generate KielerCombine-functions and connect local outputs to it
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addCombineFunction(baseEntity, 
						   firstPort.name + "_COMBINE") : null ->

 ///-----
	//do this only, iff there are no input/output ports of this local signal,
	// hence it is defined on this hierarchy layer! (= true local signals),
	// local signals are treated as environment signals in nested hearchy 
	//layers!
	
	//connect local input vertex with output combine operator
	//be careful: local signals end with o or i now, oCombine must be linked 
	//with iVertex!!!
	(firstPort.property.select(e|e.name.matches("local_input")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name.subString(0,firstPort.name.length-1) 
							+ "o_COMBINE.output", 
				firstPort.name + "_RELATION") : null ->
	//connect local output vertex with input combine 
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addRelation(baseEntity, 
					firstPort.name + modalModelName + "_COMBINERELATION",
					 "local_output") : null ->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.input", 
				firstPort.name + modalModelName + "_COMBINERELATION" ) : null->
	(firstPort.property.select(e|e.name.matches("local_output")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + modalModelName +"_COMBINERELATION") : null ->
 ///-----

	//generate KielerCombine-functions and connect environment outputs to it
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addEnvironmentCombineFunction(baseEntity, 
									  firstPort.name + "_COMBINE", 
									  firstPort.name) : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addRelation(baseEntity, 
					firstPort.name + modalModelName + "_COMBINERELATION", 
					"environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.input", 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				modalModelName + "." + firstPort.name, 
				firstPort.name + modalModelName + "_COMBINERELATION") : null ->

	//connect combine function w/ output ports
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addVertexRelation(baseEntity, 
						  firstPort.name + "_RELATION", 
						  "environment_output") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name, 
				firstPort.name + "_RELATION") : null ->
	(firstPort.property.select(e|e.name.matches("environment_output")).size > 0) ?
		addLink(baseEntity, 
				firstPort.name + "_COMBINE.output", 
				firstPort.name + "_RELATION") : null ->

	(portList.size > 0) ?
		ConnectNestedInputSignalsHelper(baseEntity, 
										modalModelName, 
										portList.withoutFirst()) : null
;


//-----------------------------------------------------------------------------
//--            R E G I O N S     A N D     M A C R O S T A T E S            --
//-----------------------------------------------------------------------------

//Create ModalModel == Region-Component. 
create EntityType this createModalModelEntity(synccharts::Region region, 
											  int number, 
									 	List[synccharts::Signal] signalList):
	let p0 = new PropertyType:
	let p1 = new PropertyType:
		p0.setName("directorClass") ->
		p0.setClass("ptolemy.data.expr.StringParameter") ->
		p0.setValue("ptolemy.domains.modal.kernel.KielerFSMDirector") ->
		p1.setName("_tableauFactory") ->
		p1.setClass("ptolemy.vergil.modal.modal.ModalTableauFactory") ->
	this.property.add(p1) ->
   	this.setName(hash(getURIFragment(region.parentState)) 
   											 	+ "_region_" + number) ->
  	this.setClass1("ptolemy.domains.modal.modal.ModalModel") ->
  	//first add signals if any
  	(signalList.size > 0) ?
  		addSignalsToModalModel(this, signalList, region) : null ->
  	//then add termination signal (outer)
  	addTerminationSignalToModalModel(this, region) ->
  	//then add termination signals (inner)
  	addTerminationSignalsToModalModel(this, region.innerStates) ->
  	//then create simple states and macro state declarations
   	this.entity.add(createModalControllerEntity(region, signalList)) ->
   	//then add macro state refinements (for all macro states)
   	IterateStatesRefinement(region.innerStates, this, signalList)
;
//Create ModalController == Region-Declaration (simple states and macro
// states declarations).
create EntityType this createModalControllerEntity(synccharts::Region region,
									 List[synccharts::Signal] signalList):
   	this.setName("_Controller") ->
  	this.setClass1("ptolemy.domains.modal.modal.ModalController") ->
  	//first add signals if any
  	(signalList.size > 0) ?
		addSignalsToModalController(this, 
									null, 
									signalList, 
									region, 
									null) : null ->
  	//add termination signal
	this.addTerminationSignalToModalController(null, region.parentState) ->
  	//add termination signals 
	this.addTerminationSignalsToModalController(null, region.innerStates) ->
  	//then iterated all states (if any in this region)
	(region.innerStates.size > 0) ? 
		IterateStates(region.innerStates, this) : null
;


//Create MacroState == State-Component (of a macro state).
create EntityType this createMacroStateEntity(synccharts::State state):
	//elementURIFragment is *NOT* real XPATH!
	let elementURIFragment = getURIFragment(state):
	let elementURIFragmentProperty = newPropertyType("elementURIFragment",
							 		"ptolemy.kernel.util.StringAttribute",
							 		elementURIFragment):
	let p1 = new PropertyType:
		p1.setName("refinementName") ->
		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
		p1.setValue(hash(getURIFragment(state))) ->
   	this.setName(hash(getURIFragment(state))) ->
  	this.setClass1("ptolemy.domains.modal.kernel.State") ->
	this.property.add(p1) ->
	this.property.add(elementURIFragmentProperty) ->
  	SetStateInitialFinalFlag(state, this)
;


//Create ModalRefinement == State-Definition (of a macro state /w regions).
create EntityType this createMacroStateRefinementEntity(
										synccharts::State state, 
										EntityType modalModel,
										List[synccharts::Signal] signalList):
   	this.setName(hash(getURIFragment(state))) ->
  	this.setClass1("ptolemy.domains.modal.modal.Refinement") ->
   	//getMovedSignalNames() contains names of moved signals
	//signalList.addAll(state.signals) ->
	//signalList.union(state.signals) ->
	//FIXME: why does the added list gets empty?//
	moveToSignalList(signalList, state.signals) ->
   	//add signals to refinement (so outer signals are visible inside), if any
   	(signalList.size > 0) ?
	   	this.addSignalsToModalController(modalModel, 
	   									 signalList, 
	   									 state.parentRegion, 
	   									 getMovedSignalNames()) : null ->
   	//create SyncChartDirector
   	this.createSyncChartDirector(getMovedSignalNames()) ->
   	//add termination signal
   	this.addTerminationSignalToModalController(modalModel, state) ->
   	//add KielerNormalTermination
   	this.addKielerNormalTermination() ->
   	IterateRegions(state.regions, this, signalList) ->
    //connect nested input signals
    ConnectNestedInputSignals(this, this.entity)
;
//Create SimpleState == State-Component.
create EntityType this createSimpleStateEntity(synccharts::State state):
	//elementURIFragment is *NOT* real XPATH!
	let elementURIFragment = getURIFragment(state):
	let elementURIFragmentProperty = newPropertyType("elementURIFragment",
							 		"ptolemy.kernel.util.StringAttribute",
							 		elementURIFragment):
   	this.setName(hash(getURIFragment(state))) ->
  	this.setClass1("ptolemy.domains.modal.kernel.State") ->
	this.property.add(elementURIFragmentProperty) ->
  	SetStateInitialFinalFlag(state, this)
;


//-----------------------------------------------------------------------------
//--            (J A V A)   H E L P E R    F U N C T I O N S                 --
//-----------------------------------------------------------------------------

//Move signalList to the other newList. 
Void moveToSignalList(List[synccharts::Signal] newList, 
					  List[synccharts::Signal] signalList) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			moveToSignalList(org.eclipse.emf.common.util.EList, 
							 org.eclipse.emf.common.util.EList)
;
List[String] getMovedSignalNames():
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			 getMovedSignalNames()
;

//Do some java console output for debugging purpose. 
Void dump(String s) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.dump(
			 java.lang.String)
;

//Get URIFragment of an model element to identify it. 
String getURIFragment(synccharts::State state) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava
			.getURIFragment(de.cau.cs.kieler.synccharts.State)
;

//Get hash value of a string. 
String hash(String s) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			hash(java.lang.String)
;

//Get URIFragment of an model element to identify it. 
int getPortType(synccharts::Signal signal, synccharts::Region region) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			getPortType(de.cau.cs.kieler.synccharts.Signal,
						de.cau.cs.kieler.synccharts.Region)
;

//Construct a new property entity.
PropertyType newPropertyType
								(String name,
								String class,
								String value) :
	let p1 = new PropertyType :
	p1.setClass(class) ->
	p1.setName(name) ->
	p1.setValue(value) ->
	p1
;

//Decide whether a states is initial or final and add the appropriate
//property to the entity.
Void SetStateInitialFinalFlag(synccharts::State state, 
									  EntityType entity) :
	let p1a = new PropertyType:
	let p1b = new PropertyType:
	let p2 = new PropertyType:
		p1a.setName("isInitialState") ->
		p1a.setClass("ptolemy.data.expr.Parameter") ->
		p1a.setValue("true") ->
		p1b.setName("isInitialState") ->
		p1b.setClass("ptolemy.data.expr.Parameter") ->
		p1b.setValue("false") ->
		p2.setName("isFinalState") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("true") ->
  	state.isInitial ? entity.property.add(p1a) : entity.property.add(p1b) 
  	//(do not set it to final, otherwise it can't even being reset!)
  	//this was unfortunately an error in ptolemy that was fixed
  	//BUT the syncchart fixed point iteration does not work if we
  	//cannot fire FSMs again (-> unknown inputs may remain)
  	//state.isFinal ? entity.property.add(p2) :null
;

//Test whether a state is a macro state or a simple state.
boolean isMacroState(synccharts::State state) :
 	state.regions.size > 0
; 

//Construct the trigger.
String buildTrigger(synccharts::Expression expression, 
					String terminatedURIHash) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			buildTrigger(de.cau.cs.kieler.synccharts.Expression, 
						 java.lang.String)
;

//Construct the effect.
String buildEffect(List[synccharts::Effect] effectList, 
				   String terminatedURIHash) :
	JAVA de.cau.cs.kieler.synccharts.sim.ptolemy.oaw.XtendJava.
			buildEffect(org.eclipse.emf.common.util.EList, 
						java.lang.String)
;


//-----------------------------------------------------------------------------
//--               I T E R A T I O N S  ( STATES & REGIONS )                 --
//-----------------------------------------------------------------------------

//Iteratate over all states (in a region).
//For  macro states : add states entity AND list them as a refinement property
//For simple states : add states
Void IterateTransitions(List[synccharts::Transition] transitionList,
							 EntityType entity):
 	let transition = transitionList.last():
 	(transitionList.size > 0) ? 
 			dump(hash(getURIFragment(transition.sourceState)) + " -> " + 
 			hash(getURIFragment(transition.targetState))) 
 			: null ->
	(transitionList.size > 0) ? 
			addTransition(transition,
						  entity,
				  		  hash(getURIFragment(transition.sourceState)) 
				  		  + "_transition_" + transitionList.size) 
		    : null -> 	
    (transitionList.size > 1) ? 
    		IterateTransitions(transitionList.withoutLast(), entity) 
    		: null
;


//Iteratate over all states (in a region).
//For  macro states : add states entity AND list them as a refinement property
//For simple states : add states
Void IterateStates(List[synccharts::State] stateList, 
						EntityType entity):
 	let state = stateList.last():
 	state.isMacroState() ? 
 			entity.entity.add(createMacroStateEntity(state)) 
 			: entity.entity.add(createSimpleStateEntity(state)) ->
 	IterateTransitions(state.outgoingTransitions, entity) ->
    (stateList.size > 1) ? 
    		IterateStates(stateList.withoutLast(), entity) 
    		: null
;


//Iteratate over all states (in a region)
//For  macro states : define the refinement (and recursively add regions!)
//For simple states : do nothing
Void IterateStatesRefinement(List[synccharts::State] stateList, 
								  EntityType entity, 
								  List[synccharts::Signal] signalList) :
 	let state = stateList.last():
 	state.isMacroState() ? 
 				entity.entity.add(
 					createMacroStateRefinementEntity(state, entity, signalList)) 
 				: null ->
    (stateList.size > 1) ? 
    			IterateStatesRefinement(stateList.withoutLast(), 
    			entity, signalList) 
    			: null
;


//Iterate over all regions (in a state)
//Add an own modal model for each region
//Define all signals that are defined until now!
Void IterateRegions(List[synccharts::Region] regionList, 
					EntityType entity, 
					List[synccharts::Signal] signalList):
 	let region = regionList.last():
 	entity.entity.add(createModalModelEntity(region, 
 											 regionList.size, 
 											 signalList)) ->
    (regionList.size > 1) ? 
    				IterateRegions(regionList.withoutLast(), 
    							   entity, 
    							   signalList) : null 
; 


//-----------------------------------------------------------------------------
//--                 C R E A T E     D I R E C T O R S                       --
//-----------------------------------------------------------------------------

//Create a "SYNCCHART Director" (for macro state definition)
Void createSyncChartDirector(EntityType entity, 
							 List[String] stateSignalNames):
    let p0 = new PropertyType:
	 let p1 = new PropertyType:
	 p1.setName("statesignals") ->
	 p1.setClass("ptolemy.kernel.util.StringAttribute") ->
	 p1.setValue(stateSignalNames.flatten().toString()) ->
    p0.setName("Kieler SyncChart Director") ->
	p0.setClass("ptolemy.actor.kiel.SyncChartDirector") ->
	p0.property.add(p1) ->
	entity.property.add(p0) 
;

//Create outer most "SYNCCHART Director" (ticks every seconds)
Void createMainSyncChartDirector(EntityType entity, 
								 List[String] stateSignalNames):
    let p0 = new PropertyType:
	 let p1 = new PropertyType:
	 let p2 = new PropertyType:
	 let p3 = new PropertyType:
	 let p4 = new PropertyType:
	 let p5 = new PropertyType:
		p1.setName("iterations") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("0") ->
		p2.setName("synchronizeToRealTime") ->
		p2.setClass("ptolemy.data.expr.Parameter") ->
		p2.setValue("false") ->
		p3.setName("timeResolution") ->
		p3.setClass("ptolemy.data.expr.Parameter") ->
		p3.setValue("1.0E-10") ->
		p4.setName("period") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		p4.setValue("0") ->
  	 	p5.setName("statesignals") ->
	 	p5.setClass("ptolemy.kernel.util.StringAttribute") ->
	 	p5.setValue(stateSignalNames.flatten().toString()) ->
    p0.setName("Kieler SyncChart Director") ->
	p0.setClass("ptolemy.actor.kiel.SyncChartDirector") ->
	p0.property.add(p1) ->
	p0.property.add(p2) ->
	p0.property.add(p3) ->
 	p0.property.add(p4) ->
 	p0.property.add(p5) ->
	entity.property.add(p0) 
;


//-----------------------------------------------------------------------------
//--         C R E A T E     R E L A T I O N S   &   L I N K S               --
//-----------------------------------------------------------------------------

//Add a state 2 state transition.
Void addTransition(	synccharts::Transition transition, 
					EntityType entity,
					String name) :
	let link1 = new LinkType:
	let link2 = new LinkType:
	link1.setPort(
		hash(getURIFragment(transition.sourceState)) + ".outgoingPort") ->
	link1.setRelation(name) ->
	link2.setPort(
		hash(getURIFragment(transition.targetState)) + ".incomingPort") ->
	link2.setRelation(name) ->
	entity.relation.add(createRelation(name, transition)) ->
	entity.link.add(link1) ->
	entity.link.add(link2) 
;


//Create a Relation Type for a Port connection to a ModalController or 
//ModalModel.
Void addPortRelationAndLinks(EntityType entity, String portName):
    let relation = new RelationType:
	let p1 = new PropertyType:
	let link1 = new LinkType:
	let link2 = new LinkType: 
		p1.setName("width") ->
		p1.setClass("ptolemy.data.expr.Parameter") ->
		p1.setValue("Auto") ->
    relation.setName(portName + "Relation") ->
    relation.setClass("ptolemy.actor.TypedIORelation") ->
	relation.property.add(p1) ->
	link1.setPort(portName) ->
	link1.setRelation(portName + "Relation") ->
	link2.setPort("_Controller." + portName) ->
	link2.setRelation(portName + "Relation") ->
	entity.relation.add(relation) ->
	entity.link.add(link1) ->
	entity.link.add(link2)
;


//Create a Relation Type for State2State transitions.
create RelationType this createRelation(String name,
										synccharts::Transition transition):
//	let p1 = new PropertyType:
//	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4 = new PropertyType:
	let p5 = new PropertyType:
	let p6 = new PropertyType:
	let p7 = new PropertyType:
	let p8 = new PropertyType:
	let p9 = new PropertyType:
//		p1.setName("guardExpression") ->
//		p1.setClass("ptolemy.kernel.util.StringAttribute") ->
//		p2.setName("outputActions") ->
//		p2.setClass("ptolemy.domains.modal.kernel.OutputActionsAttribute") ->
		p3.setName("setActions") ->
		p3.setClass("ptolemy.domains.modal.kernel.CommitActionsAttribute") ->
		p4.setName("reset") ->
		p4.setClass("ptolemy.data.expr.Parameter") ->
		//by default in SyncCharts we have a reset behavior unless its 
		//a history transition
		(!transition.isHistory) ? p4.setValue("true") : p4.setValue("false") ->
		p5.setName("preemptive") ->
		p5.setClass("ptolemy.data.expr.Parameter") ->
		(transition.type.toString().matches("STRONGABORT")) ? 
								p5.setValue("true") : p5.setValue("false") ->
		p6.setName("defaultTransition") ->
		p6.setClass("ptolemy.data.expr.Parameter") ->
		p6.setValue("false") -> //defaultTransition is NOT "normal termination"
		//transition.transitionKind.toString().matches("NORMALTERMINATION") ? 
		//						p6.setValue("true") : p6.setValue("false") ->
		p7.setName("nondeterministic") ->
		p7.setClass("ptolemy.data.expr.Parameter") ->
		p7.setValue("false") ->
		p8.setName("refinementName") ->
		p8.setClass("ptolemy.kernel.util.StringAttribute") ->
		//add priority as string value for post procession on ptolemy model
		p9.setName("priority") ->
		p9.setClass("ptolemy.kernel.util.StringAttribute") ->
		p9.setValue(""+transition.priority) ->
    this.setName(name) ->
//	this.property.add(p1) ->
//	this.property.add(p2) ->
	this.property.add(p3) ->
	this.property.add(p4) ->
	this.property.add(p5) ->
	this.property.add(p6) ->
	this.property.add(p7) ->
	this.property.add(p8) ->
	this.property.add(p9) ->
	addTrigger(this, transition) ->
	addEmission(this, transition)
;


//-----------------------------------------------------------------------------
//--                N O R M A L    T E R M I N A T I O N                     --
//-----------------------------------------------------------------------------

//Add termination signals so a normal termination (weak abortion) can be 
//triggered.
Void addTerminationSignalToModalController(EntityType entity, 
										   EntityType parent, 
										   synccharts::State state) :
	let port = new PortType:
	let p1a = new PropertyType:
	//let p1b = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	port.setName("terminated" + hash(getURIFragment(state))) ->
	port.setClass("ptolemy.domains.modal.modal.RefinementPort") ->
	p1a.setName("output") ->
	//p1b.setName("input") ->
	p2.setName("_type") ->
	p2.setClass("ptolemy.actor.TypeAttribute") ->
	p2.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3.setName("termination") ->
   	p3.setClass("ptolemy.kernel.util.StringAttribute") ->
	port.property.add(p1a) ->
	//port.property.add(p1b) ->
	port.property.add(p2) ->
	port.property.add(p3) ->
	entity.port.add(port)
;
Void addTerminationSignalsToModalController(EntityType entity, 
										    EntityType parent, 
										List[synccharts::State] stateList) :
	let state = stateList.last():
	//only for macro states
	(state.isMacroState()) ?
			addTerminationSignalToModalController(entity, 
												  parent, 
												  state) : null ->
	(stateList.size > 1)?
		addTerminationSignalsToModalController(entity, parent, 
										  	  stateList.withoutLast()) : null
;
Void addTerminationSignalToModalModel(EntityType entity, 
									  synccharts::Region region) :
 	addTerminationSignalToModalModel(entity, region.parentState)
;
Void addTerminationModalModelLink(EntityType entity, String stateURIHash) : 
	let l = new LinkType:
	l.setPort(stateURIHash + ".terminated" + stateURIHash) ->
	l.setRelation("terminated" + stateURIHash + "Relation") ->
	entity.link.add(l)	
;
Void addTerminationSignalToModalModel(EntityType entity, 
									  synccharts::State state) :
	let port = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	port.setName("terminated" + hash(getURIFragment(state))) ->
	port.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	p1.setName("output") ->
	p2.setName("_type") ->
	p2.setClass("ptolemy.actor.TypeAttribute") ->
	p2.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	p3.setName("termination") ->
   	p3.setClass("ptolemy.kernel.util.StringAttribute") ->
	port.property.add(p1) ->
	port.property.add(p2) ->
	port.property.add(p3) ->
	entity.port.add(port) ->  
	addPortRelationAndLinks(entity, port.name)
;
Void addTerminationSignalsToModalModel(EntityType entity, 
									   List[synccharts::State] stateList) :
	let state = stateList.last():
	//only for macro states
	(state.isMacroState()) ?
		addTerminationSignalToModalModel(entity, state) : null ->  
	(state.isMacroState()) ?
	 	addTerminationModalModelLink(entity, 
	 								 ""+hash(getURIFragment(state))) 
	 	: null ->
	(stateList.size > 1)?
		addTerminationSignalsToModalModel(entity, 
										  stateList.withoutLast()) 
		: null
;


//-----------------------------------------------------------------------------
//--                     A D D I N G     S I G N A L S                       --
//-----------------------------------------------------------------------------

//Add signals in signalsList to ModalModel entity.
Void addSignalsToModalModel(EntityType entity, 
							List[synccharts::Signal] signalList,
							synccharts::Region region) :
	let port = new PortType:
	let portLocalIn = new PortType:
	let portLocalOut = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p3 = new PropertyType:
	let p4a = new PropertyType:
	let p4b = new PropertyType:
	let p4c = new PropertyType:
	let p4d = new PropertyType:
	let portType = new PropertyType:
	let portTypeLocalIn = new PropertyType:
	let portTypeLocalOut = new PropertyType:
	let signal = signalList.first():
	port.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	port.setName(signal.name) ->
	portLocalIn.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalIn.setName(signal.name+"i") ->
	portLocalOut.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalOut.setName(signal.name+"o") ->
	p4a.setName("environment_input") ->
	p4b.setName("environment_output") ->
	p4c.setName("local_input") ->
	p4d.setName("local_output") ->
	p4a.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4b.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4c.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4d.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setName((getPortType(signal, region)).toString()) ->
	portTypeLocalIn.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalIn.setName("1") -> //in
	portTypeLocalOut.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalOut.setName("2") -> //out
	//denote environmental and local input/output signals
	(signal.isInput) ? port.property.add(p4a) : null ->
	(signal.isOutput) ? port.property.add(p4b) : null ->
	p1.setName("input") ->
	p2.setName("output") ->
	//if local signal, create in AND output port
	portLocalIn.property.add(p4c) ->
 	portLocalOut.property.add(p4d) ->	
	portLocalIn.property.add(p1) ->
	portLocalOut.property.add(p2) ->
	p3.setName("_type") ->
	p3.setClass("ptolemy.actor.TypeAttribute") ->
	p3.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	port.property.add(p3) ->
	port.property.add(portType) -> //input or real type
	portLocalIn.property.add(p3) ->
	portLocalIn.property.add(portTypeLocalIn) -> //(local) input
	portLocalOut.property.add(p3) ->
	portLocalOut.property.add(portTypeLocalOut) -> //(local) output
	
	//only add ports that are used ( w/ type != 0 or -1) 
	//do not handle local ports here
	(!(portType.name.matches("0") 
		|| portType.name.matches("-1") 
		|| signal.isLocal()))  ?
			entity.port.add(port) : null ->
			
	//also add necessary relation that connect above ports with the 
	//controller
	(!(portType.name.matches("0") 
		|| portType.name.matches("-1") 
		|| signal.isLocal()))  ?
			addPortRelationAndLinks(entity, port.name) : null ->
	
	//add local ports
	(signal.isLocal()) ?
			entity.port.add(portLocalIn) : null ->
	(signal.isLocal()) ?
			entity.port.add(portLocalOut) : null ->
	(signal.isLocal()) ?
			addPortRelationAndLinks(entity, portLocalIn.name) : null ->
	(signal.isLocal()) ?
			addPortRelationAndLinks(entity, portLocalOut.name) : null ->
	
	//if still signals remain, continue
	(signalList.size > 1) ? addSignalsToModalModel(entity,
												   signalList.withoutFirst(), 
												   region) : null
;


//Helper function detecting local signals.
//If signals is not input and signal is not output => signal is local.
Boolean isLocal(synccharts::Signal signal) :
 (!signal.isInput && !signal.isOutput)
;


//Add signals in signalsList to ModalController entity.
//StateSignalList contains all local signals that are defined in this state
//and that do not need to be added.
Void addSignalsToModalController(EntityType entity, EntityType parent,
								 List[synccharts::Signal] signalList,
								 synccharts::Region region,
								 List[String] stateSignalNames) :
	let port = new PortType:
	let portLocalIn = new PortType:
	let portLocalOut = new PortType:
	let p1 = new PropertyType:
	let p2 = new PropertyType:
	let p1b = new PropertyType:
	let p2b = new PropertyType:
	let p3 = new PropertyType:
	let p1c = new PropertyType:
	let p4a = new PropertyType:
	let p4b = new PropertyType:
	let p4c = new PropertyType:
	let p4d = new PropertyType:
	let portType = new PropertyType:
	let portTypeLocalIn = new PropertyType:
	let portTypeLocalOut = new PropertyType:
	let signal = signalList.first():
	let isStateSignal = (stateSignalNames != null) 
						 && (stateSignalNames.select(e|e.matches(signal.name))
						 										  .size > 0 ):
	port.setClass("ptolemy.domains.modal.modal.RefinementPort") ->
	port.setName(signal.name) ->
	portLocalIn.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalIn.setName(signal.name+"i") ->
	portLocalOut.setClass("ptolemy.domains.modal.modal.ModalPort") ->
	portLocalOut.setName(signal.name+"o") ->
	p4a.setName("environment_input") ->
	p4b.setName("environment_output") ->
	p4c.setName("local_input") ->
	p4d.setName("local_output") ->
	p4a.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4b.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4c.setClass("ptolemy.kernel.util.StringAttribute") ->
	p4d.setClass("ptolemy.kernel.util.StringAttribute") ->
	portType.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalIn.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalIn.setName("1") -> //in
	portTypeLocalOut.setClass("ptolemy.kernel.util.StringAttribute") ->
	portTypeLocalOut.setName("2") -> //out
	p1.setName("input") ->
	p2.setName("output") ->
	p1b.setName("input") ->
	p2b.setName("output") ->
	portType.setName((getPortType(signal, region)).toString()) ->
	//denote environmental and local input/output signals
	(signal.isInput) ? port.property.add(p4a) : null ->
	(signal.isOutput) ? port.property.add(p4b) : null ->
	(signal.isInput) ? port.property.add(p1) : null ->
	(signal.isOutput) ? port.property.add(p2) : null ->

	//if local signal, create in AND output port
	portLocalIn.property.add(p4c) ->
 	portLocalOut.property.add(p4d) ->	
	portLocalIn.property.add(p1b) -> //in only
	portLocalOut.property.add(p2b) ->

	p3.setName("_type") ->
	p3.setClass("ptolemy.actor.TypeAttribute") ->
	p3.setValue("int") -> //ALWAYS DEAL W/ INTEGER VALUES BECAUSE OF 
						  //KIELER-IO-ACTOR
	port.property.add(p3) ->
	port.property.add(portType) ->
	portLocalIn.property.add(p3) ->
	portLocalIn.property.add(portTypeLocalIn) -> //(local) input
	portLocalOut.property.add(p3) ->
	portLocalOut.property.add(portTypeLocalOut) -> //(local) output
	
	//only add ports that are used ( w/ type != 0 or -1)
	(!(portType.name.matches("0") 
			|| portType.name.matches("-1") 
			|| signal.isLocal())) ?
			entity.port.add(port) : null ->

	//only link ports that are used ( w/ type != 0 or -1)
	(!(portType.name.matches("0") 
			|| portType.name.matches("-1") 
			|| signal.isLocal())) ?
			linkSignalRelationToState(entity, parent, signal.name) : null ->
	
	//add local ports 
	(signal.isLocal() && !isStateSignal) ?
			entity.port.add(portLocalIn) : null ->
	(signal.isLocal() && !isStateSignal) ?
			entity.port.add(portLocalOut) : null ->
	(signal.isLocal() && !isStateSignal) ?
			linkSignalRelationToState(entity, parent, signal.name+"i") 
			: null ->
	(signal.isLocal() && !isStateSignal) ?
			linkSignalRelationToState(entity, parent, signal.name+"o") 
			: null ->

	//if still signals remain, continue
	(signalList.size > 1) ? addSignalsToModalController(entity, parent,
													signalList.withoutFirst(),
													region,
													stateSignalNames) : null	
;


//Helperfunction connecting signals to a modalController.
linkSignalRelationToState(EntityType modalController, 
						  EntityType parent, 
						  String signalName) :
	let stateName = modalController.name:
	let l = new LinkType:
	l.setPort(stateName + "." + signalName) ->
	dump(parent.name) ->
	dump(stateName + "." + signalName) ->
	l.setRelation(signalName + "Relation") ->
	parent.link.add(l)
;


//-----------------------------------------------------------------------------
//--         C R E A T E     T R I G G E R   /   E M I S S I O N S           --
//-----------------------------------------------------------------------------

//Create guardExpression.
Void addTrigger(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	//terminated source state triggers the normal termination
	let terminatedURIHash = hash(getURIFragment(transition.sourceState)):
	p1.setName("guardExpression") ->
	p1.setClass("ptolemy.kernel.util.StringAttribute") ->
	//if normal termination, replace trigger by termination-trigger
	(transition.type.toString().matches("NORMALTERMINATION")) ? 
		p1.setValue(buildTrigger(transition.trigger, terminatedURIHash)) :
		p1.setValue(buildTrigger(transition.trigger, "")) ->
	relation.property.add(p1)
;


//Create outputActions.
Void addEmission(RelationType relation, synccharts::Transition transition) :
	let p1 = new PropertyType:
	let terminatedURIHash = hash(getURIFragment(
							transition.targetState.parentRegion.parentState)):
	p1.setName("outputActions") ->
	p1.setClass("ptolemy.domains.modal.kernel.OutputActionsAttribute") ->
	//if target state is final state, then add termination-effect
	(transition.targetState.isFinal) ?
		p1.setValue(buildEffect(transition.effects, terminatedURIHash)) :
		p1.setValue(buildEffect(transition.effects, "")) ->
	relation.property.add(p1) 
;
