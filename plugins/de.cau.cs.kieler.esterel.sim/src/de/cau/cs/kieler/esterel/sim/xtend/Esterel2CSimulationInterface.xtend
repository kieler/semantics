/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2012 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.esterel.sim.xtend

import de.cau.cs.kieler.esterel.esterel.Input
import de.cau.cs.kieler.esterel.esterel.InterfaceSignalDecl
import de.cau.cs.kieler.esterel.esterel.Output
import de.cau.cs.kieler.esterel.esterel.Module
import de.cau.cs.kieler.esterel.esterel.ValueType

/**
 * Transformation of Esterel code into a c simulation interface wrapper
 * that is able to deal with JSON signals and can interface with
 * the signal functions generated by the CEC
 * 
 * @author cmot, (original transformation xtend (1.0) ctr)
 * @kieler.design 2012-10-08 proposed cmot
 * @kieler.rating 2012-05-31 yellow KI-7
 */
class Esterel2CSimulationInterface { 
    
    // General method to create the c simulation interface
	def createCSimulationInterface (Module module) {
       '''
	   «/* Generate the C header */»
       «esterelHeader()»

	   «/* Generate output functions for each Esterel signal */» 
	   «'''«FOR intSignalDecl : module.intSignalDecls»
	       		«intSignalDecl.outputFunctions(module.name)»
	       «ENDFOR»'''»

	   «/* Generate input functions that are then called my the main function's
		   tick function of the module */»
       «esterelSetInputsFunction(module)»

	   «/* Generate the generic C main function */»
	   «mainFunction(module)»

       '''
   } 	

   // -------------------------------------------------------------------------   
   
   // Generate the Esterel C header
   def esterelHeader() {
   	'''
/* Generated CSimulationInterface Wrapper */
	
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "cJSON.h"

#define DEFAULT_BUFFER_SIZE 2048

cJSON* output = 0;
cJSON* jsonvalue = 0;
	''' 
   }
   
   // -------------------------------------------------------------------------   
   
   // Generate input functions that are then called my the main function's
   // tick function of the module
   def esterelSetInputsFunction(Module module) {
'''
void setInputs(){
  char buffer[DEFAULT_BUFFER_SIZE];
  int i=0;
  char c;
  // read next line
  for (i=0; (c=getchar())!='\n'; i++){
    buffer[i]=c;
  }
  buffer[i]=0;
  
	cJSON* object = 0;
	cJSON* child = 0;
	cJSON* present = 0;
	cJSON* jsonvalue = 0;

	object = cJSON_Parse(buffer);
	
   «'''«FOR intSignalDecl : module.intSignalDecls»
	       		«intSignalDecl.callInputs(module.name)»
   «ENDFOR»'''»	
   }'''
}
   
   // -------------------------------------------------------------------------
      
   
   // Generate the generic C main function
   def mainFunction(Module it) {
   	'''
int doTick() {
    «name»();
}   
   	
int main(){«name»_reset();
  output = cJSON_CreateObject();
  while(1){
    setInputs();
	doTick();
	char* outString = cJSON_Print(output);
	strip_white_spaces(outString);
	printf("%s\n", outString);
	fflush(stdout);
	output = cJSON_CreateObject();
  }  	
}
'''
   }
   
   // -------------------------------------------------------------------------   

   // Define output functions to return JSON for each Esterel signal 
   def dispatch outputFunctions(Output it, String moduleName) {
   	  var gen = "";
   	  gen = gen + "\n";
   	  for (signal : signals)  {
   	  	gen = gen + '''«moduleName»_O_«signal.name»('''.toString();
   	  	if (signal.type.literal == "int" || signal.type.literal == "bool") {
   	  		gen = gen + "int i";
   	  	}
   	  	gen = gen + '''){  	
   	  		jsonvalue = cJSON_CreateObject();
			cJSON_AddTrueToObject(jsonvalue, "present");'''.toString();
   	  	if (signal.type.literal == "int") {
   	  		gen = gen + ''' cJSON_AddNumberToObject(jsonvalue, "value", i);'''.toString();
   	  	} 
   	  	else if (signal.type.literal == "bool") {
			gen = gen + ''' if (i == 0) {
				cJSON_AddFalseToObject(jsonvalue, "value"); }
				else {
					cJSON_AddTrueToObject(jsonvalue, "value");
				} 
			'''.toString();
   	  	}
   	  	gen = gen + '''cJSON_AddItemToObject(output, "«signal.name»", jsonvalue);}'''.toString();
   	  } // next signal
   	  gen;
   }
   
   // -------------------------------------------------------------------------   

   // No output functions for other than Esterel output signals
   def dispatch outputFunctions(InterfaceSignalDecl it, String moduleName) {
   }   
   
   // -------------------------------------------------------------------------   
   
   // Call Esterel input functions for each JSON signal that is present
   def dispatch callInputs(Input it, String moduleName) {
    var gen = "";
   	for (signal : signals)  {
   	   	gen = gen + '''
   	child = cJSON_GetObjectItem(object, "«signal.name»");
   	if (child != NULL){
   	present = cJSON_GetObjectItem(child, "present");
   	jsonvalue = cJSON_GetObjectItem(child, "value");
   	if (present != NULL && present->type==cJSON_True) {
   	    «IF signal.type == ValueType::PURE»
			«moduleName»_I_«signal.name»();
		«ENDIF»
        «IF signal.type == ValueType::INT»
            if (jsonvalue != NULL) {
                 «moduleName»_I_«signal.name»(jsonvalue->valueint);               
            }
        «ENDIF»
        «IF signal.type == ValueType::BOOL»
             if (jsonvalue != NULL) {
                if (jsonvalue->valueint) {
                    «moduleName»_I_«signal.name»(_true);
                }
                else {
                    «moduleName»_I_«signal.name»(_false);
                }
            }
        «ENDIF»
   	}
   	}'''.toString();
   	} // next signal
 	   	gen;
   }
   
   // -------------------------------------------------------------------------   

   // No input functions for other than Esterel input signals
   def dispatch callInputs(InterfaceSignalDecl it, String moduleName) {
   }
   
   // -------------------------------------------------------------------------   

}
