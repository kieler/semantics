import synccharts;
import annotations;
import kexpressions;
import s;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

/////////////// local imports //////////////
extension model::helper;
////////////////////////////////////////////

// priority of a state represented as a weak state (for strong and weak outgoing transitions) 
List[Instruction] getWeakStatePrio(synccharts::State state):
	let out = {}:
		if !state.regions.isEmpty &&
			state.outgoingTransitions.exists(t|t.type != TransitionType::STRONGABORT) &&
			state.outgoingTransitions.exists(t|t.type == TransitionType::STRONGABORT)
		then (
			let prio = new Prio:
//			let value = new s::IntValue:
//				value.setValue(getWeakThreadPriority(state)) ->
				prio.setPriority(getWeakThreadPriority(state)) ->
				out.add(prio) 
		) else (
			null
		)
		->
		out
;

// priority: weak for no outgoing strong transition states, strong for outgoing strong transition states
List[Instruction] getRealStatePrio(synccharts::State state):
	let out = {}:
		if state.outgoingTransitions.exists(t|t.type != TransitionType::STRONGABORT) &&
			state.outgoingTransitions.exists(t|t.type == TransitionType::STRONGABORT) ||
			state.outgoingTransitions.exists(t|t.type != TransitionType::NORMALTERMINATION)
		then (
			let prio = new Prio:
//			let value = new s::IntValue:
//				value.setValue(getRealThreadPriority(state)) ->
				prio.setPriority(getRealThreadPriority(state)) ->
				out.add(prio) 
		) else (
			null
		)
		->
		out
;

List[Instruction] getSmallestStatePrio(synccharts::Transition transition):
	let out = {}:
	let prio = new Prio:
//	let value = new s::IntValue:
//		value.setValue(getSmallestThreadPriority(transition.sourceState)) ->
		prio.setPriority(getSmallestThreadPriority(transition.sourceState)) ->
		out.add(prio) ->
		out
;

// Used if other transition in parallel region depends on this transition emission
List[Instruction] getReducedPrio(synccharts::Transition transition):
	let out = {}:
	let prio = new Prio:
//	let value = new s::IntValue:
		(
			if hasDependentState(transition) then (
//				value.setValue(getRealThreadPriority(transition.targetState)) ->
				prio.setPriority(getRealThreadPriority(transition.targetState)) ->
				out.add(prio)
			) else (
				null
			)
		)->
		out
;

// Returns the smallest thread priority of a state.
int getSmallestThreadPriority(State state):
	JAVA de.cau.cs.kieler.synccharts.s.Helper.getSmallestThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the thread priority of a state. The state is not represented as weak
// or strong but by the real nature of the given state.
int getRealThreadPriority(synccharts::State state):
	JAVA de.cau.cs.kieler.synccharts.s.Helper.getRealThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the thread priority of a state represented as a weak state.
int getWeakThreadPriority(synccharts::State state):
	JAVA de.cau.cs.kieler.synccharts.s.Helper.getWeakThreadPriority(de.cau.cs.kieler.synccharts.State)
;

// Returns the thread priority of the main thread.
cached int getMainTreadPriority(synccharts::State rootState):
	if rootState.regions.size == 1 then
		getRealThreadPriority(getInitialState(rootState))
	else
		getRealThreadPriority(rootState)
;
