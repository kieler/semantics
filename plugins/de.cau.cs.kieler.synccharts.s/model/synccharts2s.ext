import synccharts;
import annotations;
import kexpressions;
import s;
extension org::eclipse::xtend::util::stdlib::io;          // debug printouts
//extension org::eclipse:xtend:::util::stdlib::counter;   // usage of counters 
extension org::eclipse::xtend::util::stdlib::crossref;    // find elements that reference others
//extension org::eclipse::xtend::util::stdlib::mixin;     // annotations
//extension org::eclipse::xtend::util::stdlib::naming;    // help with qualified names
extension org::eclipse::xtend::util::stdlib::cloning;     // copy model elements and whole trees
//extension org::eclipse::xtend::util::stdlib::globalvar; // usage of global variables
//extension org::eclipse::xtend::util::stdlib::uid;       // create unique identifiers from time
extension org::eclipse::xtend::util::stdlib::tracing;     // create map between transformed objects
extension org::eclipse::xtend::util::stdlib::issues;      // pass messages back to java (e.g. to UI)

/////////////// local imports //////////////
extension model::helper;
extension model::priorities;
extension model::transitions2Instructions;
extension model::haltInstruction;
extension model::termInstruction;
extension model::pauseInstruction;
extension model::transInstruction;
extension model::forkInstruction;
extension model::joinInstruction;
////////////////////////////////////////////


// TODO:
// - local signals (must transformed to outer layer)?
// - complex expressions
// - count delays (not considered in SC yet)
// - valued signals
// - unterscheiden zwischen input, signals, outputs
// - ...

//-----------------------------------------------------------------------------
//     SyncChart - 2 - S    TRANSFORMATION    
//     @author: tam
//-----------------------------------------------------------------------------
  
//Start Model Transformation here.
create s::Program this transform(synccharts::Region root):
	//create states and cache them in mapping list
	addAllStatesToMappingList(root) ->
	
	computeThreadPriorities(root.states.first()) ->
	
	this.setName(root.states.first().id) ->
	this.setPriority(getMainTreadPriority(root.states.first())) ->

    //several forks for more then one top level region (otherwise no fork is required)
    //and construct list of s-states	
	( 
		if root.states.first().regions.size == 1 then
			this.setStates(getAllStates(root.states.first()))
		else
			this.setStates(getStatesOfRegion(root))
	) ->
	
	//signal declaration
	//TODO: maybe consolidate with synccharts signal declaration?
	this.setSignals(getStateSignals(root.states.first()))
;


// Initialize the mapping lists with all states.
// After that you can use state.getSingleTraceTarget("S")
// to geht the s::State from a synccharts::State
// Start: ----------------------------------------------
Void addAllStatesToMappingList(synccharts::Region region):
	region.states.addAllStatesToMappingList()
;

Void addAllStatesToMappingList(synccharts::State state):
	state.transform() ->
	state.transformMain() ->
	state.transformIntern() ->
	state.transformMainIntern() ->
	state.regions.addAllStatesToMappingList()
;
// End: ------------------------------------------------

// Computation of the priority list like is was done in codegen.sc.
cached List computeThreadPriorities(synccharts::State rootState):
	JAVA de.cau.cs.kieler.synccharts.s.Helper.computeThreadPriorities(de.cau.cs.kieler.synccharts.State)
;


// builds a state for s
s::State buildState(String name, List[kexpressions::Signal] signals, List[s::Instruction] instructions):
	let state = new s::State:
		state.setName(name) ->
		state.setSignals(signals) ->
		state.setInstructions(instructions)
;

// adds a state to a list of states
List[s::State] addStateToList(s::State state, List[s::State] states):
	states.add(state)
;

// returns a list of all states of a region
List[s::State] getStatesOfRegion(synccharts::Region region):
	let outList = {}:
	outList.addAll(region.states.getAllStates()) ->
	outList.addAll(region.states.transform()) ->
	outList
;

// returns a list including all states of the SyncChart
// the parameter has to be the root state of the SyncChart
List[s::State] getAllStates(synccharts::State state):
	let outList = {}:
		(
			//if root state with more than one region OR not root state ...
			if (state.parentRegion.parentState != null || (state.regions.size > 1)) then (
				let putStateSurface = (s::State)state.getSingleTraceTarget("S_surface"):
				let putStateDepth = (s::State)state.getSingleTraceTarget("S_depth"):
				(
					if state.regions.isEmpty then (
						//simple state
						putInstructions(putStateSurface, getStateSurfInstructions(state)) ->
						putInstructions(putStateDepth, getStateDepthInstructions(state)) ->
						outList.add(putStateSurface) ->
						outList.add(putStateDepth)
					) else (
						//macro state  (... only add fork,forke to instruction list yet)
						putInstructions(putStateSurface, getStateMainInstructions(state)) ->
						outList.add(putStateDepth)
					)
				)
			) else (
				//do nothing for a root state with just one region
				null
			)
		)
		
		->
		
		//for hierarchical states produce main-s-states here... 
		(
			if !state.regions.isEmpty then (
				//recursive call to getStatesOfRegion (these call getAllState again)
				outList.addAll(state.regions.getStatesOfRegion()) ->(
					let putStateHierarchy = (s::State)state.getSingleTraceTarget("S_main_surface"):
					let putStateHierarchyIntern = (s::State)state.getSingleTraceTarget("S_main_depth"):
					putInstructions(putStateHierarchy, getStateSurfInstructions(state)) ->
					putInstructions(putStateHierarchyIntern, getStateDepthInstructions(state)) ->
					outList.add(putStateHierarchy) ->
					outList.add(putStateHierarchyIntern)
				)
			) else (
				null
			)
		)
		-> 
		outList
;

s::State putInstructions(s::State state, List[s::Instruction] instructions):
	state.instructions.addAll(instructions)
;

List[s::Instruction] getStateSurfInstructions(synccharts::State state):
	let outList = {}:
		// # strong Transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isImmediate && t.isStrongAbort()).getTransitionInstruction()) ->
		// TODO: onEntry actions
		// PRIO(weak)
		outList.addAll(getWeakStatePrio(state)) ->
		
		// # weak Transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isImmediate && t.isWeakAbort()).getTransitionInstruction()) ->
		// PRIO(strong)
		outList.addAll(getRealStatePrio(state)) ->
		// normal termination
		outList.addAll(state.outgoingTransitions.select(t|t.isNormalTermination()).getJoinInstruction()) ->
		outList
;

List[s::Instruction] getStateDepthInstructions(synccharts::State state):
	let outList = {}:
		info(state.id) ->
		// PAUSE
		// TODO: check whether pause is necessary for normal termination transitions (maybe pause already included in join/joinelse?)
		outList.addAll(getPauseInstruction(state)) ->
		// TODO: host code
		// all strong transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isStrongAbort()).getTransitionInstruction()) ->
		// TODO: onInside actions
		// PRIO(weak)
		outList.addAll(getWeakStatePrio(state)) ->
		// all weak transitions
		outList.addAll(state.outgoingTransitions.select(t|t.isWeakAbort()).getTransitionInstruction()) ->
		// instructions for states without outgoing transitions
		outList.addAll(getTermInstruction(state)) ->
		outList.addAll(getHaltInstruction(state)) ->
		// GOTO(_depth): return to the return adress if no transition is taken
		outList.addAll(getGotoReturnInstruction(state)) ->
		// return value - a list with all instructions for a state
		outList
;

List[s::Instruction] getStateMainInstructions(synccharts::State state):
	let outList = {}:
		outList.addAll(getForkInstructions(state)) ->
		outList
;


// transforms a SyncChart state into a S state
create s::State this transform(synccharts::State state):
	createTrace(this,state,"SyncCharts","S_surface") ->
	this.setName("L" + getStatePathAsName(state) + "_surface") ->
	if !state.signals.isEmpty then
		this.setSignals(state.signals.transform())
	else
		null
;

// transforms a SyncChart state into a S state
create s::State this transformIntern(synccharts::State state):
	createTrace(this,state,"SyncCharts","S_depth") ->
	this.setName("L" + getStatePathAsName(state) + "_depth")
;

// transforms a SyncChart state into a S state
create s::State this transformMain(synccharts::State state):
	createTrace(this,state,"SyncCharts","S_main_surface") ->
	this.setName("L" + getStatePathAsName(state) + "_main_surface")
;

// transforms a SyncChart state into a S state
create s::State this transformMainIntern(synccharts::State state):
	createTrace(this,state,"SyncCharts","S_main_depth") ->
	this.setName("L" + getStatePathAsName(state) + "_main_depth")
;


// Transforms a SyncCharts signal into a s Signal 
//create s::Signal this transform(expressions::Signal signal):
//	let sigType = new PrimitiveSignalType:
//	createTrace(this,signal,"SyncCharts","S") ->
	// TODO: auch fÃ¼r complex
//		sigType.setPrimitiveType(PrimitiveType::Pure) ->
//		this.setName(signal.name) ->
//		this.setType(sigType)
//;

// Transforms a SyncCharts signal into a s Signal 
create kexpressions::Signal this transform(kexpressions::Signal signal):
	createTrace(this,signal,"SyncCharts","S") ->
	this.setCombineOperator(signal.combineOperator) ->
	this.setName(signal.name) ->
//	this.setHostCombineOperator(signal.combineOperator) ->
	this.setHostType(signal.hostType) ->
	this.setInitialValue(signal.initialValue) ->
	this.setIsInput(signal.isInput) ->
	this.setIsOutput(signal.isOutput) ->
	this.setType(signal.type)
;

//the following is wrong, we cannot take the same signal-ref because this
//doesnt fit
//expressions::Signal transform(expressions::Signal signal):
// signal
//;

List[kexpressions::Signal] getStateSignals(synccharts::State state):
	state.signals.transform()
;