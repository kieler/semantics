/*
* generated by Xtext
*/
package de.cau.cs.kieler.synccharts.interfacedeclparser.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import de.cau.cs.kieler.synccharts.interfacedeclparser.services.InterfaceDeclGrammarAccess;

import com.google.inject.Inject;

public class InterfaceDeclParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private InterfaceDeclGrammarAccess grammarAccess;
	
	@Override	
	public InterfaceDeclGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_Alternatives(this, this, 0, inst);
			case 1: return new RegionSignalDec_Group(this, this, 1, inst);
			case 2: return new Signals_Group(this, this, 2, inst);
			case 3: return new InputSignals_Group(this, this, 3, inst);
			case 4: return new OutputSignals_Group(this, this, 4, inst);
			case 5: return new InOutputSignals_Group(this, this, 5, inst);
			case 6: return new Signal_Alternatives(this, this, 6, inst);
			case 7: return new Variable_Group(this, this, 7, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule StateExtend ****************
 *
 * StateExtend:
 *   (regions+=RegionSignalDec|"input" "output" inOutputSignals+=InOutputSignals|
 *   "output" outputSignals+=OutputSignals|"input" inputSignals+=InputSignals|"signal"
 *   signals+=Signals)+; 
 * 
 * //==============================================================================
 * // "Buckets" containing the Signals / Regions with Signals
 * //==============================================================================
 *
 **/

// (regions+=RegionSignalDec|"input" "output" inOutputSignals+=InOutputSignals|
// "output" outputSignals+=OutputSignals|"input" inputSignals+=InputSignals|"signal"
// signals+=Signals)+
protected class StateExtend_Alternatives extends AlternativesToken {

	public StateExtend_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_RegionsAssignment_0(parent, this, 0, inst);
			case 1: return new StateExtend_Group_1(parent, this, 1, inst);
			case 2: return new StateExtend_Group_2(parent, this, 2, inst);
			case 3: return new StateExtend_Group_3(parent, this, 3, inst);
			case 4: return new StateExtend_Group_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStateExtendRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// regions+=RegionSignalDec
protected class StateExtend_RegionsAssignment_0 extends AssignmentToken  {
	
	public StateExtend_RegionsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getRegionsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("regions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("regions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegionSignalDecRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateExtendAccess().getRegionsRegionSignalDecParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateExtend_Alternatives(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// "input" "output" inOutputSignals+=InOutputSignals
protected class StateExtend_Group_1 extends GroupToken {
	
	public StateExtend_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_InOutputSignalsAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "input"
protected class StateExtend_InputKeyword_1_0 extends KeywordToken  {
	
	public StateExtend_InputKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getInputKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_Alternatives(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// "output"
protected class StateExtend_OutputKeyword_1_1 extends KeywordToken  {
	
	public StateExtend_OutputKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getOutputKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_InputKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// inOutputSignals+=InOutputSignals
protected class StateExtend_InOutputSignalsAssignment_1_2 extends AssignmentToken  {
	
	public StateExtend_InOutputSignalsAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getInOutputSignalsAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InOutputSignals_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("inOutputSignals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("inOutputSignals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInOutputSignalsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateExtendAccess().getInOutputSignalsInOutputSignalsParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateExtend_OutputKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "output" outputSignals+=OutputSignals
protected class StateExtend_Group_2 extends GroupToken {
	
	public StateExtend_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_OutputSignalsAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "output"
protected class StateExtend_OutputKeyword_2_0 extends KeywordToken  {
	
	public StateExtend_OutputKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getOutputKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_Alternatives(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// outputSignals+=OutputSignals
protected class StateExtend_OutputSignalsAssignment_2_1 extends AssignmentToken  {
	
	public StateExtend_OutputSignalsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getOutputSignalsAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OutputSignals_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("outputSignals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("outputSignals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOutputSignalsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateExtendAccess().getOutputSignalsOutputSignalsParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateExtend_OutputKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "input" inputSignals+=InputSignals
protected class StateExtend_Group_3 extends GroupToken {
	
	public StateExtend_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_InputSignalsAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "input"
protected class StateExtend_InputKeyword_3_0 extends KeywordToken  {
	
	public StateExtend_InputKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getInputKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_Alternatives(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// inputSignals+=InputSignals
protected class StateExtend_InputSignalsAssignment_3_1 extends AssignmentToken  {
	
	public StateExtend_InputSignalsAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getInputSignalsAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InputSignals_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("inputSignals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("inputSignals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getInputSignalsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateExtendAccess().getInputSignalsInputSignalsParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateExtend_InputKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "signal" signals+=Signals
protected class StateExtend_Group_4 extends GroupToken {
	
	public StateExtend_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_SignalsAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "signal"
protected class StateExtend_SignalKeyword_4_0 extends KeywordToken  {
	
	public StateExtend_SignalKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getSignalKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StateExtend_Alternatives(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// signals+=Signals
protected class StateExtend_SignalsAssignment_4_1 extends AssignmentToken  {
	
	public StateExtend_SignalsAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStateExtendAccess().getSignalsAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signals_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getStateExtendAccess().getSignalsSignalsParserRuleCall_4_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new StateExtend_SignalKeyword_4_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule StateExtend ****************/


/************ begin Rule RegionSignalDec ****************
 *
 * RegionSignalDec:
 *   region=[synccharts::Region] ":" ("var" vars+=Variable ("," vars+=Variable)*|"signal"
 *   signals+=Signal ("," signals+=Signal)*) ("," "var" vars+=Variable ("," vars+=Variable)*
 *   |"," "signal" signals+=Signal ("," signals+=Signal)*)* ";";
 *
 **/

// region=[synccharts::Region] ":" ("var" vars+=Variable ("," vars+=Variable)*|"signal"
// signals+=Signal ("," signals+=Signal)*) ("," "var" vars+=Variable ("," vars+=Variable)*
// |"," "signal" signals+=Signal ("," signals+=Signal)*)* ";"
protected class RegionSignalDec_Group extends GroupToken {
	
	public RegionSignalDec_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_SemicolonKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRegionSignalDecRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// region=[synccharts::Region]
protected class RegionSignalDec_RegionAssignment_0 extends AssignmentToken  {
	
	public RegionSignalDec_RegionAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getRegionAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("region",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("region");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRegionSignalDecAccess().getRegionRegionCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getRegionSignalDecAccess().getRegionRegionCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ":"
protected class RegionSignalDec_ColonKeyword_1 extends KeywordToken  {
	
	public RegionSignalDec_ColonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getColonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_RegionAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "var" vars+=Variable ("," vars+=Variable)*|"signal" signals+=Signal ("," signals+=
// Signal)*
protected class RegionSignalDec_Alternatives_2 extends AlternativesToken {

	public RegionSignalDec_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_2_0(parent, this, 0, inst);
			case 1: return new RegionSignalDec_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "var" vars+=Variable ("," vars+=Variable)*
protected class RegionSignalDec_Group_2_0 extends GroupToken {
	
	public RegionSignalDec_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_2_0_2(parent, this, 0, inst);
			case 1: return new RegionSignalDec_VarsAssignment_2_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "var"
protected class RegionSignalDec_VarKeyword_2_0_0 extends KeywordToken  {
	
	public RegionSignalDec_VarKeyword_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getVarKeyword_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_ColonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// vars+=Variable
protected class RegionSignalDec_VarsAssignment_2_0_1 extends AssignmentToken  {
	
	public RegionSignalDec_VarsAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getVarsAssignment_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("vars",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("vars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getVarsVariableParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_VarKeyword_2_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," vars+=Variable)*
protected class RegionSignalDec_Group_2_0_2 extends GroupToken {
	
	public RegionSignalDec_Group_2_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_2_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_VarsAssignment_2_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class RegionSignalDec_CommaKeyword_2_0_2_0 extends KeywordToken  {
	
	public RegionSignalDec_CommaKeyword_2_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getCommaKeyword_2_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_2_0_2(parent, this, 0, inst);
			case 1: return new RegionSignalDec_VarsAssignment_2_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// vars+=Variable
protected class RegionSignalDec_VarsAssignment_2_0_2_1 extends AssignmentToken  {
	
	public RegionSignalDec_VarsAssignment_2_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getVarsAssignment_2_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("vars",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("vars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getVarsVariableParserRuleCall_2_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_CommaKeyword_2_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "signal" signals+=Signal ("," signals+=Signal)*
protected class RegionSignalDec_Group_2_1 extends GroupToken {
	
	public RegionSignalDec_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_2_1_2(parent, this, 0, inst);
			case 1: return new RegionSignalDec_SignalsAssignment_2_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "signal"
protected class RegionSignalDec_SignalKeyword_2_1_0 extends KeywordToken  {
	
	public RegionSignalDec_SignalKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getSignalKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_ColonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class RegionSignalDec_SignalsAssignment_2_1_1 extends AssignmentToken  {
	
	public RegionSignalDec_SignalsAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getSignalsAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getSignalsSignalParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_SignalKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," signals+=Signal)*
protected class RegionSignalDec_Group_2_1_2 extends GroupToken {
	
	public RegionSignalDec_Group_2_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_2_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_SignalsAssignment_2_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class RegionSignalDec_CommaKeyword_2_1_2_0 extends KeywordToken  {
	
	public RegionSignalDec_CommaKeyword_2_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getCommaKeyword_2_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_2_1_2(parent, this, 0, inst);
			case 1: return new RegionSignalDec_SignalsAssignment_2_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class RegionSignalDec_SignalsAssignment_2_1_2_1 extends AssignmentToken  {
	
	public RegionSignalDec_SignalsAssignment_2_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getSignalsAssignment_2_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getSignalsSignalParserRuleCall_2_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_CommaKeyword_2_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




// ("," "var" vars+=Variable ("," vars+=Variable)*|"," "signal" signals+=Signal (","
// signals+=Signal)*)*
protected class RegionSignalDec_Alternatives_3 extends AlternativesToken {

	public RegionSignalDec_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_3_0(parent, this, 0, inst);
			case 1: return new RegionSignalDec_Group_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "," "var" vars+=Variable ("," vars+=Variable)*
protected class RegionSignalDec_Group_3_0 extends GroupToken {
	
	public RegionSignalDec_Group_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_3_0_3(parent, this, 0, inst);
			case 1: return new RegionSignalDec_VarsAssignment_3_0_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class RegionSignalDec_CommaKeyword_3_0_0 extends KeywordToken  {
	
	public RegionSignalDec_CommaKeyword_3_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getCommaKeyword_3_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Alternatives_3(parent, this, 0, inst);
			case 1: return new RegionSignalDec_Alternatives_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "var"
protected class RegionSignalDec_VarKeyword_3_0_1 extends KeywordToken  {
	
	public RegionSignalDec_VarKeyword_3_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getVarKeyword_3_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_CommaKeyword_3_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// vars+=Variable
protected class RegionSignalDec_VarsAssignment_3_0_2 extends AssignmentToken  {
	
	public RegionSignalDec_VarsAssignment_3_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getVarsAssignment_3_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("vars",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("vars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getVarsVariableParserRuleCall_3_0_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_VarKeyword_3_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," vars+=Variable)*
protected class RegionSignalDec_Group_3_0_3 extends GroupToken {
	
	public RegionSignalDec_Group_3_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_3_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_VarsAssignment_3_0_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class RegionSignalDec_CommaKeyword_3_0_3_0 extends KeywordToken  {
	
	public RegionSignalDec_CommaKeyword_3_0_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getCommaKeyword_3_0_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_3_0_3(parent, this, 0, inst);
			case 1: return new RegionSignalDec_VarsAssignment_3_0_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// vars+=Variable
protected class RegionSignalDec_VarsAssignment_3_0_3_1 extends AssignmentToken  {
	
	public RegionSignalDec_VarsAssignment_3_0_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getVarsAssignment_3_0_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("vars",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("vars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getVarsVariableParserRuleCall_3_0_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_CommaKeyword_3_0_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "," "signal" signals+=Signal ("," signals+=Signal)*
protected class RegionSignalDec_Group_3_1 extends GroupToken {
	
	public RegionSignalDec_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_3_1_3(parent, this, 0, inst);
			case 1: return new RegionSignalDec_SignalsAssignment_3_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class RegionSignalDec_CommaKeyword_3_1_0 extends KeywordToken  {
	
	public RegionSignalDec_CommaKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getCommaKeyword_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Alternatives_3(parent, this, 0, inst);
			case 1: return new RegionSignalDec_Alternatives_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "signal"
protected class RegionSignalDec_SignalKeyword_3_1_1 extends KeywordToken  {
	
	public RegionSignalDec_SignalKeyword_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getSignalKeyword_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_CommaKeyword_3_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class RegionSignalDec_SignalsAssignment_3_1_2 extends AssignmentToken  {
	
	public RegionSignalDec_SignalsAssignment_3_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getSignalsAssignment_3_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getSignalsSignalParserRuleCall_3_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_SignalKeyword_3_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," signals+=Signal)*
protected class RegionSignalDec_Group_3_1_3 extends GroupToken {
	
	public RegionSignalDec_Group_3_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getGroup_3_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_SignalsAssignment_3_1_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class RegionSignalDec_CommaKeyword_3_1_3_0 extends KeywordToken  {
	
	public RegionSignalDec_CommaKeyword_3_1_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getCommaKeyword_3_1_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Group_3_1_3(parent, this, 0, inst);
			case 1: return new RegionSignalDec_SignalsAssignment_3_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class RegionSignalDec_SignalsAssignment_3_1_3_1 extends AssignmentToken  {
	
	public RegionSignalDec_SignalsAssignment_3_1_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getSignalsAssignment_3_1_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegionSignalDecAccess().getSignalsSignalParserRuleCall_3_1_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegionSignalDec_CommaKeyword_3_1_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




// ";"
protected class RegionSignalDec_SemicolonKeyword_4 extends KeywordToken  {
	
	public RegionSignalDec_SemicolonKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegionSignalDecAccess().getSemicolonKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegionSignalDec_Alternatives_3(parent, this, 0, inst);
			case 1: return new RegionSignalDec_Alternatives_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule RegionSignalDec ****************/


/************ begin Rule Signals ****************
 *
 * Signals:
 *   (signals+=Signal ("," signals+=Signal)*) ";";
 *
 **/

// (signals+=Signal ("," signals+=Signal)*) ";"
protected class Signals_Group extends GroupToken {
	
	public Signals_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signals_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signals+=Signal ("," signals+=Signal)*
protected class Signals_Group_0 extends GroupToken {
	
	public Signals_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalsAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signals_Group_0_1(parent, this, 0, inst);
			case 1: return new Signals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class Signals_SignalsAssignment_0_0 extends AssignmentToken  {
	
	public Signals_SignalsAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalsAccess().getSignalsAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSignalsAccess().getSignalsSignalParserRuleCall_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," signals+=Signal)*
protected class Signals_Group_0_1 extends GroupToken {
	
	public Signals_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalsAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signals_SignalsAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Signals_CommaKeyword_0_1_0 extends KeywordToken  {
	
	public Signals_CommaKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalsAccess().getCommaKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signals_Group_0_1(parent, this, 0, inst);
			case 1: return new Signals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class Signals_SignalsAssignment_0_1_1 extends AssignmentToken  {
	
	public Signals_SignalsAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalsAccess().getSignalsAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSignalsAccess().getSignalsSignalParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Signals_CommaKeyword_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ";"
protected class Signals_SemicolonKeyword_1 extends KeywordToken  {
	
	public Signals_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalsAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signals_Group_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Signals ****************/


/************ begin Rule InputSignals ****************
 *
 * InputSignals:
 *   (signals+=Signal ("," signals+=Signal)*) ";";
 *
 **/

// (signals+=Signal ("," signals+=Signal)*) ";"
protected class InputSignals_Group extends GroupToken {
	
	public InputSignals_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInputSignalsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InputSignals_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInputSignalsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signals+=Signal ("," signals+=Signal)*
protected class InputSignals_Group_0 extends GroupToken {
	
	public InputSignals_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInputSignalsAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InputSignals_Group_0_1(parent, this, 0, inst);
			case 1: return new InputSignals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class InputSignals_SignalsAssignment_0_0 extends AssignmentToken  {
	
	public InputSignals_SignalsAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInputSignalsAccess().getSignalsAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInputSignalsAccess().getSignalsSignalParserRuleCall_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," signals+=Signal)*
protected class InputSignals_Group_0_1 extends GroupToken {
	
	public InputSignals_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInputSignalsAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InputSignals_SignalsAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class InputSignals_CommaKeyword_0_1_0 extends KeywordToken  {
	
	public InputSignals_CommaKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInputSignalsAccess().getCommaKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InputSignals_Group_0_1(parent, this, 0, inst);
			case 1: return new InputSignals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class InputSignals_SignalsAssignment_0_1_1 extends AssignmentToken  {
	
	public InputSignals_SignalsAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInputSignalsAccess().getSignalsAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInputSignalsAccess().getSignalsSignalParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InputSignals_CommaKeyword_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ";"
protected class InputSignals_SemicolonKeyword_1 extends KeywordToken  {
	
	public InputSignals_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInputSignalsAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InputSignals_Group_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule InputSignals ****************/


/************ begin Rule OutputSignals ****************
 *
 * OutputSignals:
 *   (signals+=Signal ("," signals+=Signal)*) ";";
 *
 **/

// (signals+=Signal ("," signals+=Signal)*) ";"
protected class OutputSignals_Group extends GroupToken {
	
	public OutputSignals_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOutputSignalsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OutputSignals_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOutputSignalsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signals+=Signal ("," signals+=Signal)*
protected class OutputSignals_Group_0 extends GroupToken {
	
	public OutputSignals_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOutputSignalsAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OutputSignals_Group_0_1(parent, this, 0, inst);
			case 1: return new OutputSignals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class OutputSignals_SignalsAssignment_0_0 extends AssignmentToken  {
	
	public OutputSignals_SignalsAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOutputSignalsAccess().getSignalsAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOutputSignalsAccess().getSignalsSignalParserRuleCall_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," signals+=Signal)*
protected class OutputSignals_Group_0_1 extends GroupToken {
	
	public OutputSignals_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOutputSignalsAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OutputSignals_SignalsAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class OutputSignals_CommaKeyword_0_1_0 extends KeywordToken  {
	
	public OutputSignals_CommaKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOutputSignalsAccess().getCommaKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OutputSignals_Group_0_1(parent, this, 0, inst);
			case 1: return new OutputSignals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class OutputSignals_SignalsAssignment_0_1_1 extends AssignmentToken  {
	
	public OutputSignals_SignalsAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOutputSignalsAccess().getSignalsAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOutputSignalsAccess().getSignalsSignalParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OutputSignals_CommaKeyword_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ";"
protected class OutputSignals_SemicolonKeyword_1 extends KeywordToken  {
	
	public OutputSignals_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOutputSignalsAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OutputSignals_Group_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule OutputSignals ****************/


/************ begin Rule InOutputSignals ****************
 *
 * InOutputSignals:
 *   (signals+=Signal ("," signals+=Signal)*) ";"; 
 * 
 * 
 * 	      
 * 	
 * 
 * //==============================================================================
 * // synccharts elements as needed
 * //==============================================================================
 *
 **/

// (signals+=Signal ("," signals+=Signal)*) ";"
protected class InOutputSignals_Group extends GroupToken {
	
	public InOutputSignals_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInOutputSignalsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InOutputSignals_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInOutputSignalsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// signals+=Signal ("," signals+=Signal)*
protected class InOutputSignals_Group_0 extends GroupToken {
	
	public InOutputSignals_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInOutputSignalsAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InOutputSignals_Group_0_1(parent, this, 0, inst);
			case 1: return new InOutputSignals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class InOutputSignals_SignalsAssignment_0_0 extends AssignmentToken  {
	
	public InOutputSignals_SignalsAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInOutputSignalsAccess().getSignalsAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInOutputSignalsAccess().getSignalsSignalParserRuleCall_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," signals+=Signal)*
protected class InOutputSignals_Group_0_1 extends GroupToken {
	
	public InOutputSignals_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInOutputSignalsAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InOutputSignals_SignalsAssignment_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class InOutputSignals_CommaKeyword_0_1_0 extends KeywordToken  {
	
	public InOutputSignals_CommaKeyword_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInOutputSignalsAccess().getCommaKeyword_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InOutputSignals_Group_0_1(parent, this, 0, inst);
			case 1: return new InOutputSignals_SignalsAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// signals+=Signal
protected class InOutputSignals_SignalsAssignment_0_1_1 extends AssignmentToken  {
	
	public InOutputSignals_SignalsAssignment_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInOutputSignalsAccess().getSignalsAssignment_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("signals",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("signals");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getInOutputSignalsAccess().getSignalsSignalParserRuleCall_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new InOutputSignals_CommaKeyword_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ";"
protected class InOutputSignals_SemicolonKeyword_1 extends KeywordToken  {
	
	public InOutputSignals_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInOutputSignalsAccess().getSemicolonKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InOutputSignals_Group_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule InOutputSignals ****************/


/************ begin Rule Signal ****************
 *
 * Signal returns synccharts::Signal:
 *   name=ID|name=ID (":=" initialValue=STRING)|name=ID (":=" initialValue=STRING) type=
 *   ValueType|name=ID (":=" initialValue=STRING) ("combine" type=ValueType "with"
 *   combineOperator=CombineOperator)|name=ID (":=" initialValue=STRING) hostType=STRING
 *   |name=ID (":=" initialValue=STRING) ("combine" hostType=STRING "with"
 *   hostCombineOperator=STRING)|name=ID ("combine" type=ValueType "with" combineOperator
 *   =CombineOperator)|name=ID ("combine" hostType=STRING "with" hostCombineOperator=
 *   STRING); 
 * 
 * //==============================================================================
 * // synccharts elements as needed
 * //==============================================================================
 *
 **/

// name=ID|name=ID (":=" initialValue=STRING)|name=ID (":=" initialValue=STRING) type=
// ValueType|name=ID (":=" initialValue=STRING) ("combine" type=ValueType "with"
// combineOperator=CombineOperator)|name=ID (":=" initialValue=STRING) hostType=STRING
// |name=ID (":=" initialValue=STRING) ("combine" hostType=STRING "with"
// hostCombineOperator=STRING)|name=ID ("combine" type=ValueType "with" combineOperator
// =CombineOperator)|name=ID ("combine" hostType=STRING "with" hostCombineOperator=
// STRING)
protected class Signal_Alternatives extends AlternativesToken {

	public Signal_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSignalAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_0(parent, this, 0, inst);
			case 1: return new Signal_Group_1(parent, this, 1, inst);
			case 2: return new Signal_Group_2(parent, this, 2, inst);
			case 3: return new Signal_Group_3(parent, this, 3, inst);
			case 4: return new Signal_Group_4(parent, this, 4, inst);
			case 5: return new Signal_Group_5(parent, this, 5, inst);
			case 6: return new Signal_Group_6(parent, this, 6, inst);
			case 7: return new Signal_Group_7(parent, this, 7, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSignalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class Signal_NameAssignment_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// name=ID (":=" initialValue=STRING)
protected class Signal_Group_1 extends GroupToken {
	
	public Signal_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_1_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// ":=" initialValue=STRING
protected class Signal_Group_1_1 extends GroupToken {
	
	public Signal_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InitialValueAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Signal_ColonEqualsSignKeyword_1_1_0 extends KeywordToken  {
	
	public Signal_ColonEqualsSignKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getColonEqualsSignKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=STRING
protected class Signal_InitialValueAssignment_1_1_1 extends AssignmentToken  {
	
	public Signal_InitialValueAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getInitialValueAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_ColonEqualsSignKeyword_1_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getInitialValueSTRINGTerminalRuleCall_1_1_1_0();
			return obj;
		}
		return null;
	}

}



// name=ID (":=" initialValue=STRING) type=ValueType
protected class Signal_Group_2 extends GroupToken {
	
	public Signal_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_TypeAssignment_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_2_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_2_0_0();
			return obj;
		}
		return null;
	}

}

// ":=" initialValue=STRING
protected class Signal_Group_2_1 extends GroupToken {
	
	public Signal_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InitialValueAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Signal_ColonEqualsSignKeyword_2_1_0 extends KeywordToken  {
	
	public Signal_ColonEqualsSignKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getColonEqualsSignKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=STRING
protected class Signal_InitialValueAssignment_2_1_1 extends AssignmentToken  {
	
	public Signal_InitialValueAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getInitialValueAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_ColonEqualsSignKeyword_2_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getInitialValueSTRINGTerminalRuleCall_2_1_1_0();
			return obj;
		}
		return null;
	}

}


// type=ValueType
protected class Signal_TypeAssignment_2_2 extends AssignmentToken  {
	
	public Signal_TypeAssignment_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getTypeAssignment_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getSignalAccess().getTypeValueTypeEnumRuleCall_2_2_0();
			return obj;
		}
		return null;
	}

}


// name=ID (":=" initialValue=STRING) ("combine" type=ValueType "with" combineOperator=
// CombineOperator)
protected class Signal_Group_3 extends GroupToken {
	
	public Signal_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_3_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_3_0_0();
			return obj;
		}
		return null;
	}

}

// ":=" initialValue=STRING
protected class Signal_Group_3_1 extends GroupToken {
	
	public Signal_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InitialValueAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Signal_ColonEqualsSignKeyword_3_1_0 extends KeywordToken  {
	
	public Signal_ColonEqualsSignKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getColonEqualsSignKeyword_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=STRING
protected class Signal_InitialValueAssignment_3_1_1 extends AssignmentToken  {
	
	public Signal_InitialValueAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getInitialValueAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_ColonEqualsSignKeyword_3_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getInitialValueSTRINGTerminalRuleCall_3_1_1_0();
			return obj;
		}
		return null;
	}

}


// "combine" type=ValueType "with" combineOperator=CombineOperator
protected class Signal_Group_3_2 extends GroupToken {
	
	public Signal_Group_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_CombineOperatorAssignment_3_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "combine"
protected class Signal_CombineKeyword_3_2_0 extends KeywordToken  {
	
	public Signal_CombineKeyword_3_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getCombineKeyword_3_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=ValueType
protected class Signal_TypeAssignment_3_2_1 extends AssignmentToken  {
	
	public Signal_TypeAssignment_3_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getTypeAssignment_3_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_CombineKeyword_3_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getSignalAccess().getTypeValueTypeEnumRuleCall_3_2_1_0();
			return obj;
		}
		return null;
	}

}

// "with"
protected class Signal_WithKeyword_3_2_2 extends KeywordToken  {
	
	public Signal_WithKeyword_3_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getWithKeyword_3_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_TypeAssignment_3_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// combineOperator=CombineOperator
protected class Signal_CombineOperatorAssignment_3_2_3 extends AssignmentToken  {
	
	public Signal_CombineOperatorAssignment_3_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getCombineOperatorAssignment_3_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_WithKeyword_3_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("combineOperator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("combineOperator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getSignalAccess().getCombineOperatorCombineOperatorEnumRuleCall_3_2_3_0();
			return obj;
		}
		return null;
	}

}



// name=ID (":=" initialValue=STRING) hostType=STRING
protected class Signal_Group_4 extends GroupToken {
	
	public Signal_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_HostTypeAssignment_4_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_4_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_4_0_0();
			return obj;
		}
		return null;
	}

}

// ":=" initialValue=STRING
protected class Signal_Group_4_1 extends GroupToken {
	
	public Signal_Group_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InitialValueAssignment_4_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Signal_ColonEqualsSignKeyword_4_1_0 extends KeywordToken  {
	
	public Signal_ColonEqualsSignKeyword_4_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getColonEqualsSignKeyword_4_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=STRING
protected class Signal_InitialValueAssignment_4_1_1 extends AssignmentToken  {
	
	public Signal_InitialValueAssignment_4_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getInitialValueAssignment_4_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_ColonEqualsSignKeyword_4_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getInitialValueSTRINGTerminalRuleCall_4_1_1_0();
			return obj;
		}
		return null;
	}

}


// hostType=STRING
protected class Signal_HostTypeAssignment_4_2 extends AssignmentToken  {
	
	public Signal_HostTypeAssignment_4_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getHostTypeAssignment_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hostType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hostType");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getHostTypeSTRINGTerminalRuleCall_4_2_0();
			return obj;
		}
		return null;
	}

}


// name=ID (":=" initialValue=STRING) ("combine" hostType=STRING "with"
// hostCombineOperator=STRING)
protected class Signal_Group_5 extends GroupToken {
	
	public Signal_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_5_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_5_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_5_0_0();
			return obj;
		}
		return null;
	}

}

// ":=" initialValue=STRING
protected class Signal_Group_5_1 extends GroupToken {
	
	public Signal_Group_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_InitialValueAssignment_5_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Signal_ColonEqualsSignKeyword_5_1_0 extends KeywordToken  {
	
	public Signal_ColonEqualsSignKeyword_5_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getColonEqualsSignKeyword_5_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_5_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=STRING
protected class Signal_InitialValueAssignment_5_1_1 extends AssignmentToken  {
	
	public Signal_InitialValueAssignment_5_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getInitialValueAssignment_5_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_ColonEqualsSignKeyword_5_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getInitialValueSTRINGTerminalRuleCall_5_1_1_0();
			return obj;
		}
		return null;
	}

}


// "combine" hostType=STRING "with" hostCombineOperator=STRING
protected class Signal_Group_5_2 extends GroupToken {
	
	public Signal_Group_5_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_HostCombineOperatorAssignment_5_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "combine"
protected class Signal_CombineKeyword_5_2_0 extends KeywordToken  {
	
	public Signal_CombineKeyword_5_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getCombineKeyword_5_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// hostType=STRING
protected class Signal_HostTypeAssignment_5_2_1 extends AssignmentToken  {
	
	public Signal_HostTypeAssignment_5_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getHostTypeAssignment_5_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_CombineKeyword_5_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hostType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hostType");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getHostTypeSTRINGTerminalRuleCall_5_2_1_0();
			return obj;
		}
		return null;
	}

}

// "with"
protected class Signal_WithKeyword_5_2_2 extends KeywordToken  {
	
	public Signal_WithKeyword_5_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getWithKeyword_5_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_HostTypeAssignment_5_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// hostCombineOperator=STRING
protected class Signal_HostCombineOperatorAssignment_5_2_3 extends AssignmentToken  {
	
	public Signal_HostCombineOperatorAssignment_5_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getHostCombineOperatorAssignment_5_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_WithKeyword_5_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hostCombineOperator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hostCombineOperator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getHostCombineOperatorSTRINGTerminalRuleCall_5_2_3_0();
			return obj;
		}
		return null;
	}

}



// name=ID ("combine" type=ValueType "with" combineOperator=CombineOperator)
protected class Signal_Group_6 extends GroupToken {
	
	public Signal_Group_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_6_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_6_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_6_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_6_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_6_0_0();
			return obj;
		}
		return null;
	}

}

// "combine" type=ValueType "with" combineOperator=CombineOperator
protected class Signal_Group_6_1 extends GroupToken {
	
	public Signal_Group_6_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_6_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_CombineOperatorAssignment_6_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "combine"
protected class Signal_CombineKeyword_6_1_0 extends KeywordToken  {
	
	public Signal_CombineKeyword_6_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getCombineKeyword_6_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_6_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=ValueType
protected class Signal_TypeAssignment_6_1_1 extends AssignmentToken  {
	
	public Signal_TypeAssignment_6_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getTypeAssignment_6_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_CombineKeyword_6_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getSignalAccess().getTypeValueTypeEnumRuleCall_6_1_1_0();
			return obj;
		}
		return null;
	}

}

// "with"
protected class Signal_WithKeyword_6_1_2 extends KeywordToken  {
	
	public Signal_WithKeyword_6_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getWithKeyword_6_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_TypeAssignment_6_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// combineOperator=CombineOperator
protected class Signal_CombineOperatorAssignment_6_1_3 extends AssignmentToken  {
	
	public Signal_CombineOperatorAssignment_6_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getCombineOperatorAssignment_6_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_WithKeyword_6_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("combineOperator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("combineOperator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getSignalAccess().getCombineOperatorCombineOperatorEnumRuleCall_6_1_3_0();
			return obj;
		}
		return null;
	}

}



// name=ID ("combine" hostType=STRING "with" hostCombineOperator=STRING)
protected class Signal_Group_7 extends GroupToken {
	
	public Signal_Group_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_Group_7_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class Signal_NameAssignment_7_0 extends AssignmentToken  {
	
	public Signal_NameAssignment_7_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getNameAssignment_7_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getNameIDTerminalRuleCall_7_0_0();
			return obj;
		}
		return null;
	}

}

// "combine" hostType=STRING "with" hostCombineOperator=STRING
protected class Signal_Group_7_1 extends GroupToken {
	
	public Signal_Group_7_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSignalAccess().getGroup_7_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_HostCombineOperatorAssignment_7_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "combine"
protected class Signal_CombineKeyword_7_1_0 extends KeywordToken  {
	
	public Signal_CombineKeyword_7_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getCombineKeyword_7_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_NameAssignment_7_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// hostType=STRING
protected class Signal_HostTypeAssignment_7_1_1 extends AssignmentToken  {
	
	public Signal_HostTypeAssignment_7_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getHostTypeAssignment_7_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_CombineKeyword_7_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hostType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hostType");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getHostTypeSTRINGTerminalRuleCall_7_1_1_0();
			return obj;
		}
		return null;
	}

}

// "with"
protected class Signal_WithKeyword_7_1_2 extends KeywordToken  {
	
	public Signal_WithKeyword_7_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSignalAccess().getWithKeyword_7_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_HostTypeAssignment_7_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// hostCombineOperator=STRING
protected class Signal_HostCombineOperatorAssignment_7_1_3 extends AssignmentToken  {
	
	public Signal_HostCombineOperatorAssignment_7_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSignalAccess().getHostCombineOperatorAssignment_7_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Signal_WithKeyword_7_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hostCombineOperator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hostCombineOperator");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSignalAccess().getHostCombineOperatorSTRINGTerminalRuleCall_7_1_3_0();
			return obj;
		}
		return null;
	}

}




/************ end Rule Signal ****************/


/************ begin Rule Variable ****************
 *
 * Variable returns synccharts::Variable:
 *   name=ID (":=" initialValue=STRING)? type=ValueType? ("host" hostType=STRING)?;
 *
 **/

// name=ID (":=" initialValue=STRING)? type=ValueType? ("host" hostType=STRING)?
protected class Variable_Group extends GroupToken {
	
	public Variable_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group_3(parent, this, 0, inst);
			case 1: return new Variable_TypeAssignment_2(parent, this, 1, inst);
			case 2: return new Variable_Group_1(parent, this, 2, inst);
			case 3: return new Variable_NameAssignment_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class Variable_NameAssignment_0 extends AssignmentToken  {
	
	public Variable_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// (":=" initialValue=STRING)?
protected class Variable_Group_1 extends GroupToken {
	
	public Variable_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_InitialValueAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":="
protected class Variable_ColonEqualsSignKeyword_1_0 extends KeywordToken  {
	
	public Variable_ColonEqualsSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableAccess().getColonEqualsSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// initialValue=STRING
protected class Variable_InitialValueAssignment_1_1 extends AssignmentToken  {
	
	public Variable_InitialValueAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getInitialValueAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_ColonEqualsSignKeyword_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initialValue",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initialValue");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getInitialValueSTRINGTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}


// type=ValueType?
protected class Variable_TypeAssignment_2 extends AssignmentToken  {
	
	public Variable_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group_1(parent, this, 0, inst);
			case 1: return new Variable_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getVariableAccess().getTypeValueTypeEnumRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ("host" hostType=STRING)?
protected class Variable_Group_3 extends GroupToken {
	
	public Variable_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_HostTypeAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "host"
protected class Variable_HostKeyword_3_0 extends KeywordToken  {
	
	public Variable_HostKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableAccess().getHostKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_TypeAssignment_2(parent, this, 0, inst);
			case 1: return new Variable_Group_1(parent, this, 1, inst);
			case 2: return new Variable_NameAssignment_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// hostType=STRING
protected class Variable_HostTypeAssignment_3_1 extends AssignmentToken  {
	
	public Variable_HostTypeAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getHostTypeAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_HostKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hostType",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hostType");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getHostTypeSTRINGTerminalRuleCall_3_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Variable ****************/

}
