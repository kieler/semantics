/*
 * generated by Xtext
 */
package de.cau.cs.kieler.synccharts.dsl.scoping;

import java.util.ArrayList;

import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.resource.EObjectDescription;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import de.cau.cs.kieler.synccharts.Action;
import de.cau.cs.kieler.synccharts.ComplexExpression;
import de.cau.cs.kieler.synccharts.Emission;
import de.cau.cs.kieler.synccharts.Expression;
import de.cau.cs.kieler.synccharts.Region;
import de.cau.cs.kieler.synccharts.Signal;
import de.cau.cs.kieler.synccharts.SignalReference;
import de.cau.cs.kieler.synccharts.State;
import de.cau.cs.kieler.synccharts.Transition;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class KitsScopeProvider extends AbstractDeclarativeScopeProvider {
	/**
	 * This declarative function calcualtes the scope of target states
	 * 
	 * @param context
	 *            the context
	 * @param reference
	 *            the reference
	 * @return new scope for target states
	 */
	IScope scope_Transition_targetState(Transition context, EReference reference) {
		State sourceState = null;
		if (context.eContainer() != null
				&& context.eContainer() instanceof State) {
			sourceState = (State) context.eContainer();
		}
		Region parentRegion = null;
		if (sourceState.getParentRegion() != null) {
			parentRegion = sourceState.getParentRegion();
		}

		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		if (!(parentRegion.getInnerStates().isEmpty())) {
			for (State innerState : parentRegion.getInnerStates()) {
				// if the inner state has a label then add its label
				if (innerState.getLabel() != null) {
					IEObjectDescription elem = EObjectDescription.create(
							innerState.getLabel(), innerState);
					scopeElems.add(elem);
				}
				// else if the inner state has an id then add its id
				else if (innerState.getId() != null) {
					IEObjectDescription elem = EObjectDescription.create(
							innerState.getId(), innerState);
					scopeElems.add(elem);
				}
			}
		}
		return new SimpleScope(scopeElems);
	}

	/**
	 * This declarative function calculates the scope of signals in emissions
	 * 
	 * @param context
	 *            the context
	 * @param reference
	 *            the reference
	 * @return new scope for signals in emissions
	 */

	IScope scope_Emission_signal(Emission context, EReference reference) {
		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		Action a = null;
		// this is my transition
		if (context.getParentEAction() != null) {
			a = context.getParentEAction();
		} else {
			System.out
					.println("DEBUG ERROR: No parent action found for Emission");
		}
		// assert a != null;
		State currentState = findParentState(a);
		// has the current state declared any signals?
		scopeElems.addAll(getStateSignals(currentState));
		// has the parent region of the current state declared any signals?
		Region r = currentState.getParentRegion();
		gatherSignals(r, scopeElems);
		return new SimpleScope(scopeElems);
	}

	/**
	 * * Helper to gather all signals in a region
	 * 
	 * @param r
	 * @param scopeElems
	 * @return all signals in a region and its inner states
	 */
	private void gatherSignals(Region r,
			ArrayList<IEObjectDescription> scopeElems) {
		State currentState = null;
		scopeElems.addAll(getRegionSignals(r));
		if (r.getParentState() != null) {
			currentState = r.getParentState();
			scopeElems.addAll(getStateSignals(currentState));
			// assert currentState.getParentRegion() != null;
			gatherSignals(currentState.getParentRegion(), scopeElems);
		}
		// return scopeElems;
	}

	/**
	 * @param state
	 *            the state to be searched for signal declarations
	 * @return signals that the state has declared
	 */
	private ArrayList<IEObjectDescription> getStateSignals(State state) {
		ArrayList<IEObjectDescription> stateSignals = new ArrayList<IEObjectDescription>();
		if (state.getSignals() != null) {
			for (Signal sig : state.getSignals()) {
				stateSignals.add(EObjectDescription.create(sig.getName(), sig));
				// System.out.println("=================================");
				// System.out.println("Source state signal: " + sig.getName());
				// System.out.println("=================================");
			}
		}
		return stateSignals;
	}

	/**
	 * 
	 * @param region
	 *            the region to be searched for signal declarations
	 * @return signals that the region has declared
	 */
	private ArrayList<IEObjectDescription> getRegionSignals(Region region) {
		ArrayList<IEObjectDescription> regionSignals = new ArrayList<IEObjectDescription>();
		if (region.getSignals() != null) {
			for (Signal sig : region.getSignals()) {
				regionSignals
						.add(EObjectDescription.create(sig.getName(), sig));
				// System.out.println("=================================");
				// System.out.println("Source state signal: " + sig.getName());
				// System.out.println("=================================");
			}
		}
		return regionSignals;
	}

	/**
	 * @param a
	 *            the Action that holds the Emission in which our Signal
	 *            reference is
	 * @return the state in which the Signal has been referenced
	 * 
	 */
	private State findParentState(Action a) {
		State s = null;
		if (a instanceof Transition) {
			Transition t = (Transition) a;
			s = t.getSourceState();
		}
		if (a.getParentStateEntryAction() != null) {
			s = a.getParentStateEntryAction();
		}
		if (a.getParentStateExitAction() != null) {
			s = a.getParentStateExitAction();
		}
		if (a.getParentStateInnerAction() != null) {
			s = a.getParentStateInnerAction();
		}
		if (a.getParentStateSuspension() != null) {
			s = a.getParentStateSuspension();
		}
		return s;

	}

	/**
	 * This declarative function calculates the scope of signals in signal
	 * references
	 * 
	 * @param context
	 *            the context
	 * @param reference
	 *            the reference
	 * @return new scope for signals in signal references
	 */
	IScope scope_SignalReference_signal(SignalReference context,
			EReference reference) {

		ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
		// TODO Test with complex expressions who are not direct children of
		// transitions
		Action action = null;
		if (context.getParentExpression() != null
				&& context.getParentExpression() instanceof ComplexExpression) {
			action = findParentTransition(context.getParentExpression());
		} else {
			action = context.getParentAction();
		}

		// this is my transition
		assert (action != null && action instanceof Action) : "No parent action found for Signal Reference "
				+ context.getSignal().getName();

		// assert a != null;
		State currentState = findParentState(action);
		// has the current state declared any signals?
		scopeElems.addAll(getStateSignals(currentState));
		// has the parent region of the current state declared any signals?
		Region r = currentState.getParentRegion();
		gatherSignals(r, scopeElems);

		return new SimpleScope(scopeElems);

	}

	/**
	 * @param context
	 * @param exp
	 * @return
	 */
	private Action findParentTransition(ComplexExpression exp) {
		if (exp.getParentExpression() instanceof ComplexExpression) {
			findParentTransition(exp.getParentExpression());
		}
		return exp.getParentAction();
	}

}
