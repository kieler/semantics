import synccharts;

// ================================================================================================
// Pseudo States 
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not be initial or final!" :
	isInitial == false && isFinal == false;
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain regions!" :
	(regions == null) || (regions.size == 0);
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain signals!" :
	(signals == null) || (signals.size == 0);
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain actions!" :
	((entryActions == null) || (entryActions.size == 0))
	&& ((innerActions == null) || (innerActions.size == 0))
	&& ((exitActions == null) || (exitActions.size == 0));
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain a suspension trigger!" :
	suspensionTrigger == null;
	
context State if (type == StateType::CONDITIONAL) 
	ERROR "Conditional states must have outgoing transitions" :
	outgoingTransitions.size>0;	
	
	
// ================================================================================================
// Reference States 
//context State if (type != StateType::REFERENCE) ERROR "only reference states may contain signal renamings!" :
//	(renamings == null) || (renamings.size == 0);

context State if (type != StateType::REFERENCE || type!= StateType::TEXTUAL) ERROR "Only textual or reference states may contain body text!" :
	(bodyText == null) || (bodyText.matches("\\s*"));
// ================================================================================================
// General States 
context State if (parentRegion != null && parentRegion.parentState != null && isInitial == false) // not checked for root state 
  ERROR "Not reachable state! Every state needs at least one incoming transition!" :
  (parentRegion.innerStates.exists(e|e.outgoingTransitions.exists(t|t.targetState == this)));

context State if ( label == null || label.matches("\\s*"))
	ERROR "Anonymous states (= no label) need an ID." : 
	(id != null && id.length>0);

context State if (label != null && !label.matches("\\s*"))
	ERROR "States within a region need to have different labels." :
	parentRegion.innerStates.forAll(s| (s.label != label) || (s == this));

context State
	ERROR "Names and IDs should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	(id.matches("\\w*") && label.matches("\\w*"));

context State if(outgoingTransitions.size > 1) 
  ERROR "A state can only have one outgoing normal termination!" :
    (outgoingTransitions.select(t|t.type == TransitionType::NORMALTERMINATION).size<=1 );
    
context State if(outgoingTransitions.size > 1) 
  WARNING "At least one of the transitions will never be taken." :
    (outgoingTransitions.select(t|t.trigger == null).size <= 1);

context State if (signals.size>0)
  ERROR "Signalname may not be empty!" :
   this.signals.forAll(s| s.name.length>0);


// Root state
context State if (parentRegion == null || parentRegion.parentState == null)
  WARNING "Model has no inputs":
   (signals.exists(s | s.isInput));

context State if (parentRegion == null || parentRegion.parentState == null)
  WARNING "Model has no outputs":
   (signals.exists(s | s.isOutput));

context State if (parentRegion == null || parentRegion.parentState == null)
  ERROR "The root state should have at least one Region containing at least one State! 
  Try upgrading the root state!":
   (regions.size > 0 && regions.forAll(r|r.innerStates.size > 0));

context State if (parentRegion != null && parentRegion.parentState == null)
  ERROR "There should be exactly one root State which represents the whole SyncChart.":
   (parentRegion.innerStates.size == 1);

// ================================================================================================
// Regions

context Region if (parentState != null) // not checked for root state
	ERROR "Every region should have exactly one initial state!" : 
	(innerStates.select(s|s.isInitial).size == 1);

context Region
	ERROR "Names and IDs should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	id.matches("\\w*");
	
context Region if ((parentState.parentRegion.parentState != null) && 
				   (parentState.outgoingTransitions.exists(t|t.type == TransitionType::NORMALTERMINATION)))
	ERROR "A hierarchical state with an outgoing normal termination \n"
		+ "has to contain at least one final state in every parallel region." :
	(innerStates.select(s|s.isFinal).size > 0);

context Region 
	ERROR "An empty Region does not make sense! Remove the Region or add States to it!" : 
	(innerStates.size > 0);

// ================================================================================================
// Signals
context Signal if (parentState != null && parentState.parentRegion != null && parentState.parentRegion.parentState != null) 
    ERROR "Only signals in the root state may be global inputs or outputs." :
	((!isInput) && (!isOutput));

context Signal if ((initialValue == null) || (initialValue == "")) 
    ERROR "Only valued signals may have a combine type other than NONE!" :
	combineOperator == CombineOperator::NONE;
	
context Signal
	ERROR "Signals need unique names in a State or Region declaration." :
	( parentRegion != null && parentRegion.signals.forAll(s| (s.name != name) || (s == this)) ||
	  parentState != null && parentState.signals.forAll(s| (s.name != name) || (s == this)) )
	;

context Variable
	ERROR "Variables need unique names in a Region declaration." :
	( parentRegion != null && parentRegion.signals.forAll(s| (s.name != name) || (s == this)) )
	;

context ValuedObject
	ERROR "Names and IDs should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	(name.matches("\\w*"));
	
// ================================================================================================
// Transitions
context Transition if (isImmediate) ERROR "Immediate transitions must not have a delay!" :
	(delay == null) || (delay == 1);
	
context Transition ERROR "Delays have to be at least 1!" :
	(delay == null) || (delay >= 1);
	
context Transition if (isImmediate)
	ERROR "An immediate transition produces an endless loop!" :
	sourceState != targetState;

context Transition if (type == TransitionType::NORMALTERMINATION)
   	ERROR "Normal termination may not have a trigger!" :
   	(trigger == null);   
   	
context Transition if (type == TransitionType::NORMALTERMINATION)
   	ERROR "Normal termination must have the lowest priority!" :
   	(!sourceState.outgoingTransitions.exists(t|t.priority > this.priority));  

context Transition if (type == TransitionType::NORMALTERMINATION)
	ERROR "Simple states may not have a normal termination transition" :
	(sourceState.regions.size!=0);

context Transition if(sourceState.outgoingTransitions.size > 1) 
    ERROR "Priorities of outgoing transitions need to be distinct!" :
    (sourceState.outgoingTransitions.forAll(t| (priority != t.priority || this == t)));

// ================================================================================================
// Expressions
// FIXME: Problem is that checks done in a strange context are not displayed in the model as markers, 
// Use only valid contexts for checks. Otherwise only the problem view shows the error.
context ComplexExpression if ((operator == OperatorType::NOT) || (operator == OperatorType::VAL)) ERROR "Unary operators may not have more or less than one operand!" :
	subExpressions.size == 1;
	
context ComplexExpression if (!((operator == OperatorType::NOT) || (operator == OperatorType::VAL) || (operator == OperatorType::PRE))) ERROR "Binary operators may not have more or less than two operands!" :
	subExpressions.size == 2;

// ================================================================================================
// Emissions
	
context Emission if (signal.type == ValueType::PURE) ERROR "Pure signals cannot be assigned a value!" :
	newValue == null;
	
context Emission if (!(signal.type == ValueType::PURE)) ERROR "Valued signals must be assigned a value!" :
	newValue != null;
	
// ================================================================================================
// Actions

context Action if (triggersAndEffects != null && triggersAndEffects.trim().compareTo("") != 0 ) 
    ERROR "Triggers and Effects String has not correctly been parsed yet! Action children are empty
           but triggers and effects string contains text." :
    (trigger != null || (effects!=null && effects.size >0) || this.isImmediate);
	