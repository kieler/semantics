import synccharts;

// ================================================================================================
// Pseudo States 
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not be initial or final!" :
	isInitial == false && isFinal == false;
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain regions!" :
	(regions == null) || (regions.size == 0);
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain signals!" :
	(signals == null) || (signals.size == 0);
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain actions!" :
	((entryActions == null) || (entryActions.size == 0))
	&& ((innerActions == null) || (innerActions.size == 0))
	&& ((exitActions == null) || (exitActions.size == 0));
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain a suspension trigger!" :
	suspensionTrigger == null;
	
context State if (type == StateType::CONDITIONAL) 
	ERROR "Conditional states must have outgoing transitions" :
	outgoingTransitions.size>0;	
	
	
// ================================================================================================
// Reference States 
//context State if (type != StateType::REFERENCE) ERROR "only reference states may contain signal renamings!" :
//	(renamings == null) || (renamings.size == 0);

context State if (type != StateType::REFERENCE && type != StateType::TEXTUAL) 
	ERROR "Only textual or reference states may contain body text!" :
	(bodyText == null) || (bodyText.code.matches("\\s*"));
// ================================================================================================
// General States 
context State if (parentRegion != null && parentRegion.parentState != null && isInitial == false) // not checked for root state 
  ERROR "Not reachable state! Every state needs at least one incoming transition!" :
  (parentRegion.innerStates.exists(e|e.outgoingTransitions.exists(t|t.targetState == this)));

context State
	ERROR "States need an ID. The tool gives IDs automatically to states. So if a state has no ID, something went wrong. Rename or recreate the state and send a bug report, please!" : 
	(id != null && !id.matches("\\s*"));

context State if (id != null && !id.matches("\\s*"))
	ERROR "States within a region need to have different IDs (which are created from their labels)." :
	parentRegion.innerStates.forAll(s| (s.id != id) || (s == this));

context State
	ERROR "IDs should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	(id.matches("\\w*"));
//	 && label.matches("\\w*"));

context State if(outgoingTransitions.size > 1) 
  ERROR "A state can only have one outgoing normal termination!" :
    (outgoingTransitions.select(t|t.type == TransitionType::NORMALTERMINATION).size<=1 );
    
context State if(outgoingTransitions.size > 1) 
  WARNING "At least one of the transitions will never be taken." :
    (outgoingTransitions.select(t|t.trigger == null).size <= 1);

context State if (signals.size>0)
  ERROR "Signalname may not be empty!" :
   this.signals.forAll(s| s.name.length>0);

// TODO: verify those check conditions when variables work
context State if (interfaceDeclaration.length > 0)
  WARNING "The Interfacedeclaration is not empty but there are no signals and variables defined" :
  	(!this.signals.isEmpty) || (!this.regions.select(r | (!r.variables.isEmpty || !r.signals.isEmpty)).isEmpty);
   
// Root state
context State if (parentRegion == null || parentRegion.parentState == null)
  WARNING "Model has no inputs":
   (signals.exists(s | s.isInput));

context State if (parentRegion == null || parentRegion.parentState == null)
  WARNING "Model has no outputs":
   (signals.exists(s | s.isOutput));

context State if (parentRegion == null || parentRegion.parentState == null)
  ERROR "The root state should have at least one Region containing at least one State! 
  Try upgrading the root state!":
   (regions.size > 0 && regions.forAll(r|r.innerStates.size > 0));

context State if (parentRegion != null && parentRegion.parentState == null)
  ERROR "There should be exactly one root State which represents the whole SyncChart.":
   (parentRegion.innerStates.size == 1);

// ================================================================================================
// Regions

context Region if (parentState != null) // not checked for root state
	ERROR "Every region should have exactly one initial state!" : 
	(innerStates.select(s|s.isInitial).size == 1);

context Region
	ERROR "IDs should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	id.matches("\\w*");
	
context Region if ((parentState.parentRegion.parentState != null) && 
				   (parentState.outgoingTransitions.exists(t|t.type == TransitionType::NORMALTERMINATION)))
	ERROR "A hierarchical state with an outgoing normal termination \n"
		+ "has to contain at least one final state in every parallel region." :
	(innerStates.select(s|s.isFinal).size > 0);

context Region 
	ERROR "An empty Region does not make sense! Remove the Region or add States to it!" : 
	(innerStates.size > 0);

context Region if(parentState != null && parentState.regions.size > 1)
	ERROR "Regions in a state need to have unique IDs within that state." :
	(id!= null && !id.matches("\\s*") && parentState.regions.forAll(r| (r.id != id) || (r == this)));

// ================================================================================================
// Signals
context Signal if (parentState != null && parentState.parentRegion != null && parentState.parentRegion.parentState != null) 
    ERROR "Only signals in the root state may be global inputs or outputs." :
	((!isInput) && (!isOutput));

context Signal if ((initialValue == null) || (initialValue == "")) 
    ERROR "Only valued signals may have a combine type other than NONE!" :
	combineOperator == CombineOperator::NONE;
	
context Signal
	ERROR "Signals need unique names in a State or Region declaration." :
	( parentRegion != null && parentRegion.signals.forAll(s| (s.name != name) || (s == this)) ||
	  parentState != null && parentState.signals.forAll(s| (s.name != name) || (s == this)) )
	;
		
context Signal if (isInput || (! isOutput && ! isInput))
	WARNING "Signal never read." :
	( parentState != null && parentState.eAllContents.typeSelect(SignalReference).select(reference|reference.signal.name == this.name).size > 0 ) ||
	( parentRegion != null && parentRegion.eAllContents.typeSelect(SignalReference).select(reference|reference.signal.name == this.name).size > 0);

context Signal if (isOutput || (! isInput && ! isOutput))
	WARNING "Signal never emitted." :
	( parentState != null && parentState.eAllContents.typeSelect(Emission).select(emission|emission.signal.name == this.name).size > 0 ) ||
	( parentRegion != null && parentRegion.eAllContents.typeSelect(Emission).select(emission|emission.signal.name == this.name).size > 0);

context Variable
	ERROR "Variables need unique names in a Region declaration." :
	( parentRegion != null && parentRegion.signals.forAll(s| (s.name != name) || (s == this)) )
	;

context ValuedObject
	ERROR "Variable and Signal names should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	(name.matches("\\w*"));
	
// ================================================================================================
// Transitions
context Transition if (isImmediate) ERROR "Immediate transitions must not have a delay!" :
	(delay == null) || (delay == 1);
	
context Transition ERROR "Delays have to be at least 1!" :
	(delay == null) || (delay >= 1);
	
context Transition if (isImmediate)
	ERROR "An immediate transition produces an endless loop!" :
	sourceState != targetState;

context Transition if (type == TransitionType::NORMALTERMINATION)
   	ERROR "Normal termination may not have a trigger!" :
   	(trigger == null);   
   	
context Transition if (type == TransitionType::NORMALTERMINATION)
   	ERROR "Normal termination must have the lowest priority!" :
   	(!sourceState.outgoingTransitions.exists(t|t.priority > this.priority));  

context Transition if (type == TransitionType::NORMALTERMINATION)
	ERROR "Simple states may not have a normal termination transition" :
	((sourceState.regions.size!=0)  || (sourceState.type == StateType::REFERENCE));

context Transition if(sourceState.outgoingTransitions.size > 1) 
    ERROR "Priorities of outgoing transitions need to be distinct!" :
    (sourceState.outgoingTransitions.forAll(t| (priority != t.priority || this == t)));
    
context Transition
	ERROR "SyncCharts do not support inter-level transitions!\nOnly use transitions between states in the same region!\nYou can use final states and normal termination transitions to emulate inter-level transition behavior.":
	(sourceState.parentRegion == targetState.parentRegion);

// ================================================================================================
// Expressions
// FIXME: Problem is that checks done in a strange context are not displayed in the model as markers, 
// Use only valid contexts for checks. Otherwise only the problem view shows the error.
context ComplexExpression if ((operator == OperatorType::NOT) || (operator == OperatorType::VAL)) ERROR "Unary operators may not have more or less than one operand!" :
	subExpressions.size == 1;
	
context ComplexExpression if (!((operator == OperatorType::NOT) || (operator == OperatorType::VAL) || (operator == OperatorType::PRE))) ERROR "Binary operators may not have more or less than two operands!" :
	subExpressions.size == 2;

// ================================================================================================
// Emissions
	
context Emission if (signal.type == ValueType::PURE) ERROR "Pure signals cannot be assigned a value!" :
	newValue == null;
	
context Emission if (!(signal.type == ValueType::PURE)) ERROR "Valued signals must be assigned a value!" :
	newValue != null;
	
// ================================================================================================
// Actions

context Action if (triggersAndEffects != null && triggersAndEffects.trim().compareTo("") != 0 ) 
    ERROR "Triggers and Effects String has not correctly been parsed yet! Action children are empty
           but triggers and effects string contains text." :
    (trigger != null || (effects!=null && effects.size >0) || this.isImmediate);
    
// Only Transitions can have a triggers without effects
context Action if (parentStateEntryAction != null || parentStateExitAction != null || parentStateInnerAction != null || parentStateSuspension != null)
	ERROR "Trigger must have an effect." :
	effects.size > 0;
