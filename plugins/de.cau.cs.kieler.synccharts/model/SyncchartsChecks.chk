import synccharts;
import kexpressions;

// ===========================================================================
// Scopes

Boolean signalNotRead(Signal signal, Scope scope):
 scope.eAllContents.typeSelect(ValuedObjectReference).select(reference|reference.valuedObject.name.matches(signal.name)).isEmpty
;

Boolean signalNotEmitted(Signal signal, Scope scope):
 scope.eAllContents.typeSelect(Emission).select(emission|emission.signal.name.matches(signal.name)).isEmpty
;

List[Signal] getDuplicateSignals(Scope scope):
  scope.signals.select(e|!scope.signals.forAll(s| (s.name != e.name) || (s == e)))
;

List[Variable] getDuplicateVariables(Scope scope):
  scope.variables.select(e|!scope.variables.forAll(s| (s.name != e.name) || (s == e)))
;

List[Signal] getUnreadSignals(Scope scope):
 scope.signals.select(e|(e.isInput || !e.isOutput) && e.signalNotRead(scope) && e.name != "tick")
;

List[Signal] getUnemittedSignals(Scope scope):
 scope.signals.select(e|(e.isOutput || !e.isInput) && e.signalNotEmitted(scope) && e.name != "tick")
;

Boolean containsTextualState(Scope scope):
  !(scope.eAllContents.typeSelect(State).select(state|state.type == StateType::TEXTUAL).isEmpty)
;

context Scope
   ERROR "The following signals in this scope are duplicates but signals must be unique: " + this.getDuplicateSignals().name :
   this.getDuplicateSignals().isEmpty || this.containsTextualState()
;

context Scope
   ERROR "The following variables in this scope are duplicates but signals must be unique: " + this.getDuplicateVariables().name :
   this.getDuplicateVariables().isEmpty || this.containsTextualState()
;

context Scope
   WARNING "The following signals in this scope are never read: " + this.getUnreadSignals().name :
   this.getUnreadSignals().isEmpty || this.containsTextualState()
;

context Scope
    WARNING "The following signals in this scope are never emitted: " + this.getUnemittedSignals().name : 
    this.getUnemittedSignals().isEmpty || this.containsTextualState()
    ;

Boolean variableNotRead(Variable var, Scope scope):
 scope.eAllContents.typeSelect(ValuedObjectReference).select(reference|reference.valuedObject.name == var.name).isEmpty
;

Boolean variableNotWritten(Variable var, Scope scope):
 scope.eAllContents.typeSelect(Assignment).select(assignment|assignment.variable.name == var.name).isEmpty
;

context Scope
   WARNING "The following variables in this scope are never read: " + variables.select(e|e.variableNotRead(this)).name :
   variables.select(e|e.variableNotRead(this)).isEmpty
;

context Scope
    WARNING "The following variables in this scope never get a value assigned to them: " + variables.select(e|!e.const && e.variableNotWritten(this)).name : 
    variables.select(e|!e.const && e.variableNotWritten(this)).isEmpty
;

// ================================================================================================
// Pseudo States 
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not be initial or final!" :
	isInitial == false && isFinal == false;
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain regions!" :
	(regions == null) || (regions.size == 0);
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain signals!" :
	(signals == null) || (signals.size == 0);
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain actions!" :
	((entryActions == null) || (entryActions.size == 0))
	&& ((innerActions == null) || (innerActions.size == 0))
	&& ((exitActions == null) || (exitActions.size == 0));
	
context State if (type == StateType::CONDITIONAL) ERROR "Conditional states must not contain a suspension trigger!" :
	suspensionTrigger == null;
	
context State if (type == StateType::CONDITIONAL) 
	ERROR "Conditional states must have outgoing transitions" :
	outgoingTransitions.size>0;	
	 
	
// ================================================================================================
// Reference States 
//context State if (type != StateType::REFERENCE) ERROR "only reference states may contain signal renamings!" :
//	(renamings == null) || (renamings.size == 0);

context State if (type != StateType::REFERENCE && type != StateType::TEXTUAL) 
	ERROR "Only textual or reference states may contain body text!" :
	(bodyText == null) || (bodyText.size == 0); // (bodyText.code.toString().trim().matches("")); <-- the string appears to be "[]" 
	
// ================================================================================================
// General States 
context State if (parentRegion != null && parentRegion.parentState != null && isInitial == false) // not checked for root state 
  ERROR "Not reachable state! Every state needs at least one incoming transition!" :
  (parentRegion.states.exists(e|e.outgoingTransitions.exists(t|t.targetState == this)));

context State
	ERROR "States need an ID. The tool gives IDs automatically to states. So if a state has no ID, something went wrong. Rename or recreate the state and send a bug report, please!" : 
	(id != null && !id.matches("\\s*"));

context State if (id != null && !id.matches("\\s*"))
	ERROR "States within a region need to have different IDs (which are created from their labels)." :
	parentRegion.states.forAll(s| (s.id != id) || (s == this));

context State
	ERROR "IDs should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	(id.matches("\\w*"));
//	 && label.matches("\\w*"));

context State if(outgoingTransitions.size > 1) 
  ERROR "A state can only have one outgoing normal termination!" :
    (outgoingTransitions.select(t|t.type == TransitionType::NORMALTERMINATION).size<=1 );
    
context State if(outgoingTransitions.size > 1) 
  WARNING "At least one of the transitions will never be taken." :
    (outgoingTransitions.select(t|t.trigger == null).size <= 1);

context State if (signals.size>0)
  ERROR "Signalname may not be empty!" :
   this.signals.forAll(s| s.name.length>0);

// TODO: verify those check conditions when variables work
context Scope if (!interfaceDeclaration.trim().matches(""))
  WARNING "The Interfacedeclaration is not empty but there are no signals and variables defined" :
  	(!this.signals.isEmpty) || (!this.variables.isEmpty);
   
// Root state
/*
context State if (parentRegion == null || parentRegion.parentState == null)
  WARNING "Model has no inputs":
   (signals.exists(s | s.isInput));

context State if (parentRegion == null || parentRegion.parentState == null)
  WARNING "Model has no outputs":
   (signals.exists(s | s.isOutput));
*/

context State if ((parentRegion == null || parentRegion.parentState == null) && bodyText.isEmpty)
  ERROR "The root state should have at least one Region containing at least one State! 
  Try upgrading the root state!":
   (regions.size > 0 && regions.forAll(r|r.states.size > 0));

context State if (parentRegion != null && parentRegion.parentState == null)
  ERROR "There should be exactly one root State which represents the whole SyncChart.":
   (parentRegion.states.size == 1);

// ================================================================================================
// Regions

context Region if (parentState != null && bodyText.isEmpty ) // not checked for root state
	ERROR "Every region should have exactly one initial state!" : 
	(states.select(s|s.isInitial).size == 1);

context Region
	ERROR "IDs should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	id.matches("\\w*");
	
context Region if ((parentState.parentRegion.parentState != null) && 
				   (parentState.outgoingTransitions.exists(t|t.type == TransitionType::NORMALTERMINATION)))
	ERROR "A hierarchical state with an outgoing normal termination \n"
		+ "has to contain at least one final state in every parallel region." :
	(states.select(s|s.isFinal).size > 0);

context Region if (bodyText.isEmpty) // only check if no textual macrostate
	ERROR "An empty Region does not make sense! Remove the Region or add States to it!" : 
	(states.size > 0);

// haf: removed this rule because we decided to also allow Regions without an ID
//context Region if(parentState != null && parentState.regions.size > 1)
//	ERROR "Regions in a state need to have unique IDs within that state." :
//	(id!= null && !id.matches("\\s*") && parentState.regions.forAll(r| (r.id != id) || (r == this)));

// ================================================================================================
// Signals

context Signal if (eContainer /*=parentState*/ != null && eContainer.eContainer.eContainer /*=parentState.parentRegion.parentState*/ != null) 
    ERROR "Only signals in the root state may be global inputs or outputs." :
	((!isInput) && (!isOutput));

context Signal if ((initialValue == null) || (initialValue == "")) 
    ERROR "Only valued signals may have a combine type other than NONE!" :
	combineOperator == CombineOperator::NONE;
	
		
context ValuedObject
	ERROR "Variable and Signal names should be of standard identifier type, i.e. only contain characters, numbers and the _ sign." :
	(name.matches("\\w*"));
	
// ================================================================================================
// Transitions
context Transition ERROR "Priorities have to be at least 1!" :
    (priority == null) || (priority >= 1);

context Transition if (isImmediate) ERROR "Immediate transitions must not have a delay!" :
	(delay == null) || (delay == 1);
	
context Transition ERROR "Delays have to be at least 1!" :
	(delay == null) || (delay >= 1);
	
context Transition if (isImmediate)
	ERROR "An immediate transition produces an endless loop!" :
	sourceState != targetState;

context Transition if (type == TransitionType::NORMALTERMINATION)
   	ERROR "Normal termination may not have a trigger!" :
   	(trigger == null);   
   	
context Transition if (type == TransitionType::NORMALTERMINATION)
   	ERROR "Normal termination must have the lowest priority!" :
   	(!sourceState.outgoingTransitions.exists(t|t.priority > this.priority));  

context Transition if (type == TransitionType::STRONGABORT)
    ERROR "Strong aborts must have the highest priority!" :
    (sourceState.outgoingTransitions.forAll(t|t.priority > this.priority || t.type == this.type)); 

context Transition if (type == TransitionType::NORMALTERMINATION)
	ERROR "Simple states may not have a normal termination transition" :
	((sourceState.regions.size!=0)  || (sourceState.type == StateType::REFERENCE) || (sourceState.type == StateType::TEXTUAL));

context Transition if (type == TransitionType::STRONGABORT)
    WARNING "Strong aborts on simple states don't make sense." :
    ((sourceState.regions.size!=0)  || (sourceState.type == StateType::REFERENCE) || (sourceState.type == StateType::TEXTUAL));


context Transition if(sourceState.outgoingTransitions.size > 1) 
    ERROR "Priorities of outgoing transitions need to be distinct!" :
    (sourceState.outgoingTransitions.forAll(t| (priority != t.priority || this == t)));
 
 context Transition if(sourceState.type==StateType::CONDITIONAL) 
    ERROR "Transitions of conditionals must be immediate!" :
    (isImmediate);
    
context Transition
	ERROR "SyncCharts do not support inter-level transitions!\nOnly use transitions between states in the same region!\nYou can use final states and normal termination transitions to emulate inter-level transition behavior.":
	(sourceState.parentRegion == targetState.parentRegion);

// ================================================================================================
// Expressions
// FIXME: Problem is that checks done in a strange context are not displayed in the model as markers, 
// Use only valid contexts for checks. Otherwise only the problem view shows the error.
context OperatorExpression if ((operator == OperatorType::NOT) || (operator == OperatorType::VAL)) ERROR "Unary operators may not have more or less than one operand!" :
	subExpressions.size == 1;
	
context OperatorExpression if (!((operator == OperatorType::NOT) || (operator == OperatorType::VAL) || (operator == OperatorType::PRE))) ERROR "Binary operators may not have more or less than two operands!" :
	subExpressions.size == 2;

// ================================================================================================
// Emissions
	
context Emission if (signal.type == ValueType::PURE) ERROR "Pure signals cannot be assigned a value! (" +signal.name+")" :
	newValue == null;
	
context Emission if (!(signal.type == ValueType::PURE)) ERROR "Valued signals must be assigned a value! (" +signal.name+")" :
	newValue != null;
	
// ================================================================================================
// Actions

context Action if (label != null && label.trim().compareTo("") != 0 ) 
    ERROR "Triggers and Effects String has not correctly been parsed yet! Action children are empty
           but triggers and effects string contains text." :
    (trigger != null || (effects!=null && effects.size >0) || this.isImmediate);
    
// Only Transitions can have a triggers without effects
context Action if (eContainer.metaType.toString().matches("State"))
	ERROR "Trigger must have an effect." :
	effects.size > 0;
