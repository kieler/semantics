\chapter{Concepts}
\label{chapter:AutoConcepts}

\section{Setting up an Automated Run}
\label{section:AutoConceptsSetup}
There are several possibilities of how to solve the problem of accumulating
large amounts of information prior to a long running action.
The first possibility would be to have the user enter the paths to the 
necessary files in text files, parse those files and start a run with
the parsed information. While this is a good method for performing
static runs from a console environment it has several disadvantages
inside the GUI of an Eclipse RCA:
\begin{itemize}
 \item Manually entered file names in a text file are prone to have erroneous information.
It is very hard to manually enter the correct file name of any file and the entered location
only works on one OS. Aside from that it takes a long time to manually enter the possible wast
amount of files used.
 \item There is no way to quickly adjust the file if other models or execution files should be used.
 \item It also means more files cluttering up the workspace.
 \item It is not very intuitive and the user has to know the exact syntax that the execution needs.
\end{itemize}

A far easier approach is the selection of the files through the use of a dialog.
Here the first option is to write a new Dialog from scratch. While this option
ensures flexibility since only the elements that are really needed are on it in
exactly the way they are needed it has also a few downsides:
\begin{itemize}
 \item It involves a lot of work since every widget has to be manually placed on the dialog.
 \item It involves even more work to get the layout of the dialog just right.
\end{itemize}

The easiest way it to use one of the dialogs provided by Eclipse specifically the wizard type dialog.
Eclipse itself uses a host of wizards as explained in [ref here].
The wizard has several advantages over the other methods explained here:
\begin{itemize}
 \item Even inexperienced users can be guided to set up a valid execution run.
 \item The entered information is most likely valid since the wizard only displays valid files.
 \item It is quicker to program and easier to adjust than any of the other methods.
\end{itemize}


\section{Input for the Automation}
\label{section:AutoConceptsInput}
In order to input information into the DataComponents the first decision has to be in
what form the information will be supplied.
The chosen form is that of a list of key, value pairs. It allows for the most
flexiblility while still being very generic and simple to read and write on.
This list of properties will at least include the path to the model file in order
for components to be executed with several different model files without having
to alter the code between runs.

The next question is how the components will get the information.

The first possibility would be to have the component ask the plug-in for the information
in question. The upside of this would be that components are sure to get all the information
they need before the execution can start since they can keep asking for it. However this would
likely mean that the component would have to ask multiple times as they cannot know when
the required information will be available which constitutes additional workload. Furthermore
this situation would likely mean that multiple components might request information
at the same time. This means that there would be the need for substantial synchronization mechanisms
to ensure consistency of data.

Therefore the way chosen in this thesis is that the Execution Manager will inform interested components
about all properties that were accumulated and then starts the execution run. This ensures
that a run is started in any event and keeps communication between the components and the manager simple.

\section{Automate the execution}
\label{section:AutoConceptsExecution}
Automating the execution itself requires the plug-in to interact with the KIEM.
There is already an API defined for loading an execution file by supplying a path so that
is what will be used in this project.
Then it is neccasary to initialize the execution and step through it using the API
methods provided in the Execution. For this the EventListener extension point of the 
KIEM can also be used in order to determine when a step has finished executing and
a new one can be dispatched.
After the execution is finished all components should be called again to be given
a chance to provide some information for the display in the next step. This information
will be gathered in the same form and way as described in [ref to pref section].


\section{Output of the results of the execution}
\label{section:AutoConceptsOutput}
On the subject of displaying the information again several options
are available.


The last objective is to display the information in a meaningful way.
This should involve at least two methods of output:
\begin{enumerate}
  \item A formatted string possibly in an XML fashion that can be parsed and
  used by other plug-ins for automatic analysis.
  \item Some graphic component that will display the information in way that is
  easy to read for most users.
\end{enumerate}