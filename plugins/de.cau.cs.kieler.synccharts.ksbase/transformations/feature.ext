import synccharts;
import kexpressions;
import utilities;

extension repair;
extension dialogs;

// start from selected state
Void fixSelected(State state):
 fix(state)
;

// start from selected region (root region is usually best)
Void fixSelected(Region rootRegion):
 fix(rootRegion)
;

//Adds a successor to the given state 
Void addSuccessorState(State source):
 let target = new State:
 connectStates(source, target) ->
 source.parentRegion.states.add(target) ->
 setSelection(target)
;
 
Void addSuccessorStates(List[State] states):
 states.addSuccessorState()
;

//Adds a predecessor to the given state
Void addPredecessorState(State target):
let source = new State:
connectStates(source,target) ->
target.parentRegion.states.add(source) ->
(target.isInitial == true) ?
    (target.setIsInitial(false) ->
    source.setIsInitial(true)) : 
setSelection(source)
;

//Adds a choice to the given state
//by adding a conditional with two
//targets.
Void addChoice(State source):
let choice = new State:
let opt1 = new State:
let opt2 = new State:
let t1 = new Transition:
let t2 = new Transition:
// haf: no default name: choice.setLabel("C1") ->
choice.setType(StateType::CONDITIONAL) ->
// haf: no default name: opt1.setLabel("S0") ->
// haf: no default name: opt2.setLabel("S1") ->
connectStates(source,choice) ->
t1.setSourceState(choice) ->
t1.setTargetState(opt1) ->
t1.setPriority(1) ->
t2.setSourceState(choice) ->
t2.setTargetState(opt2) ->
t2.setPriority(2) ->
source.parentRegion.states.add(choice) ->
source.parentRegion.states.add(opt1) ->
source.parentRegion.states.add(opt2)
;

//Flips source and target of the 
//given transition.
Void flipTransition(Transition t):
 let source = t.sourceState:
 let target = t.targetState: 
 t.setSourceState(target) ->
 t.setTargetState(source) ->
 setSelection(t) 
;

//Converts transitions into strong abort
Void setStrong(Transition t):
 t.setType(TransitionType::STRONGABORT) ->
 setSelection(t) 
;

//Converts transitions into weak abort
Void setWeak(Transition t):
 t.setType(TransitionType::WEAKABORT) ->
 setSelection(t) 
;

//Converts transitions into normaltermination
Void setNormalTermination(Transition t):
 t.setType(TransitionType::NORMALTERMINATION) ->
 setSelection(t) 
;

//Inserts a state in a transition
Void insertState(Transition t):
 let source = t.sourceState:
 let target = t.targetState:
 let newState = new State:
 t.setTargetState(newState) ->
 connectStates(newState, target) ->
 source.parentRegion.states.add(newState) ->
 setSelection(newState)
;
//Connects two states
Void connectStates(State source, State target):
let transition = new Transition:
transition.setSourceState(source) ->
transition.setTargetState(target) ->
setSelection(transition)
;

// create a self loop of one state
Void addSelfLoop(State state):
  connectStates(state, state)
;

//Reroutes the target of the given transition
//to the given state
Void rerouteTransitionTarget(Transition t, State target):
t.setTargetState(target)
;
Void rerouteTransitionTarget(State target, Transition t):
 rerouteTransitionTarget(t, target)
;

//Reroutes the source of the given transition
//to the given state
Void rerouteTransitionSource(Transition t, State source):
t.sourceState.outgoingTransitions.remove(t) ->
t.setSourceState(source) ->
source.outgoingTransitions.add(t)
;
Void rerouteTransitionSource(State source, Transition t):
 rerouteTransitionSource(t, source)
;

//Adds a parallel region to the given state
Void upgradeState(State parentState):
let region = new Region:
let state = new State:
let index = parentState.regions.size:
state.setIsInitial(true) ->
// haf: no name by default state.setLabel("Initial") ->
region.states.add(state) ->
// haf: no name by default region.setLabel("R" + index) ->
parentState.regions.add(region) ->
setSelection(state)
;

Void downgradeState(State parentState):
if parentState.regions.size > 0 then
 parentState.regions.removeAll(parentState.regions) ->
 parentState.signals.removeAll(parentState.signals)
;

//Returns true if the state is a complex state, 
//i.e. it has at least one inner region
Boolean isRegionState(State state):
    state.regions.size > 0
;

//Sets the object that should be selected after the transformation is executed
Void setSelection(Object object):
JAVA de.cau.cs.kieler.ksbase.ui.kivi.KSBasECombination.selectObject(java.lang.Object)
//JAVA de.cau.cs.kieler.ksbase.ui.kivi.KSBasECombination.select(java.lang.Object)
 //JAVA de.cau.cs.kieler.ksbase.ui.utils.TransformationUtils.setPostTransformationSelection(java.lang.Object)
;

//Checks if the state is the root state.
Boolean isNoRootState(State state): 
    state.parentRegion.parentState != null
;

Boolean isNoRootState(State s1, State s2):
	s1.isNoRootState() && s2.isNoRootState()
;

Boolean statesOnSameHierarchy(State s1, State s2):
	s1.parentRegion == s2.parentRegion
;

Boolean isNoRootState(List[State] states):
    states.notExists(e|e.parentRegion.parentState == null)
;

Boolean isNoRootRegion(Region region):
 region.parentState != null
;

Boolean isNoRootRegion(Region r1, Region r2):
 r1.parentState != null && r2.parentState != null
;

Boolean isNoRootRegion(List[Region] regions):
 regions.notExists(e|e.parentState == null)
;

Boolean hasNoRootState(State s, Transition t):
 s.parentRegion.parentState != null
;

Boolean hasNoRootState(Transition t, State s):
 s.parentRegion.parentState != null
;

Boolean isSimpleState(State s):
 !s.hasSignalsVariables() 
    && s.regions.isEmpty 
    && s.entryActions.isEmpty 
    && s.innerActions.isEmpty
    && s.exitActions.isEmpty
    && s.suspensionTrigger == null
;

Boolean isNotASimpleState(State s):
 !s.isSimpleState()
;

Boolean isSourceASimpleState(Transition t):
 t.sourceState.isSimpleState()
;

Boolean isSourceNotASimpleState(Transition t):
 t.sourceState.isNotASimpleState()
;

Boolean canTurnIntoNormalTermination(Transition t):
 t.isSourceNotASimpleState() && t.type != TransitionType::NORMALTERMINATION
;

Boolean canTurnIntoStrongAbort(Transition t):
 t.isSourceNotASimpleState() && t.type != TransitionType::STRONGABORT
;

Boolean canTurnIntoWeakAbort(Transition t):
 t.type != TransitionType::WEAKABORT
;

Void toggleInitial(State s):
 s.setIsInitial(!s.isInitial)
;

Void toggleFinal(State s):
 s.setIsFinal(!s.isFinal)
;

Void toggleStateInitialFinal(State s):
 switch{
 	case s.isInitial && s.isFinal: (s.setIsInitial(false) -> s.setIsFinal(false))
 	case s.isInitial: s.setIsFinal(true)
 	case s.isFinal: (s.setIsFinal(false) -> s.setIsInitial(true))
 	default: (s.setIsFinal(true) -> s.setIsInitial(false))
 }
;

// Add a state to the parent state and add all Regions
// to that new State
Void encapsulateRegions(State parentState):
  let regions = parentState.regions:
  let newRegion = new Region:
  let newState = new State:
  (parentState.regions.size > 0) ? 
    (newState.regions.addAll(regions) ->
    parentState.regions.add(newRegion) ->
    // haf: no default name: newRegion.setLabel("R" + parentState.regions.size) ->
    newRegion.states.add(newState)) : 
   null
;

// Delete the state and move all its regions to the
// parent state 
Void flattenState(State state):
let parentRegion = state.parentRegion:
let parentState = parentRegion.parentState:
let stateSize = parentRegion.states.size:
let incoming = state.incomingTransitions:
let outgoing = state.outgoingTransitions:
incoming.setSourceState(state) ->
outgoing.setTargetState(state) ->
parentState.regions.addAll(state.regions) ->
parentRegion.states.remove(state) ->
if (stateSize <= 1) then parentState.regions.remove(parentRegion)
;

List[State] getStateList():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.FixSyncChartUtils.getStateList()
;

Void myDebug(Object object):
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.FixSyncChartUtils.debug(java.lang.Object)
;

// put the selected region into a new state and add
// that state to a region in the selected regions parent state
Void encapsulateRegion(Region target):
 let newState = new State:
 let newRegion = new Region:
 if (target.parentState != null) then (
   newState.setIsInitial(true) ->
   // haf: no default name:  newRegion.setLabel("R" + target.parentState.regions.size) ->
   target.parentState.regions.add(newRegion) ->
   newRegion.states.add(newState) ->
   newState.regions.add(target) ->
   setSelection(newState)
 )
;

Void encapsulateRegion(List[Region] targets):
 let newState = new State:
 let newRegion = new Region:
 let parent = targets.get(0).parentState:
 newState.setIsInitial(true) ->
 // haf: no default name: newRegion.setLabel("R" + parent.regions.size) ->
 parent.regions.add(newRegion) ->
 newRegion.states.add(newState) ->
 newState.regions.addAll(targets) ->
 setSelection(newState)
;

Void flattenRegion(Region target):
 let parentState = target.parentState:
 let parentRegion = parentState.parentRegion:
 parentRegion.states.addAll(target.states) ->
 parentState.regions.remove(target) ->
 if (parentState.regions.isEmpty) then
   parentRegion.states.remove(parentState)
;

Void flattenRegion(List[Region] target):
 let parentState = target.get(0).parentState:
 let parentRegion = parentState.parentRegion:
 target.states.setParentRegion(parentRegion) ->
 parentState.regions.removeAll(target) ->
 if (parentState.regions.isEmpty) then
   parentRegion.states.remove(parentState)
;

/////////////////////////
//     Templates      ///
/////////////////////////

Boolean isRootRegion(Region region):
 region.parentState == null
;

//Creates a default StateChart
Void createDefault(Region rootRegion):
let state = new State:
let innerState = new State:
let region = new Region:
state.setLabel(getFileNameOfActiveEditor()) ->
state.regions.add(region) ->
// haf: no default name: innerState.setLabel("Initial") ->
innerState.setIsInitial(true) -> 
region.states.add(innerState) ->
// haf: no default name: region.setLabel("R0") ->
rootRegion.states.add(state) ->
setSelection(innerState)
;

String getFileNameOfActiveEditor():
JAVA de.cau.cs.kieler.ksbase.ui.utils.TransformationUtils.getFileNameOfActiveEditor()
;

//Adds an initial state to a region
Void addState(Region target):
 let state = new State:
 (if (target.states.isEmpty) then
  (// haf: no default name: state.setLabel("Initial") ->
   state.setIsInitial(true))
  ) ->
 target.states.add(state) ->
 setSelection(state)
;

// Helper method to set the label on a transition
Void setLabel(Action action, String label):
 JAVA de.cau.cs.kieler.synccharts.ksbase.SyncchartsKsbasePlugin.setLabel(de.cau.cs.kieler.synccharts.Action, java.lang.String)
;
 
//Good ol' ABRO
Void addABRO(Region rootRegion):
let waitABToFinal = new Transition:
let reset = new Transition:
let ABOFinal = new State:
let wATrans = new Transition:
let wBTrans = new Transition:
let wAInitial = new State:
let wAFinal = new State:
let wBInitial = new State:
let wBFinal = new State:
let wA = new Region:
let wB = new Region:
let waitAB = new State:
let ABORegion = new Region:
let ABO = new State:
let innerRootRegion = new Region:
let sigA = new Signal:
let sigB = new Signal:
let sigR = new Signal:
let sigO = new Signal:
let sigAExpr = new ValuedObjectReference:
let sigBExpr = new ValuedObjectReference:
let sigOExpr = new Emission:
let sigRExpr = new ValuedObjectReference:
let root = new State:
//ABRO Root State
root.setLabel("ABRO") ->
//ABRO Signal definition:
sigA.setName("A") ->
sigA.setIsInput(true) ->
sigAExpr.setValuedObject(sigA) ->
sigB.setName("B") ->
sigB.setIsInput(true) ->
sigBExpr.setValuedObject(sigB) ->
sigR.setName("R") ->
sigR.setIsInput(true) ->
sigRExpr.setValuedObject(sigR) ->
sigO.setName("O") ->
sigO.setIsOutput(true) ->
sigOExpr.setSignal(sigO) ->
root.signals.add(sigA) ->
root.signals.add(sigB) ->
root.signals.add(sigR) ->
root.signals.add(sigO) ->
//Inner State ABO
ABO.setLabel("ABO") ->
ABO.setIsInitial(true) ->
//Inner state Wait A and B
waitAB.setLabel("WaitAB") ->
waitAB.setIsInitial(true) ->
//Region for 'wait for a' 
wAInitial.setLabel("wA") ->
wAInitial.setIsInitial(true) ->
wA.states.add(wAInitial) ->
//wA.setLabel("wA") -> use anonymous regions for ABRO
wAFinal.setLabel("dA") ->
wAFinal.setIsFinal(true) ->
wA.states.add(wAFinal) ->
wATrans.setSourceState(wAInitial) ->
wATrans.setTargetState(wAFinal) ->
//wATrans.setTrigger(sigAExpr) ->
setLabel(wATrans, "A") ->
waitAB.regions.add(wA) ->
//Region for 'wait for b'
wBInitial.setLabel("wB") ->
wBInitial.setIsInitial(true) ->
wB.states.add(wBInitial) ->
//wB.setLabel("wB") -> use anonymous regions for ABRO
wBFinal.setLabel("dB") ->
wBFinal.setIsFinal(true) ->
wB.states.add(wBFinal) ->
wBTrans.setSourceState(wBInitial) ->
wBTrans.setTargetState(wBFinal) ->
//wBTrans.setTrigger(sigBExpr) ->
setLabel(wBTrans, "B") ->
waitAB.regions.add(wB) ->
//ABO final state
ABOFinal.setLabel("done") ->
waitABToFinal.setSourceState(waitAB) ->
waitABToFinal.setTargetState(ABOFinal) ->
waitABToFinal.setType(TransitionType::NORMALTERMINATION) ->
//waitABToFinal.effects.add(sigOExpr) ->
setLabel(waitABToFinal, "/O") ->
ABORegion.states.add(waitAB) ->
//ABORegion.setLabel("ABO") -> use anonymous regions for ABRO
ABORegion.states.add(ABOFinal) ->
ABO.regions.add(ABORegion)->
reset.setSourceState(ABO) ->
reset.setTargetState(ABO) ->
reset.setType(TransitionType::STRONGABORT) ->
//reset.setTrigger(sigRExpr) ->
setLabel(reset, "R") ->
innerRootRegion.states.add(ABO) ->
//innerRootRegion.setLabel("R0") -> use anonymous regions for ABRO
root.regions.add(innerRootRegion) ->
rootRegion.states.add(root)
;

// determine whether a scope contains signals or variables
Boolean scopeHasSignalsVariables(Scope scope):
 (scope.signals.size > 0 || scope.variables.size > 0)
;

// delegate methods
Boolean hasSignalsVariables(Region region):
 scopeHasSignalsVariables(region)
;
Boolean hasSignalsVariables(State state):
 scopeHasSignalsVariables(state)
;

// get an empty string list from java for creating a list for user selection
List[String] getStringList():
 JAVA de.cau.cs.kieler.synccharts.ksbase.util.FixSyncChartUtils.getStringList()
;

// create a list for user selection with all signal and variable names
List unionOfSignalsAndVariables(Scope scope):
 let list = getStringList():
 list.removeAll(list) ->
 list.addAll(scope.signals.name) ->
 list.addAll(scope.variables.name) ->
 list
;

// entry point for the renaming of signals/variables inside a scope
Void renameSignalVariable(State scope):
 scopeRenameSignalVariable(scope)
;
Void renameSignalVariable(Region scope):
 scopeRenameSignalVariable(scope)
;
 
// open a dialog and ask the user to select the signal/variable to rename
Void scopeRenameSignalVariable(Scope scope):
 let choice = unionOfSignalsAndVariables(scope):
 let oldName = (String) getListSelectionFromUserIntern("Select signal or variable to rename", choice):
 if (oldName != null) then scopeRenameSignalVariableStep2(scope, oldName)
;

// open a dialog and ask the user for a new name for the signal
Void renameSignal(Signal signal):
 let newName = getStringFromUserIntern("Enter new name for Signal " + signal.name + "!", "newName"):
 if (newName != null) then signal.setName(newName)
;

// open a dialog and ask the user for a new name for the signal or variable
Void scopeRenameSignalVariableStep2(Scope scope, String oldName):
 let newName = getStringFromUserIntern("Enter new name for Signal or Variable " + oldName + "!", "newName"):
 if (newName != null) then scopeRenameSignalVariableStep3(scope, oldName, newName)
;

// find the signal or variable referenced by the old name and rename it
Void scopeRenameSignalVariableStep3(Scope scope, String oldName, String newName):
 let var = findVariable(scope, oldName):
 let sig = findSignal(scope, oldName):
 (if (var != null) then renameVariable(scope, var, newName)) ->
 (if (sig != null) then renameSignal(scope, sig, newName))
;

// rename a signal
Void renameSignal(Scope scope, Signal signal, String newName):
 let oldName = signal.name:
 signal.setName(newName)
;

// rename a variable
Void renameVariable(Scope scope, Variable var, String newName):
 let oldName = var.name:
 var.setName(newName)
;

// find a variable at the toplevel of a scope
Variable findVariable(Scope scope, String name):
 scope.variables.selectFirst(var|var.name.matches(name))
;

// find a signal at the toplevel of a scope
Signal findSignal(Scope scope, String name):
 scope.signals.selectFirst(e|e.name.matches(name))
; 
