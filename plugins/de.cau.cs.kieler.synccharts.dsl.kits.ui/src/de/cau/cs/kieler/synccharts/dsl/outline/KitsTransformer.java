/*
 * generated by Xtext
 */
package de.cau.cs.kieler.synccharts.dsl.outline;

import java.util.List;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.ui.statushandlers.StatusManager;
import org.eclipse.xtext.ui.common.editor.outline.ContentOutlineNode;
import org.eclipse.xtext.ui.common.editor.outline.transformer.AbstractDeclarativeSemanticModelTransformer;

import de.cau.cs.kieler.synccharts.Action;
import de.cau.cs.kieler.synccharts.Signal;
import de.cau.cs.kieler.synccharts.State;
import de.cau.cs.kieler.synccharts.Transition;

/**
 * customization of the default outline structure
 * 
 */
public class KitsTransformer extends
        AbstractDeclarativeSemanticModelTransformer {
    /**
     * @modified oba
     */
    List<ContentOutlineNode> myContentOutlineNodes;

    /**
     * This method will be called by naming convention: - method name must be
     * createNode - first param: subclass of EObject - second param:
     * ContentOutlineNode
     * 
     */
    public ContentOutlineNode createNode(State semanticState,
            ContentOutlineNode parentNode) {
        ContentOutlineNode node = super.newOutlineNode(semanticState,
                parentNode);
        String myStateType = null;
        String myStateId = null;
        String myStateLabel = null;
        String nodeLabel = "";

        /**
         * init myState "myStateLabel" --> init myState:"myStateLabel"
         */
        if (semanticState.getType() != null
                && semanticState.getType().getName() != "NORMAL") {
            myStateType = semanticState.getType().getName();
            nodeLabel = myStateType + " state ";
        }

        /*
         * States always have to have an ID. Otherwise handle the error by using
         * a pop-up of the Status Manager.
         */
        try {
            myStateId = semanticState.getId();
            nodeLabel = nodeLabel + myStateId;
        } catch (Exception e) {
            Status myStatus = new Status(IStatus.WARNING, "KITS Editor Plugin",
                    "Kits Formatter found a state without an ID", e);
            StatusManager.getManager().handle(myStatus, StatusManager.SHOW);
        }
        /*
         * Add the state label to the outline label IF it is different than the
         * state ID
         */
        assert semanticState.getId() != null;
        if (semanticState.getLabel() != null
                && !(semanticState.getLabel().trim().equals(""))
                && !(semanticState.getLabel().equals(semanticState.getId()))) {
            myStateLabel = semanticState.getLabel();
            nodeLabel = nodeLabel + " : \" " + myStateLabel + "\"";
        }

        node.setLabel(nodeLabel);
        return node;
    }

    public ContentOutlineNode createNode(Action semanticAction,
            ContentOutlineNode parentNode) {
        ContentOutlineNode node = super.newOutlineNode(semanticAction,
                parentNode);

        String actionKeyword = "";
        // onexit "anExitAction" --> onExit : anExitAction
        if (semanticAction.eContainingFeature().getName() == "entryActions") {
            actionKeyword = "on entry";
            if (semanticAction.getTriggersAndEffects() != null) {
                actionKeyword = actionKeyword + " : "
                        + semanticAction.getTriggersAndEffects();
            }
        }
        if (semanticAction.eContainingFeature().getName() == "exitActions") {
            actionKeyword = "on exit";
            if (semanticAction.getTriggersAndEffects() != null) {
                actionKeyword = actionKeyword + " : "
                        + semanticAction.getTriggersAndEffects();
            }
        }
        if (semanticAction.eContainingFeature().getName() == "innerActions") {
            actionKeyword = "inner action";
            if (semanticAction.getTriggersAndEffects() != null) {
                actionKeyword = actionKeyword + " : "
                        + semanticAction.getTriggersAndEffects();
            }
        }
        if (semanticAction.eContainingFeature().getName() == "suspensionTrigger") {
            actionKeyword = "suspended";
            if (semanticAction.getTriggersAndEffects() != null) {
                actionKeyword = actionKeyword + " when "
                        + semanticAction.getTriggersAndEffects();
            }
        }
        if (semanticAction.isIsImmediate()) {
            actionKeyword = "# " + actionKeyword;
        }
        node.setLabel(actionKeyword);
        return node;
    }

    public ContentOutlineNode createNode(Transition semanticTransition,
            ContentOutlineNode parentNode) {
        ContentOutlineNode node = super.newOutlineNode(semanticTransition,
                parentNode);

        /**
         * Example: A --> B; note: each transition has a type
         */
        String transitionLabel = semanticTransition.getType().toString();

        /**
         * from A
         */
        if (semanticTransition.getSourceState() != null) {
            State semanticSource = semanticTransition.getSourceState();
            if (semanticSource.getLabel() != null
                    && !(semanticSource.getLabel().trim().equals("")))

            {
                transitionLabel = transitionLabel + " from "
                        + semanticTransition.getSourceState().getLabel();
            }
        }
        /**
         * from A to B
         */
        if (semanticTransition.getTargetState() != null) {
            State semanticTarget = semanticTransition.getTargetState();
            if (semanticTarget.getLabel() != null
                    && !(semanticTarget.getLabel().trim().equals(""))) {
                {
                    transitionLabel = transitionLabel + " to "
                            + semanticTransition.getTargetState().getLabel();
                    node.setLabel(transitionLabel);
                }
                return node;
            }
            if (semanticTarget.getId() != null
                    && !(semanticTarget.getId().trim().equals(""))) {
                transitionLabel = transitionLabel + " to "
                        + semanticTransition.getTargetState().getId();
                node.setLabel(transitionLabel);
            }
            return node;

        }
        node.setLabel(transitionLabel);
        return node;
    }

    public ContentOutlineNode createNode(Signal semanticSignal,
            ContentOutlineNode parentNode) {
        ContentOutlineNode node = super.newOutlineNode(semanticSignal,
                parentNode);

        String signalLabel = "";
        if (semanticSignal.isIsInput()) {
            signalLabel = "input " + semanticSignal.getName();
        }
        if (semanticSignal.isIsOutput()) {
            signalLabel = "output " + semanticSignal.getName();
        }
        // if (semanticSignal.isIsInputOutput()) {
        // signalLabel = "input output " + semanticSignal.getName();
        // }
        node.setLabel(signalLabel);
        return node;
    }

    /**
     * This method will be called by naming convention: - method name must be
     * getChildren - first param: subclass of EObject
     */
    // public List<EObject> getChildren(State s) {
    // return s.eContents();
    // }
}
