/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 * 
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2015 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.prom.templates

import com.google.common.base.Charsets
import com.google.common.io.Files
import com.google.common.io.LineProcessor
import de.cau.cs.kieler.prom.configurable.ResourceSubstitution
import freemarker.template.Template
import java.io.File
import java.io.IOException
import java.io.StringWriter
import java.util.List
import java.util.Map
import java.util.regex.Pattern
import org.eclipse.core.resources.IFile
import org.eclipse.emf.ecore.EObject

/**
 * This class generates wrapper code for models.
 * Annotations are mapped to macro calls which are injected in the input template.
 * Afterwards the macro calls are evaluated by the template engine and the wrapper code which they define is inserted.
 * 
 * @author aas
 */
class TemplateManager {

    /**
     * A template variable which is replaced with the name of the last analyzed model.
     */
    public static val MODEL_NAME_VARIABLE = "model_name"
    
    /**
     * The variable name in the target template
     * for code generated by KiCo.
     */
    public static val KICO_GENERATED_CODE_VARIABLE = "kico_code"
    
    /**
     * Macro definitions to use <@init>, <@input>, <@output> in wrapper code snippets.
     */
    private static var String macroDefinitions = null
    
    /**
     * Processes the template context.
     * 
     * @param config The template context
     * @return the code after the template has been processed
     */
    public static def String process(TemplateContext config) {
        if(config.templateFile == null) {
            return ""
        }
        
        // Prepare template engine
        val project = config.templateFile.project
        val templatePath = config.templateFile.projectRelativePath.toOSString
        FreemarkerConfiguration.newConfiguration(project.location.toOSString)
        // The Freemarker template that will be processed 
        var Template template
        // The variables that are set in the template
        val map = newHashMap
        
        // Add additional mappings from configuration
        if(config.additionalMappings != null) {
            map.putAll(config.additionalMappings)
        }
        
        // Get mapping of macro calls
        if(config.macroCallDatas != null) {
            val templateCodeWithMacroCalls = getTemplateCodeWithMacroCalls(config.templateFile, config.macroCallDatas)

            // Debug log macro calls
//            System.err.println(templateCodeWithMacroCalls)

            // Add implicit include of assignment macros such as <@init> and <@output>
            FreemarkerConfiguration.stringTemplateLoader.putTemplate("injectionMacros", getOrInitializeMacroDefinitions )
            FreemarkerConfiguration.configuration.addAutoInclude("injectionMacros")
            // Get template with macro calls and now implicitly loaded snippet definitions.
            template = new Template("templateWithMacroCalls", templateCodeWithMacroCalls, FreemarkerConfiguration.configuration)
        } else {
            template = FreemarkerConfiguration.configuration.getTemplate(templatePath)
        }
        
        // Add the template name, path, location, etc. to the mapping
        var templateFileSubstitution = new ResourceSubstitution("template") {
            override getValue() {
                config.templateFile
            }
        }
        map.putAll(templateFileSubstitution.variableMappings)
        
        // Process the template with the all mappings
        val writer = new StringWriter()
        template.process(map, writer)
        // Return the result
        val text = writer.toString()
        writer.close
        return text
    }

    /**
     * Searches for wrapper code annotations in the models
     * and injects macro calls accordingly in the template.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     * @param annotationDatas The annotations that injected as macro calls
     * @return a String with the input template,
     *         where placeholders for the different phases are replaced with the corresponding macro calls
     *         that have been injected.
     */
    private static def String getTemplateCodeWithMacroCalls(IFile templateFile, List<MacroCallData> macroCallDatas) {
        // Create macro calls from annotations
        val map = getMappingOfPhasePlaceholders(macroCallDatas)
        // Processor that injects macro calls in input template
        val lineProcessor = new LineProcessor<String>() {
            String text = ""
            
            override getResult() {
                return text
            }
            
            override processLine(String line) throws IOException {
                // Replace placeholders in the line
                // Freemarker should process the templates only after the macro calls have been injected.
                // Otherwise things like includes are processed, not needed in this case, yet gone in the next iteration,
                // in which macro calls should be processed.
                // Thus, injecting the macro calls is done here, before Freemarker is used.
                var lineWithoutPlaceholders = line
                for(entry : map.entrySet) {
                    val placeholderRegex = Pattern.quote("${"+entry.key+"}")
                    lineWithoutPlaceholders = lineWithoutPlaceholders.replaceAll(placeholderRegex, entry.value)
                }
                text += lineWithoutPlaceholders+"\n"
                // Continue reading the lines
                return true
            }
        }
        val code = Files.readLines(new File(templateFile.location.toOSString),
                                   Charsets.UTF_8,
                                   lineProcessor)
        return code
    }

    /**
     * Initializes the macro definitions when they are not yet initialized.
     * Afterwards they are returned.
     * 
     * @return the macro definitions of assignment macros such as <@input>
     */
    private static def String getOrInitializeMacroDefinitions() {
        // Initialize if not done yet
        if(macroDefinitions == null){
            macroDefinitions = ""
            
            for(phase : CodeGenerationPhase.PHASES ){
                for(macro : phase.injectionMacros){
                    macroDefinitions += macro.freeMarkerDefinition
                    macroDefinitions += "\n"
                }                
            }
        }
        return macroDefinitions
    }
    
    /**
     * Creates macro calls from wrapper code annotation datas.
     * 
     * @param annotationDatas List with the datas to generate macro calls for 
     * @return a map where the keys 'inits', 'inputs' and 'outputs'
     *         are mapped to the corresponding macro calls for the given annotations.
     */
    private static def Map<String, String> getMappingOfPhasePlaceholders(MacroCallData... macroCallDatas) {
        val Map<String, String> map = newHashMap
        
        // The assignment macros such as <@init> and <@output> use a variable
        // to determine if their snippet should be inserted.
        for(phase : CodeGenerationPhase.PHASES) {
            phase.codeToInject = phase.freeMarkerAssignment+"\n"
        }

        // Keep track of the annotations that were already seen before in this collection
        val doneDatas = <MacroCallData> newHashSet
        var isDoneAlready = false
        
        // Add macro calls for annotations to the different phases
        var MacroCallData prev = null; 
        for (data : macroCallDatas) {
            
            isDoneAlready = true
            if (!doneDatas.contains(data)) {
                doneDatas.add(data)
                isDoneAlready = false
            }

            for(phase : CodeGenerationPhase.PHASES) {
                // We initialize every annotation only once
                // although the same annotation might be used twice: as input and output.
                if(!phase.singleton || (phase.singleton && !isDoneAlready) ) {
                    // Use input annotations on inputs only, and output annotations on outputs only
                    if(phase.isApplicable(data)) {
                        // The macro of this annotation should be called in this phase
                        phase.codeToInject = phase.codeToInject + getTemplateCode(data)
                    }
                }
            }
            prev = data;
        }

        // Send FreeMarker the text to replace the placeholder of each phase
        for(phase : CodeGenerationPhase.PHASES) {
            map.putAll(phase.injectionMacroMappings)
        }
        return map
    }

    /**
     * Creates meta assignments and macro calls for an wrapper code annotation data.
     * 
     * @param data The annotation data
     * @return a string to set information about the variable which the annotation is used for.
     *         as well as the macro call for the annotation.    
     */
    private static def String getTemplateCode(MacroCallData data) {
        return getMetaAssignments(data) + getMacroCall(data);
    }

    /**
     * Creates a statements that sets meta information about the next variable to be used.
     * 
     * @param data The wrapper code annotation data 
     * @return a string which globally sets meta information.  
     */
    private static def String getMetaAssignments(MacroCallData data) {
        return '''<#assign varname = '«data.varName»' vartype = '«data.varType»' />'''+"\n"
    }

    /**
     * Creates a statement that calls a macro to generate code for the wrapper code annotation data.
     * 
     * @param data The wrapper code annotation data
     * @return a string with the macro call for an wrapper code annotation data.
     */
    private static def String getMacroCall(MacroCallData data) {
        var txt = ""
        // Ignore non existing macro <=> only call if macro exists
        if (data.ignoreNonExistingSnippet)
            txt += '''<#if «data.name»??>'''

        txt += '''<@«data.name» '''
        // Append arguments
        var boolean isBooleanArgument
        var boolean isFloatArgument
        for (String arg : data.arguments) {
            isBooleanArgument = (arg.equalsIgnoreCase("true") || arg.equalsIgnoreCase("false"))
            try {
                isFloatArgument = (Float.valueOf(arg) != null)
            } catch (NumberFormatException e) {
                isFloatArgument = false
            }
            val isNonStringArgument = isBooleanArgument || isFloatArgument
            // Only string arguments need to be surrounded by single quotation marks
            if(isNonStringArgument)
                txt += '''«arg» '''   
            else 
                txt += ''''«arg»' '''
        }
        // Close macro call
        txt += '''/>''';

        // Close if
        if (data.ignoreNonExistingSnippet)
            txt += '''</#if>'''
        
        txt += "\n"

        return txt
    }

    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def List<MacroCallData> getAnnotationInterface(EObject model) {
        val allDatas = <MacroCallData> newArrayList
        // Load EObject from file
        if (model != null) {
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : ModelAnalyzer.analyzers) {
                val datas = analyzer.getAnnotationInterface(model)
                if (datas != null) {
                    allDatas.addAll(datas)    
                }
            }
        }
        return allDatas
    }

    /**
     * Looks for the interface (inputs / outputs) in the model
     * and based on this, creates data objects suited for simulation of the model.
     * 
     * @param model The model
     * @param datas List to add found datas objects to
     */
    public static def List<MacroCallData> getSimulationInterface(EObject model) {
        val allDatas = <MacroCallData> newArrayList
        // Load EObject from file
        if (model != null) {
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : ModelAnalyzer.analyzers) {
                val datas = analyzer.getSimulationInterface(model)
                if (!datas.isNullOrEmpty) {
                    allDatas.addAll(datas)    
                }
            }
        }
        return allDatas
    }
    
    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def String getModelName(EObject model) {
        // Load EObject from file
        if (model != null) {
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : ModelAnalyzer.analyzers) {
                val modelName = analyzer.getModelName(model)
                if(modelName != null) {
                    return modelName
                }
            }
        }
    }
}