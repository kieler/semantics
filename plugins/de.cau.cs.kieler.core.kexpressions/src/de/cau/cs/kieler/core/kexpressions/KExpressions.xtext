/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 * 
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2010 by
 * + Christian-Albrechts-University of Kiel
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
grammar de.cau.cs.kieler.core.kexpressions.KExpressions with  de.cau.cs.kieler.core.annotations.text.Annotations

import "http://kieler.cs.cau.de/kexpressions/0.1.2" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Root returns ecore::EObject:
    Expression;

//Variable returns annotations::Annotatable:
//    (annotations += StringAnnotation)*;

// --------------------------
//
//   EXPRESSIONS
//
// --------------------------

Expression returns Expression:
     BoolExpression  
     | ValuedExpression
	;


// Example: not D and C or val(E) = 42 or not (A and (B or C))
BoolExpression returns Expression:
	OrExpression;


// Example: A or B, A and B and C, C and B or D and not E, A and B and C
OrExpression returns Expression:
	AndExpression ({OperatorExpression.subExpressions+=current} operator=OrOperator subExpressions+=AndExpression)*;


// Example: A and B, not C and 42 <= val(D)
AndExpression returns Expression:
	CompareOperation ({OperatorExpression.subExpressions+=current} operator=AndOperator subExpressions+=CompareOperation)*;
//	{OperatorExpression} subExpressions += CompareOperation (/*{OperatorExpression.subExpressions+=current}*/ operator=(AndOperator|OrOperator) subExpressions+=CompareOperation)*;


// Example: 42 <= val(A)
CompareOperation returns Expression:
	NotOrValuedExpression ({OperatorExpression.subExpressions+=current} operator=CompareOperator subExpressions+=NotOrValuedExpression)
	| NotExpression
	;


// order IS IMPORTANT
NotOrValuedExpression returns Expression:
	ValuedExpression
	| NotExpression
    ;


// Example: not A, not false, not (A or B)
// at the latter we need the parents to indicate the right binding
NotExpression returns Expression:
	{OperatorExpression} operator=NotOperator subExpressions+=(NotExpression)
    | AtomicExpression
    ;
  
    
// everything that evaluates to a primitive number value
ValuedExpression returns Expression:
	AddExpression;


// Example: 1 + 2
AddExpression returns Expression:
	SubExpression ({OperatorExpression.subExpressions+=current} operator=AddOperator subExpressions+=SubExpression)*;


// Example: varA - ?B
SubExpression returns Expression:
	MultExpression ({OperatorExpression.subExpressions+=current} operator=SubOperator subExpressions+=MultExpression)*;
//    ({OperatorExpression} subExpressions+=MultExpression (operator=SubOperator subExpressions+=MultExpression)+)
//	| ({OperatorExpression} subExpressions+=MultExpression subExpressions+=NIntValue)
//    | MultExpression;


// Example: 2 * 4
MultExpression returns Expression:
	DivExpression ({OperatorExpression.subExpressions+=current} operator=MultOperator subExpressions+=DivExpression)*;


// Example: (2 / 4)
// note: division always has to have parentheses because the '/' sign is also used for trigger/effect delimiter
DivExpression returns Expression:
	ModExpression ({OperatorExpression.subExpressions+=current} operator=DivOperator subExpressions+=ModExpression)?;
	

// Example: varA mod ?B
ModExpression returns Expression:
	NegExpression ({OperatorExpression.subExpressions+=current} operator=ModOperator subExpressions+=AtomicValuedExpression)?;


// Example: -?A, -(?A + ?B)
// at the latter we need the parents to indicate the right binding
NegExpression returns Expression:
	{OperatorExpression} operator=SubOperator subExpressions+=(NegExpression)
    | AtomicValuedExpression
    ;
  
    
AtomicExpression returns Expression:
    BoolValue
    | ValuedObjectTestExpression 
    | '(' BoolExpression ')'
    | TextExpression
    ;


AtomicValuedExpression returns Expression:
    IntValue
    | FloatValue | DoubleValue
//    | '(' DivExpression ')'
    | '(' ValuedExpression ')'
    | AtomicExpression 
    ;


// Example: pre(pre(val(A))), pre(val(pre(A))), val(A), A varX
ValuedObjectTestExpression returns Expression:
	{OperatorExpression} operator=(PreOperator|ValOperator)  '('subExpressions+=ValuedObjectTestExpression')'
	| ValuedObjectReference
	;


// Example: A, varB
ValuedObjectReference returns ValuedObjectReference:
	valuedObject=[ValuedObject|ID];


// Example: 'printf(...)'
TextExpression returns TextExpression:
	text=HOSTCODE;


IntValue returns IntValue:
	value=INT;

//NIntValue returns IntValue:
//	value=NINT;


FloatValue returns FloatValue:
	value=FLOAT;


BoolValue returns BoolValue:
	value=BOOLEAN;


DoubleValue returns DoubleValue:
    value=FLOAT;

// data type rule allowing any kind of value to be accepted,
// e.g. as initialValues of valuedObjects
// used in Kits.xtext 
AnyType returns ecore::EString:
    BOOLEAN | INT | FLOAT | ID | STRING;


// --------------------------
//
//  Interface Declarations
//
// --------------------------


//ISignal returns ISignal:
//	name=ID (channelDescr=ChannelDescription)?;

//InterfaceDeclaration:
//	(declarations+=ValuedObject ";")* ;

//ChannelDescription:
//	(":" type=TypeIdentifier)
//	| ("(" type=TypeIdentifier ")")
//	| (":=" expression=Expression ":" type=TypeIdentifier);

// Variables
//InterfaceVariableDecl:
//	"var" (varDecls+=VariableDecl) ("," varDecls+=VariableDecl)*;
	
//VariableDecl:
//	(variables+=IVariable) ("," variables+=IVariable)* ":" type=TypeIdentifier;

//IVariable:
//	 name=ID (":=" expression=Expression)?;

// transform ID to hostcode
//TypeIdentifier:
//	type=ValueType 
//	| typeID=ID
//	| ("combine" (type=ValueType | typeID=ID) "with" operator=CombineOperator);
	
	
	
//InterfaceDeclaration:
//  (declarations+= ValuedObjectDelaration ";")* ;
//
//
//ValuedObjectDelaration:
//    SignalDeclaration | SignalDeclaration
//;
//	
//SignalDeclaration returns Signal:
//    SignalDefinition
//;
//SignalDefinition:
//    (isInput?='input')? (isOutput?='output')? 'signal'
//    name=ID (':' (type=ValueType | typeID=ID)
//    ('=' varInitialValue=Expression)?
//    ('with' varCombineOperator=CombineOperator)?)? ';';


/************************************************/
/*           Variable Definition                */
/************************************************/
// A dummy VariableDefinition declaration, which will be override by an other grammar 
//VariableDefinition:
//  {VariableDefinition} 'variable' name=ID ';';
// CMOT changes, want to use VariableDefinitions from SyncText
//VariableDeclaration returns Variable:
//    VariableDefinition
//;
//VariableDefinition:
//    (isInput?='input')? (isOutput?='output')? (isStatic?='static')? (type=ValueType | typeID=ID) name=ID
//    ('=' initialValue=Expression)? ('with' varCombineOperator=CombineOperator)? ';';    
//	
	

// --------------------------
//
//  Terminals...
//
// --------------------------


enum CompareOperator returns OperatorType:
	EQ="==" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";

enum PreOperator returns OperatorType:
    PRE="pre";

enum OrOperator returns OperatorType:
	OR="|";

enum AndOperator returns OperatorType:
	AND="&";

enum NotOperator returns OperatorType:
	NOT="!";

enum AddOperator returns OperatorType:
	ADD="+";
	
enum SubOperator returns OperatorType:
	SUB="-";
	
enum MultOperator returns OperatorType:	
	MULT="*";

enum ModOperator returns OperatorType:	
	MOD="%";

enum DivOperator returns OperatorType:	
	DIV="/";

enum ValOperator returns OperatorType:
	VAL="val";


/*
   the following declarations are re-used in Actions.xtext, Interface.xtext, Kits.xtext 
*/
enum ValueType returns ValueType:
	PURE="pure" | BOOL="bool" | UNSIGNED="unsigned"	| 
	INT="int" | FLOAT="float" | DOUBLE="double" |
	STRING="string" | HOST="host";


enum CombineOperator returns CombineOperator:
	NONE="none" | ADD="+" | MULT="*" | MAX="max" |
	MIN="min" | OR="|" | AND="&" | HOST="host";


// custom terminal rule allowing to save transition label string as they are
terminal HOSTCODE returns ecore::EString: 
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'";